// Collected Java Source Files
// Generated by AllJavaFilesCollector

// =========================================
// File: /raja/ui/ComputeParametersDialog.java
// =========================================

/* $Id: ComputeParametersDialog.java,v 1.1.1.1 2001/01/08 23:10:15 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.ui;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.border.Border;


/**
 * Class defining the dialog for the ray tracing parameters.
 */
class ComputeParametersDialog extends JDialog
{
    private NumberTextField xResolTextField, yResolTextField, depthTextField;
    private JRadioButton defaultSamplingRadioButton, diadicSamplingRadioButton, antialiasSamplingRadioButton;
    private JComboBox antialiasLevelComboBox;
    private JCheckBox exactCheckBox;
    private String antialiasLevelString;

    int xResol, yResol, depth;
    int antialiasLevel;
    boolean diadic, antialias, exact;

    ComputeParametersDialog(Frame owner)
    {
        super(owner, "Ray tracing parameters", true);

        // Closing the dialog has the same effect as cancel
        setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
        addWindowListener(new WindowAdapter() {
                public void windowClosing(WindowEvent e) 
                {
                    restoreParameters();
                    setVisible(false);
                }
            });

        // Init fields of this dialog

        // Init text fields
        xResolTextField = new NumberTextField(256);
        yResolTextField = new NumberTextField(192);
        depthTextField = new NumberTextField(5);

        // Init radio buttons
        defaultSamplingRadioButton = new JRadioButton("Default");
        diadicSamplingRadioButton = new JRadioButton("Diadic");
        antialiasSamplingRadioButton = new JRadioButton("Antialias");
        ButtonGroup samplingGroup = new ButtonGroup();
        samplingGroup.add(defaultSamplingRadioButton);
        samplingGroup.add(diadicSamplingRadioButton);
        samplingGroup.add(antialiasSamplingRadioButton);
        diadicSamplingRadioButton.setSelected(true);

        // Init antialiasLevel combo box
        String[] antialiasLevels = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16" };
        antialiasLevelComboBox = new JComboBox(antialiasLevels);
        antialiasLevelComboBox.setSelectedIndex(1);

        // Init exact check box
        exactCheckBox = new JCheckBox("Exact");
        exactCheckBox.setSelected(false);

        // Save these parameters
        saveParameters();

        // Enable/Disable antialiasLevel combo box according to the state
        // of the antialias radio button
        antialiasLevelComboBox.setEnabled(false);
        antialiasSamplingRadioButton.addItemListener(new ItemListener() {
                public void itemStateChanged(ItemEvent e)
                {
                    antialiasLevelComboBox.setEnabled(e.getStateChange() == ItemEvent.SELECTED);
                }
            });

        // Init buttons
        JButton okButton = new JButton("OK");
        okButton.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    // Check that the text fields are non empty
                    String emptyTxtField = null;

                    if (xResolTextField.getText().equals(""))
                    {
                        emptyTxtField = "X Resolution";
                    }
                    else if (yResolTextField.getText().equals(""))
                    {
                        emptyTxtField = "Y Resolution";
                    }
                    else if (depthTextField.getText().equals(""))
                    {
                        emptyTxtField = "Depth";
                    }

                    if (emptyTxtField != null)
                    {
                        // At least one text field is empty
                        // Show an error message
                        JOptionPane.showMessageDialog(ComputeParametersDialog.this,
                                                      emptyTxtField + " field cannot be empty.",
                                                      "Empty Field Error",
                                                      JOptionPane.ERROR_MESSAGE);
                        return;
                    }

                    // Text fields are non empty
                    // Save parameters and hide
                    saveParameters();
                    setVisible(false);
                }
            });
        JButton cancelButton = new JButton("Cancel");
        cancelButton.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    restoreParameters();
                    setVisible(false);
                }
            });

        // Finally, layout the GUI
        JPanel pane = new JPanel();
        setContentPane(pane);
        pane.setLayout(new BoxLayout(pane, BoxLayout.Y_AXIS));
        pane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        Border emptyBorder = BorderFactory.createEmptyBorder(5, 5, 5, 5);

        // Init the resolution pane
        JPanel paneResolution = new JPanel();
        paneResolution.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createTitledBorder("Resolution"),
                                                                    emptyBorder));
        paneResolution.setLayout(new GridLayout(2, 2, 5, 5));
        paneResolution.add(new JLabel("X resolution"));
        paneResolution.add(xResolTextField);
        paneResolution.add(new JLabel("Y resolution"));
        paneResolution.add(yResolTextField);
        pane.add(paneResolution);

        pane.add(Box.createRigidArea(new Dimension(0, 10)));

        // Init the sampling pane
        JPanel paneSampling = new JPanel();
        paneSampling.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createTitledBorder("Sampling"),
                                                                  emptyBorder));
        paneSampling.setLayout(new GridLayout(3, 1, 5, 5));
        paneSampling.add(defaultSamplingRadioButton);
        paneSampling.add(diadicSamplingRadioButton);
        Box antialiasBox = new Box(BoxLayout.X_AXIS);
        antialiasBox.add(antialiasSamplingRadioButton);
        antialiasBox.add(antialiasLevelComboBox);
        antialiasBox.add(Box.createHorizontalGlue());
        paneSampling.add(antialiasBox);
        pane.add(paneSampling);

        pane.add(Box.createRigidArea(new Dimension(0, 15)));

        // Init the recursivity pane
        JPanel paneRecursivity = new JPanel();
        paneRecursivity.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createTitledBorder("Recursivity"),
                                                                     emptyBorder));
        paneRecursivity.setLayout(new GridLayout(2, 2, 5, 5));
        paneRecursivity.add(new JLabel("Depth"));
        paneRecursivity.add(depthTextField);
        paneRecursivity.add(exactCheckBox);
        pane.add(paneRecursivity);

        pane.add(Box.createRigidArea(new Dimension(0, 15)));

        // Init the button pane
        JPanel paneButtons = new JPanel();
        paneButtons.setLayout(new BoxLayout(paneButtons, BoxLayout.X_AXIS));
        paneButtons.add(Box.createHorizontalGlue());
        paneButtons.add(okButton);
        paneButtons.add(Box.createRigidArea(new Dimension(10, 0)));
        paneButtons.add(cancelButton);
        pane.add(paneButtons);
    }

    /**
     * Saves the parameters in the package accessible fields.
     */
    private void saveParameters()
    {
        xResol = xResolTextField.getValue();
        yResol = yResolTextField.getValue();
        depth = depthTextField.getValue();

        antialias = antialiasSamplingRadioButton.isSelected();
        antialiasLevelString = (String) antialiasLevelComboBox.getSelectedItem();
        antialiasLevel = antialias ? Integer.parseInt(antialiasLevelString) : 0;

        diadic = diadicSamplingRadioButton.isSelected();
        exact = exactCheckBox.isSelected();
    }

    /**
     * Restores the parameters from the package accessible fields.
     */
    private void restoreParameters()
    {
        xResolTextField.setValue(xResol);
        yResolTextField.setValue(yResol);
        depthTextField.setValue(depth);

        antialiasLevelComboBox.setSelectedItem(antialiasLevelString);

        diadicSamplingRadioButton.setSelected(diadic);
        antialiasSamplingRadioButton.setSelected(antialias);
        exactCheckBox.setSelected(exact);
    }
}


/**
 * Class defining a text field accepting only digit input characters.
 */
class NumberTextField extends JTextField
{
    private Toolkit toolkit;

    NumberTextField(int value)
    {
        super(String.valueOf(value));
        toolkit = Toolkit.getDefaultToolkit();
    }

    int getValue()
    {
        int retVal;
        retVal = Integer.parseInt(getText());
        return retVal;
    }

    void setValue(int value)
    {
        setText(String.valueOf(value));
    }

    protected Document createDefaultModel()
    {
        return new WholeNumberDocument();
    }

    class WholeNumberDocument extends PlainDocument
    {
        public void insertString(int offs, String str, AttributeSet a) throws BadLocationException
        {
            for (int i = 0 ; i < str.length() ; i++)
            {
                if (! Character.isDigit(str.charAt(i)))
                {
                    toolkit.beep();
                    return;
                }
            }
            super.insertString(offs, str, a);
        }
    }
}


// =========================================
// File: /raja/ui/ImageFrame.java
// =========================================

/* $Id: ImageFrame.java,v 1.2 2001/02/18 09:26:56 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.ui;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
import javax.swing.filechooser.FileFilter;

import raja.io.ImageIO;
import raja.io.ImageWriter;


/**
 * A Class defining a frame displaying an image under construction.
 */
class ImageFrame extends JFrame
{
    private BufferedImage image;
    private ImageDisplay display;
    private JFileChooser fc;
    private JCheckBoxMenuItem updatingMenuItem;

    ImageFrame(String name, BufferedImage im, long updatingRate)
    {
        super(name);
        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);

        image = im;

        // Init display
        display = new ImageDisplay(im, updatingRate, false);
        getContentPane().add(display);

        // Init Menus
        JMenuBar menuBar = new JMenuBar();
        setJMenuBar(menuBar);

        JMenu menu = new JMenu("File");
        menuBar.add(menu);

        // Init updating menu item
        updatingMenuItem = new JCheckBoxMenuItem("Updating", false);
        updatingMenuItem.addItemListener(new ItemListener() {
                public void itemStateChanged(ItemEvent e)
                {
                    display.setUpdating(e.getStateChange() == ItemEvent.SELECTED);
                }
            });
        menu.add(updatingMenuItem);

        menu.addSeparator();

        // Init save menu item
        Action saveAction = new SaveAction();
        try
        {
            fc = new JFileChooser();
            fc.addChoosableFileFilter(Util.imageFileFilter);
            fc.setFileFilter(Util.imageFileFilter);
        }
        catch (java.security.AccessControlException e)
        {
            // No access to local disk
            // Maybe running in a restricted environnment?
            fc = null;
            // Disabling save action
            saveAction.setEnabled(false);
        }
        menu.add(saveAction);

        menu.addSeparator();

        // Init close menu item
        JMenuItem mi = new JMenuItem("Close");
        mi.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e)
            {
                setVisible(false);
                dispose();
            }
        });
        menu.add(mi);
    }

    public void dispose()
    {
        setUpdating(false);
        display.stopUpdating();
        super.dispose();
    }

    /**
     * Sets the updating behavior.
     */
    void setUpdating(boolean b)
    {
        display.setUpdating(b);
        updatingMenuItem.setSelected(b);
    }

    /**
     * Class defining an action to save the displayed image.
     */
    class SaveAction extends AbstractAction
    {
	SaveAction()
        {
	    super("Save...", new ImageIcon(ImageFrame.this.getClass().getClassLoader().getResource("raja/ui/icons/file_save.gif")));
	}

        public void actionPerformed(ActionEvent evt)
        {
            int returnVal = fc.showSaveDialog(ImageFrame.this);

            if (returnVal == JFileChooser.APPROVE_OPTION)
            {
                File file = fc.getSelectedFile();

                try
                {
                    String codec = ImageIO.suffix2Codec(file);

                    if (codec == null)
                    {
                        JOptionPane.showMessageDialog(ImageFrame.this,
                                                      "Could not deduce codec for file: " + file,
                                                      "Illegal file suffix",
                                                      JOptionPane.ERROR_MESSAGE);
                        return;
                    }

                    OutputStream os = new BufferedOutputStream(new FileOutputStream(file));
                    ImageWriter writer = ImageIO.createImageWriter(codec, os);

                    if (writer == null)
                    {
                        JOptionPane.showMessageDialog(ImageFrame.this,
                                                      "Could not find an image writer for this codec: " +
                                                      codec,
                                                      "Illegal codec",
                                                      JOptionPane.ERROR_MESSAGE);
                        return;
                    }

                    Object writeParam = writer.createDefaultImageWriteParam(image);
                    writer.setImageWriteParam(writeParam);
                    writer.write(image);
                    os.close();
                    JOptionPane.showMessageDialog(ImageFrame.this,
                                                  codec + " file: " + file + " has been written succesfully");
                }
                catch (IOException err)
                {
                    JOptionPane.showMessageDialog(ImageFrame.this,
                                                  err.getMessage(),
                                                  "I/O Error",
                                                  JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }
}


/**
 * A Class defining an area displaying an image under construction.
 */
class ImageDisplay extends JPanel implements Runnable
{
    private BufferedImage image;
    private Thread updatingThread;
    private long updatingRate;
    private boolean updatingRunning;

    ImageDisplay(BufferedImage image, long updatingRate, boolean updating)
    {
        super();
        this.image = image;
        this.updatingRate = updatingRate;
        this.updatingRunning = updating;

        updatingThread = new Thread(this);
        updatingThread.setPriority(Thread.MAX_PRIORITY);
        updatingThread.start();
    }

    public void paintComponent(Graphics g)
    {
        super.paintComponent(g);

        g.drawImage(image,
                    (getWidth()  - image.getWidth() ) / 2,
                    (getHeight() - image.getHeight()) / 2,
                    this);
    }

    public Dimension getMaximumSize()
    {
        return getPreferredSize();
    }
    public Dimension getMinimumSize()
    {
        return getPreferredSize();
    }
    public Dimension getPreferredSize()
    {
        return new Dimension(image.getWidth(), image.getHeight());
    }

    BufferedImage getImage()
    {
        return image;
    }

    public void run() {
        while(true) {
            try {
                Thread.currentThread().sleep(updatingRate);

                if (updatingRunning) {
                    repaint();
                }
                else {
                    synchronized (this) {
                        while (! updatingRunning) {
                            wait();
                        }
                    }
                }
            }
            catch (InterruptedException e) {
            }
        }
    }
    synchronized void setUpdating(boolean b)
    {
        if (updatingRunning && !b) {
            // To be sure that the latest version of the image is
            // displayed, we re-display this component
            repaint();
        }

        updatingRunning = b;

        notify();
    }
    synchronized public void stopUpdating()
    {
        updatingThread.stop();
    }
}


// =========================================
// File: /raja/ui/CommandLineUI.java
// =========================================

/* $Id: CommandLineUI.java,v 1.5 2001/02/25 01:28:40 gregoire Exp $
 * Copyright (C) 2000-2001 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.ui;

import java.io.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import javax.swing.*;
import javax.swing.event.*;

import raja.renderer.Scene;
import raja.renderer.Renderer;
import raja.renderer.Resolution;
import raja.io.ObjectReader;
import raja.io.ImageIO;
import raja.io.ImageWriter;

import gnu.getopt.*;


/**
 * Main class of this Command Line User Interface.
 */
public class CommandLineUI
{
    private static final int SHOW_NOT_REQUESTED = 0;
    private static final int SHOW_HELP = 1;
    private static final int SHOW_VERSION = 2;

    private static final String NO_PROGRESS = "none";
    private static final String X_PROGRESS = "X";
    private static final String TXT_PROGRESS = "txt";

    private static final String progNameLong = "Raja's Command Line UI";
    private static final String progName = "raja";

    private static final String usage =
        "Usage: " + progName + " [OPTIONS] INPUT_FILE\n" +
        "\n" +
        "Options:\n" +
        "\n" +
        "  -h, --help\t\t\tdisplay this help\n" +
        "  -q, --quiet, --silent\t\tbe really quiet\n" +
        "  -v, --verbose[=LEVEL]\t\tincrease verbosity, or set to LEVEL\n" +
        "  -V, --version\t\t\tdisplay version\n" +
        "  -x, --xview\t\t\tshow image during its computation\n" +
        "  -p, --progress={X, txt}\tturns progress display on and\n" +
        "                         \tchose between graphical or textual display\n" +
        "\n" +
        "  -r, --resolution=RES\t\tset resolution to RES (default 256x192)\n" +
        "  -d, --depth=DEPTH\t\tset recursivity depth (default 5)\n" +
        "  -e, --exact\t\t\tdisable optimization mode\n" +
        "  -a, --antialias=LEVEL\t\tuse antialiasing with level LEVEL\n" +
        "  -D, --diadic\t\t\tuse diadic sampling\n" +
        "\n" +
        "  -o, --output=FILE\t\tsave image into FILE\n" +
        "  -c, --codec=CODEC\t\tset encoding codec to CODEC\n" +
        "                   \t\tavailable codecs: PNG, TIFF, JPEG, PNM, BMP";

    private static final String fullVersion =
        progNameLong + " version " + Util.rajaVersion + "\n" +
        "\n" +
        "(C) 1999-2001 Emmanuel Fleury, Gr�goire Sutre\n" +
        "\n" +
        "This program is free software; It is distributed in the hope that\n" +
        "it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n" +
        "warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n" +
        "See the GNU General Public License for more details.\n" +
        "\n" +
        "Written by Emmanuel Fleury <efleury@users.sourceforge.net>\n" +
        "       and Gr�goire Sutre  <gregoire@users.sourceforge.net>\n" +
        "\n" +
        "For news, updates and documentation, visit http://raja.sourceforge.net";

    /**
     * Main method to run this program.
     */
    public static void main(String[] argv)
    {
        long starttime = 0, endtime = 0;

        // Set parameters to default values
        boolean diadic = false;
        boolean exact = false;
        int showInfo = SHOW_NOT_REQUESTED;
        boolean xview = false;
        int antialiasLevel = 0;
        int depth = 5;
        String codec = null;
        String inputFile = null;
        String outputFile = null;
        String progress = NO_PROGRESS;
        Resolution resolution = new Resolution(256, 192);
        MessageWriter msgWriter = new MessageWriter(System.out,
                                                    System.err,
                                                    MessageWriter.VERBOSITY_NORMAL);



        // Parsing command line --------------------------------------------

        // Init LongOpt array for Getopt initialization
        LongOpt[] longopts = new LongOpt[14];

        // Init flag options
        longopts[0]  = new LongOpt("diadic",  LongOpt.NO_ARGUMENT, null, 'D');
        longopts[1]  = new LongOpt("exact",   LongOpt.NO_ARGUMENT, null, 'e');
        longopts[2]  = new LongOpt("help",    LongOpt.NO_ARGUMENT, null, 'h');
        longopts[3]  = new LongOpt("quiet",   LongOpt.NO_ARGUMENT, null, 'q');
        longopts[4]  = new LongOpt("silent",  LongOpt.NO_ARGUMENT, null, 'q');
        longopts[5]  = new LongOpt("version", LongOpt.NO_ARGUMENT, null, 'V');
        longopts[6]  = new LongOpt("xview",   LongOpt.NO_ARGUMENT, null, 'x');

        // Init optional valued options
        longopts[7]  = new LongOpt("verbose", LongOpt.OPTIONAL_ARGUMENT, null, 'v');

        // Init valued options
        longopts[8]  = new LongOpt("antialias",  LongOpt.REQUIRED_ARGUMENT, null, 'a');
        longopts[9]  = new LongOpt("codec",      LongOpt.REQUIRED_ARGUMENT, null, 'c');
        longopts[10] = new LongOpt("depth",      LongOpt.REQUIRED_ARGUMENT, null, 'd');
        longopts[11] = new LongOpt("output",     LongOpt.REQUIRED_ARGUMENT, null, 'o');
        longopts[12] = new LongOpt("progress",   LongOpt.REQUIRED_ARGUMENT, null, 'p');
        longopts[13] = new LongOpt("resolution", LongOpt.REQUIRED_ARGUMENT, null, 'r');

        // Init Getopt object to parse options
        Getopt g = new Getopt(progName, argv, "+:DehqVxv::a:c:d:o:p:r:", longopts);

        // Get options
        int c;
        String arg;

        while ((c = g.getopt()) != -1)
        {
            switch (c)
            {
            case 'D':
                diadic = true;
                break;

            case 'e':
                exact = true;
                break;

            case 'h':
                showInfo = SHOW_HELP;
                break;

            case 'q':
                msgWriter.setVerbosity(MessageWriter.VERBOSITY_NONE);
                break;

            case 'V':
                showInfo = SHOW_VERSION;
                break;

            case 'x':
                xview = true;
                break;

            case 'v':
                arg = g.getOptarg();
                if (arg != null)
                {
                    try
                    {
                        msgWriter.setVerbosity(parseNonNegativeInt(arg));
                    }
                    catch(NumberFormatException err)
                    {
                        printInvalidArgumentError(msgWriter, "verbose", arg);
                        System.exit(1);
                    }
                }
                else
                {
                    msgWriter.increaseVerbosity();
                }
                break;

            case 'a':
                arg = g.getOptarg();
                try
                {
                    antialiasLevel = parseNonNegativeInt(arg);
                }
                catch(NumberFormatException err)
                {
                    printInvalidArgumentError(msgWriter, "antialias", arg);
                    System.exit(1);
                }
                break;

            case 'c':
                arg = g.getOptarg();
                codec = arg.toUpperCase();
                break;

            case 'd':
                arg = g.getOptarg();
                try
                {
                    depth = parseNonNegativeInt(arg);
                }
                catch(NumberFormatException err)
                {
                    printInvalidArgumentError(msgWriter, "depth", arg);
                    System.exit(1);
                }
                break;

            case 'o':
                arg = g.getOptarg();
                outputFile = arg;
                break;

            case 'p':
                arg = g.getOptarg();
                if (arg.equals("X"))
                {
                    progress = X_PROGRESS;
                }
                else if (arg.equals("txt"))
                {
                    progress = TXT_PROGRESS;
                }
                else
                {
                    printInvalidArgumentError(msgWriter, "progress", arg);
                    System.exit(1);
                }
                break;

            case 'r':
                arg = g.getOptarg();
                int sep = arg.indexOf('x');

                if (sep == -1)
                {
                    printInvalidArgumentError(msgWriter, "resolution", arg);
                    System.exit(1);
                }

                try
                {
                    int width = parseNonNegativeInt(arg.substring(0, sep));
                    int height = parseNonNegativeInt(arg.substring(sep + 1));
                    resolution = new Resolution(width, height);
                }
                catch(NumberFormatException err)
                {
                    printInvalidArgumentError(msgWriter, "resolution", arg);
                    System.exit(1);
                }
                break;

            case ':':
            case '?':
                msgWriter.message(MessageWriter.MSG_ERROR,
                                  "Try `" + progName + " --help' for more information.");
                System.exit(1);

            default:
                // This shall not happen
                throw new RuntimeException(progNameLong + " internal error !!!!");
            }
        }

        // Check whether more information about this program is requested
        if (showInfo == SHOW_HELP)
        {
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_CRUCIAL,
                              usage);
            System.exit(0);
        }
        else if (showInfo == SHOW_VERSION)
        {
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_CRUCIAL,
                              fullVersion);
            System.exit(0);
        }

        // Check that there remains exactly one argument
        int index = g.getOptind();
        if (index > (argv.length - 1))
        {
            msgWriter.message(MessageWriter.MSG_ERROR,
                              "Missing input file.");
            msgWriter.message(MessageWriter.MSG_ERROR,
                              "Try `" + progName + " --help' for more information.");
            System.exit(1);
        }
        else if (index < (argv.length - 1))
        {
            msgWriter.message(MessageWriter.MSG_ERROR,
                              "Too many input files.");
            msgWriter.message(MessageWriter.MSG_ERROR,
                              "Try `" + progName + " --help' for more information.");
            System.exit(1);
        }

        // Init input file
        inputFile = argv[index];

        // [End of] Parsing command line -----------------------------------



        // Report parsed parameters ----------------------------------------

        // Display program name and version
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL,
                          progNameLong + " version " + Util.rajaVersion + "\n");

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "\n\n" +
                          "------------ Reporting parsed parameters ---------------------------------" +
                          "\n");

        // Display input file
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_LOW,
                          "Input file: " + inputFile + "\n");

        // Display selected options
        String selectedOptions =
            "Selected options:" + "\n" +
            "   xview:\t" + xview + "\n" +
            "   progress:\t" + progress + "\n" +
            "   resolution:\t" + resolution + "\n" +
            "   depth:\t" + depth + "\n" +
            "   antialias:\t" + ((antialiasLevel == 0) ?
                                 "none" :
                                 "enabled with level " + antialiasLevel) + "\n" +
            "   exact:\t" + exact + "\n" +
            "   diadic:\t" + diadic + "\n" +
            "   output:\t" + ((outputFile == null) ?
                              "none" :
                              outputFile) + "\n" +
            "   codec:\t" + ((codec == null) ?
                             "unspecified" :
                             codec);

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_LOW,
                          selectedOptions + "\n");

        if ((! xview) && (outputFile == null))
        {
            // Warn user that image will be lost
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL,
                              "WARNING: you didn't select option `--xview' nor `--output'" + "\n" +
                              "         image will be lost after rendering !!!" + "\n");
        }

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "--- [End of] Reporting parsed parameters ---------------------------------" +
                          "\n");

        // [End of] Report parsed parameters -------------------------------



        // Check capability to save ouput file  ----------------------------

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "\n\n" +
                          "------------ Checking capability to save ouput file ----------------------" +
                          "\n");

        // Deduce codec if not set
        if ((codec == null) && (outputFile != null))
        {
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "Encoding codec was not specified." + "\n" +
                              "Trying to deduce codec from output file suffix...");

            codec = ImageIO.suffix2Codec(outputFile);

            if (codec == null)
            {
                msgWriter.message(MessageWriter.MSG_ERROR,
                                  "Error: Could not deduce codec for file: " + outputFile + "\n" +
                                  "       Please use a supported image file suffix or explicitly set the" + "\n" +
                                  "       encoding codec with the --codec option");
                System.exit(1);
            }

            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "done." +
                              "\n");

            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_LOW,
                              "Using codec: " + codec + "\n");
        }

        // Check that we will be able to save the image
        if (outputFile != null)
        {
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "Checking capability to write using codec: " + codec +
                              " into file: " + outputFile + "...");

            try
            {
                FileOutputStream fileOutputStream = new FileOutputStream(outputFile);

                if (ImageIO.createImageWriter(codec, fileOutputStream) == null)
                {
                    msgWriter.message(MessageWriter.MSG_ERROR,
                                      "Error: Could not find an image writer for this codec: " + codec);
                    System.exit(1);
                }

                fileOutputStream.close();
            }
            catch (IOException err)
            {
                msgWriter.message(MessageWriter.MSG_ERROR,
                                  "I/O Error: " + err.getMessage());
                System.exit(1);
            }

            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "done." +
                              "\n");
        }

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "--- [End of] Checking capability to save ouput file ----------------------" +
                          "\n");

        // [End of] Check capability to save ouput file  -------------------



        // Pre-rendering initializations -----------------------------------

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "\n\n" +
                          "------------ Pre-rendering initializations -------------------------------" +
                          "\n");

        // Parse input file
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL,
                          "Parsing file: " + inputFile + "...");
        Scene scene = null;
        try
        {
            Reader in = new InputStreamReader(new FileInputStream(inputFile));
            ObjectReader reader = new ObjectReader(in);
            starttime = System.currentTimeMillis();
            scene = (Scene) reader.readObject();
            endtime = System.currentTimeMillis();
        }
        catch (IOException err)
        {
            msgWriter.message(MessageWriter.MSG_ERROR,
                              "I/O Error: " + err.getMessage());
            System.exit(1);
        }

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL,
                          "Parsing finished.");

        // Display parsing time
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_LOW,
                          "Parsing time: " + Util.getTime(endtime - starttime));

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL, "");

        // Init renderer
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "Initializing renderer...");
        Renderer renderer = Util.getRenderer(scene,
                                             resolution,
                                             exact,
                                             depth,
                                             diadic,
                                             antialiasLevel);
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "done." +
                          "\n");

        // Get a reference to the image to be filled by the renderer
        BufferedImage image = renderer.getImage();

        // Init image frame and show it if necessary
        ImageFrame imageFrame = null;

        if (xview)
        {
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "Initializing image showing frame...");

            imageFrame = new ImageFrame("Raja's image", image, 100);
            imageFrame.setLocation(300, 300);
            imageFrame.pack();
            imageFrame.setUpdating(true);
            imageFrame.setVisible(true);
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "done." +
                              "\n");
        }

        // Init progress display
        BoundedRangeModel model = renderer.getModel();
        JFrame progressFrame = null;

        if (progress == TXT_PROGRESS)
        {
            // Textual progress display
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "Initializing textual progress display...");
            model.addChangeListener(new TextualProgressBar(model, System.out));
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "done." +
                              "\n");
        }
        else if (progress == X_PROGRESS)
        {
            // Graphical progress display
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "Initializing graphical progress display...");
            progressFrame = new GraphicalProgressBarFrame(model, progNameLong);
            progressFrame.setLocation(300, 200);
            progressFrame.pack();
            progressFrame.setVisible(true);
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "done." +
                              "\n");
        }

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "--- [End of] Pre-rendering initializations -------------------------------" +
                          "\n");

        // [End of] Pre-rendering initializations --------------------------



        // Rendering stage -------------------------------------------------

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "\n\n" +
                          "------------ Rendering stage ---------------------------------------------" +
                          "\n");

        // Init rendering thread
        Thread rendering = new Thread(renderer);

        // Tune thread priority
        rendering.setPriority(Thread.MIN_PRIORITY);

        // Start rendering
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL,
                          "Rendering...");

        starttime = System.currentTimeMillis();
        rendering.start();
        try
        {
            rendering.join();
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
        endtime = System.currentTimeMillis();

        // Rendering finished
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL,
                          "Rendering finished.");

        // Display rendering time
        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_LOW,
                          "Rendering time: " + Util.getTime(endtime - starttime));

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "\n" +
                          "--- [End of] Rendering stage ---------------------------------------------");

        // [End of] Rendering ----------------------------------------------



        // Post-rendering tasks --------------------------------------------

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "\n\n" +
                          "\n" +
                          "------------ Post-rendering tasks ----------------------------------------");

        // Update image frame and stop progress display
        if (xview)
        {
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "\n" +
                              "Stopping updating image showing frame...");
            imageFrame.setUpdating(false);
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "done.");
        }
        if (progress == X_PROGRESS)
        {
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "\n" +
                              "Disposing of graphical progress display...");
            progressFrame.dispose();
            msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                              "done.");
        }

        // Save image
        if (outputFile != null)
        {
            try
            {
                msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL, "");

                msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL,
                                  "Writing " + codec + " file: " + outputFile + "...");

                OutputStream os = new BufferedOutputStream(new FileOutputStream(outputFile));
                ImageWriter writer = ImageIO.createImageWriter(codec, os);

                if (writer == null)
                {
                    // This shall not happen, since we already checked the
                    // writing ability for this codec
                    throw new RuntimeException(progNameLong + " internal error !!!!");
                }

                Object writeParam = writer.createDefaultImageWriteParam(image);
                writer.setImageWriteParam(writeParam);
                writer.write(image);
                os.close();

                msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_NORMAL,
                                  "done.");
            }
            catch (IOException err)
            {
                msgWriter.message(MessageWriter.MSG_ERROR,
                                  "I/O Error: " + err.getMessage());
                System.exit(1);
            }
        }

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "\n" +
                          "--- [End of] Post-rendering tasks ----------------------------------------");

        // [End of] Post-rendering tasks -----------------------------------



        // Exit gracefully -------------------------------------------------

        msgWriter.message(MessageWriter.MSG_SIGNIFICANCE_VERY_LOW,
                          "\n\n" +
                          "\n" +
                          "------------ Exiting gracefully ------------------------------------------");

        if ((! xview) || (! imageFrame.isShowing())) {
            // Exit if no image frame was requested or
            // if the image frame has been closed
            System.exit(0);
        }
        else
        {
            // add a listener to the image frame in order to exit when
            // the frame is closed
            imageFrame.addWindowListener(new WindowAdapter() {
                    public void windowClosed(WindowEvent e) 
                    {
                        System.exit(0);
                    }
                });
        }

        // [End of] Exit gracefully ----------------------------------------
    }

    private static int parseNonNegativeInt(String s)
    {
        int result = Integer.parseInt(s);

        if (result < 0)
        {
            throw new NumberFormatException(s);
        }

        return result;
    }

    private static void printInvalidArgumentError(MessageWriter w,
                                                  String opt,
                                                  String arg)
    {
        w.message(MessageWriter.MSG_ERROR,
                  "Invalid argument `" + arg + "' for option `--" + opt + "'.");
        w.message(MessageWriter.MSG_ERROR,
                  "Try `" + progName + " --help' for more information.");
    }
}


/**
 * A Class for writing messages filtered by their significance.
 */
class MessageWriter
{
    static final int MSG_ERROR                 = -1;
    static final int MSG_SIGNIFICANCE_CRUCIAL  = 0;
    static final int MSG_SIGNIFICANCE_NORMAL   = 1;
    static final int MSG_SIGNIFICANCE_LOW      = 2;
    static final int MSG_SIGNIFICANCE_VERY_LOW = 3;

    static final int VERBOSITY_NONE      = 0;
    static final int VERBOSITY_NORMAL    = 1;
    static final int VERBOSITY_HIGH      = 2;
    static final int VERBOSITY_VERY_HIGH = 3;

    private PrintStream out;
    private PrintStream err;
    private int verbosity;

    MessageWriter(PrintStream out, PrintStream err, int verbosity)
    {
        this.out = out;
        this.err = err;
        this.verbosity = verbosity;
    }

    void setVerbosity(int verbosity)
    {
        this.verbosity = verbosity;
    }

    void increaseVerbosity()
    {
        verbosity++;
    }

    void message(int significance, String msg)
    {
        if (significance == MSG_ERROR)
        {
            err.println(msg);
        }
        else if (significance <= verbosity)
        {
            out.println(msg);
        }
    }
    
}


/**
 * A Class defining a frame displaying a graphic progress bar.
 */
class GraphicalProgressBarFrame extends JFrame
{
    GraphicalProgressBarFrame(BoundedRangeModel m, String title)
    {
        super(title);
        JPanel pane = new JPanel();
        setContentPane(pane);
        pane.setLayout(new BoxLayout(pane, BoxLayout.Y_AXIS));
        pane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JProgressBar progressBar = new JProgressBar();
        progressBar.setModel(m);
        progressBar.setStringPainted(true);

        JLabel label = new JLabel("Rendering...");
        label.setAlignmentX((float) 0.5);
        label.setForeground(Color.black);

        pane.add(label);
        pane.add(Box.createRigidArea(new Dimension(0, 10)));
        pane.add(progressBar);
    }
}


/**
 * A Class defining a textual progress bar on an output print stream.
 */
class TextualProgressBar implements ChangeListener
{
    private BoundedRangeModel m;
    private PrintStream ps;
    private int percentComplete;
    private boolean printedHeader = false;

    TextualProgressBar(BoundedRangeModel m, PrintStream ps)
    {
        this.m = m;
        this.ps = ps;
        this.percentComplete = 0;
    }

    public void stateChanged(ChangeEvent e)
    {
        if (! printedHeader)
        {
            ps.print("\n   0% -> ");
            printedHeader = true;
        }

        int newPercentComplete = (100 * (m.getValue() - m.getMinimum())) /
                                        (m.getMaximum() - m.getMinimum());

        if (newPercentComplete > percentComplete)
        {
            if (newPercentComplete == 50)
            {
                ps.print(".\n  50% -> ");
            }
            else if (newPercentComplete == 100)
            {
                ps.print(".\n\n");
            }
            else if ((newPercentComplete / 10) > (percentComplete / 10))
            {
                ps.print(". ");
            }
            else
            {
                ps.print(".");
            }
        }
        percentComplete = newPercentComplete;
    }
}


// =========================================
// File: /raja/ui/MiniGUI.java
// =========================================

/* $Id: MiniGUI.java,v 1.2 2001/02/25 01:28:40 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.ui;

import java.io.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.filechooser.FileFilter;
import javax.swing.undo.*;

import raja.renderer.Scene;
import raja.renderer.Renderer;
import raja.renderer.Resolution;
import raja.io.ObjectReader;


/**
 * Main class of this Mini Graphical User Interface.
 */
public class MiniGUI extends JFrame
{
    private JTextArea txtInput, txtLog;
    private ComputeParametersDialog computeParametersDialog;
    private ComputingImageThread computingImage;
    private Action newDocumentAction, openDocumentAction, saveDocumentAction;
    private Action cutAction, copyAction, pasteAction;
    private UndoAction undoAction;
    private RedoAction redoAction;
    private Action computeParametersAction;
    private Action startAndResumeComputationAction, suspendComputationAction, stopComputationAction;
    private JProgressBar progressBar;
    private JFileChooser fc;
    private UndoManager undoManager;
    private UndoableEditListener undoEditListener;
    private boolean documentChanged;
    private DocumentListener documentChangedListener;

    /**
     * Creates a MiniGUI object.
     */
    MiniGUI()
    {
        super("Raja's Mini GUI");

        // Closing the frame exits the GUI
        setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
        addWindowListener(new WindowAdapter() {
                public void windowClosing(WindowEvent e) 
                {
                    exit();
                }
            });

        // Init fields of this MiniGUI
        txtInput = new JTextArea();
        txtLog = new JTextArea();
        txtLog.setEditable(false);
        txtLog.setForeground(Color.red);
        computeParametersDialog = new ComputeParametersDialog(this);
        progressBar = new JProgressBar();

        // Init actions
        initActions();

        // Init JFileChooser
        try
        {
            fc = new JFileChooser();
            fc.addChoosableFileFilter(Util.rajaInputFileFilter);
            fc.setFileFilter(Util.rajaInputFileFilter);
        }
        catch (java.security.AccessControlException e)
        {
            // No access to local disk
            // Maybe running in a restricted environnment?
            fc = null;
            // Disabling open/save actions
            openDocumentAction.setEnabled(false);
            saveDocumentAction.setEnabled(false);
        }

        // Init undo capabilities
        undoManager = new UndoManager();
        undoEditListener = new UndoableEditListener() {
                public void undoableEditHappened(UndoableEditEvent e) {
                    //Remember the edit and update the menus
                    undoManager.addEdit(e.getEdit());
                    undoAction.update();
                    redoAction.update();
                }
            };

        // Init listener to detect change in the document
        documentChangedListener = new DocumentListener() {
                public void insertUpdate(DocumentEvent e)
                {
                    documentChanged = true;
                }
                public void removeUpdate(DocumentEvent e)
                {
                    documentChanged = true;
                }
                public void changedUpdate(DocumentEvent e)
                {
                    //Plain text components don't fire these events
                }
            };

        // Registers document listeners on current document and update
        // undo/redo actions.
        documentPostSet();

        // Init the label displaying the line number and the column number.
        LineAndColumn lineAndColumn = new LineAndColumn();
        txtInput.addCaretListener(lineAndColumn);

        // Finally, layout the GUI
        JPanel pane = new JPanel();
        setContentPane(pane);
        pane.setLayout(new BorderLayout());

        JPanel inputTextPane = new JPanel();
        inputTextPane.setLayout(new BorderLayout());
        inputTextPane.add(new JScrollPane(txtInput));
        inputTextPane.add(lineAndColumn, BorderLayout.SOUTH);

        JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,
                                              inputTextPane,
                                              new JScrollPane(txtLog));
        splitPane.setOneTouchExpandable(true);
        splitPane.setPreferredSize(new Dimension(600, 550));
        splitPane.setDividerLocation(450);

        pane.add(splitPane, BorderLayout.CENTER);

        progressBar.setStringPainted(true);
        pane.add(progressBar, BorderLayout.SOUTH);

        initToolBarAndMenuBar();
    }

    /**
     * Quits this currently running MiniGUI.
     */
    private void exit()
    {
        if (checkDocumentChanged())
        {
            System.exit(0);
        }
    }

    /**
     * Creates the actions used in this GUI.
     */
    private void initActions()
    {
        // Get class loader to retrieve ressources
        ClassLoader cl = this.getClass().getClassLoader();

        // New, open and save actions
        newDocumentAction = new NewDocumentAction();
        newDocumentAction.putValue(Action.SMALL_ICON,
                                   new ImageIcon(cl.getResource("raja/ui/icons/file_new.gif")));
        newDocumentAction.putValue(Action.SHORT_DESCRIPTION, "New document");

        openDocumentAction = new OpenDocumentAction();
        openDocumentAction.putValue(Action.SMALL_ICON,
                                    new ImageIcon(cl.getResource("raja/ui/icons/file_open.gif")));
        openDocumentAction.putValue(Action.SHORT_DESCRIPTION, "Open document");

        saveDocumentAction = new SaveDocumentAction();
        saveDocumentAction.putValue(Action.SMALL_ICON,
                                    new ImageIcon(cl.getResource("raja/ui/icons/file_save.gif")));
        saveDocumentAction.putValue(Action.SHORT_DESCRIPTION, "Save document");

        // Cut, copy and paste actions
        // These actions are provided by the text editor
        java.util.Hashtable actions = new java.util.Hashtable();
        Action[] actionsArray = txtInput.getActions();
        for (int i = 0 ; i < actionsArray.length; i++)
        {
            Action a = actionsArray[i];
            actions.put(a.getValue(Action.NAME), a);
        }

        cutAction = (Action) actions.get(DefaultEditorKit.cutAction);
        cutAction.putValue(Action.SMALL_ICON,
                           new ImageIcon(cl.getResource("raja/ui/icons/edit_cut.gif")));
        cutAction.putValue(Action.NAME, "Cut");
        cutAction.putValue(Action.SHORT_DESCRIPTION, "Cut selection to clipboard");

        copyAction = (Action) actions.get(DefaultEditorKit.copyAction);
        copyAction.putValue(Action.SMALL_ICON,
                            new ImageIcon(cl.getResource("raja/ui/icons/edit_copy.gif")));
        copyAction.putValue(Action.NAME, "Copy");
        copyAction.putValue(Action.SHORT_DESCRIPTION, "Copy selection to clipboard");

        pasteAction = (Action) actions.get(DefaultEditorKit.pasteAction);
        pasteAction.putValue(Action.SMALL_ICON,
                             new ImageIcon(cl.getResource("raja/ui/icons/edit_paste.gif")));
        pasteAction.putValue(Action.NAME, "Paste");
        pasteAction.putValue(Action.SHORT_DESCRIPTION, "Paste clipboard to selection");

        // Undo/redo actions
        undoAction = new UndoAction();
        undoAction.putValue(Action.SMALL_ICON,
                            new ImageIcon(cl.getResource("raja/ui/icons/edit_undo.gif")));
        undoAction.putValue(Action.SHORT_DESCRIPTION, "Undo last edit");

        redoAction = new RedoAction();
        redoAction.putValue(Action.SMALL_ICON,
                            new ImageIcon(cl.getResource("raja/ui/icons/edit_redo.gif")));
        redoAction.putValue(Action.SHORT_DESCRIPTION, "Redo previous edit");

        // Compute parameters action
        computeParametersAction = new ComputeParametersAction();
        computeParametersAction.putValue(Action.SMALL_ICON,
                                         new ImageIcon(cl.getResource("raja/ui/icons/compute_parameters.gif")));
        computeParametersAction.putValue(Action.SHORT_DESCRIPTION, "Ray tracing parameters");

        // Start/resume, suspend and stop actions
        startAndResumeComputationAction = new StartAndResumeComputationAction();
        startAndResumeComputationAction.putValue(Action.SMALL_ICON,
                                                 new ImageIcon(cl.getResource("raja/ui/icons/compute_start.gif")));
        startAndResumeComputationAction.putValue(Action.SHORT_DESCRIPTION, "Start/resume computation");

        suspendComputationAction = new SuspendComputationAction();
        suspendComputationAction.putValue(Action.SMALL_ICON,
                                          new ImageIcon(cl.getResource("raja/ui/icons/compute_suspend.gif")));
        suspendComputationAction.putValue(Action.SHORT_DESCRIPTION, "Suspend ongoing computation");

        stopComputationAction = new StopComputationAction();
        stopComputationAction.putValue(Action.SMALL_ICON,
                                       new ImageIcon(cl.getResource("raja/ui/icons/compute_stop.gif")));
        stopComputationAction.putValue(Action.SHORT_DESCRIPTION, "Stop ongoing computation");

        suspendComputationAction.setEnabled(false);
        stopComputationAction.setEnabled(false);
    }

    /**
     * Adds an action to a tool bar.  This method performs some extra
     * initialization for all toolbar buttons.
     */
    private static void addActionToToolBar(Action action, JToolBar toolBar)
    {
        JButton b = toolBar.add(action);
        b.setText("");
        b.setRequestFocusEnabled(false);
        b.setMargin(new Insets(1,1,1,1));
    }

    /**
     * Creates tool bar and the menus.
     */
    private void initToolBarAndMenuBar()
    {
        // Tool bar initialization
        JToolBar toolBar = new JToolBar();
        addActionToToolBar(newDocumentAction, toolBar);
        addActionToToolBar(openDocumentAction, toolBar);
        addActionToToolBar(saveDocumentAction, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(cutAction, toolBar);
        addActionToToolBar(copyAction, toolBar);
        addActionToToolBar(pasteAction, toolBar);
        addActionToToolBar(undoAction, toolBar);
        addActionToToolBar(redoAction, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(computeParametersAction, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(startAndResumeComputationAction, toolBar);
        addActionToToolBar(suspendComputationAction, toolBar);
        addActionToToolBar(stopComputationAction, toolBar);

        toolBar.setMargin(new Insets(1,1,1,1));

        // Attach the tool bar to the content pane
        getContentPane().add(toolBar, BorderLayout.NORTH);

        // Menu bar initialization
        JMenuBar menuBar = new JMenuBar();
        JMenu menu;

        // File menu
        menu = new JMenu("File");
        menuBar.add(menu);
        menu.add(newDocumentAction);
        menu.add(openDocumentAction);
        menu.add(saveDocumentAction);
        menu.addSeparator();
        JMenuItem mi = new JMenuItem("Exit");
        mi.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt)
            {
                exit();
            }
        });
        menu.add(mi);

        // Edit menu
        menu = new JMenu("Edit");
        menuBar.add(menu);
        menu.add(cutAction);
        menu.add(copyAction);
        menu.add(pasteAction);
        menu.addSeparator();
        menu.add(undoAction);
        menu.add(redoAction);

        // Compute menu
        menu = new JMenu("Compute");
        menuBar.add(menu);
        menu.add(computeParametersAction);
        menu.addSeparator();
        menu.add(startAndResumeComputationAction);
        menu.add(suspendComputationAction);
        menu.add(stopComputationAction);

        // Attach the menu bar to this frame
        setJMenuBar(menuBar);
    }

    /**
     * Saves current document.  This method returns true if the document
     * was successfully saved, and false otherwise.
     */
    private boolean saveDocument()
    {
        int returnVal = fc.showSaveDialog(MiniGUI.this);

        if (returnVal == JFileChooser.APPROVE_OPTION)
        {
            File file = fc.getSelectedFile();

            try
            {
                Writer writer = new BufferedWriter(new FileWriter(file));
                txtInput.write(writer);
                writer.close();
            }
            catch (java.io.IOException err)
            {
                JOptionPane.showMessageDialog(MiniGUI.this,
                                              err.getMessage(),
                                              "I/O Error",
                                              JOptionPane.ERROR_MESSAGE);
                return false;
            }
            documentChanged = false;
            return true;
        }
        else
        {
            return false;
        }
    }

    /**
     * Checks whether the document has changed before performing some action
     * that would lose the document (such as open file or exit).  This
     * method returns true if the action can be performed and false otherwise.
     */
    private boolean checkDocumentChanged()
    {
        if (! documentChanged)
        {
            return true;
        }
        else if (fc == null)
        {
            // No access to local disk.
            int ret = JOptionPane.showConfirmDialog(this,
                                                    "Current document will be lost.  Do you still want to continue?",
                                                    "Warning",
                                                    JOptionPane.YES_NO_OPTION,
                                                    JOptionPane.WARNING_MESSAGE);
            return (ret == JFileChooser.APPROVE_OPTION);
        }
        else
        {
            int ret = JOptionPane.showConfirmDialog(this,
                                                    "Current document has changed.  Do you want to save it?",
                                                    "Warning",
                                                    JOptionPane.YES_NO_CANCEL_OPTION,
                                                    JOptionPane.WARNING_MESSAGE);
            switch (ret)
            {
                case JOptionPane.YES_OPTION:
                    return saveDocument();

                case JOptionPane.NO_OPTION:
                    return true;

                default:
                    return false;
            }
        }
    }

    /**
     * Unregisters listeners on current document and reset undo manager.
     * This method shall be called just before setting a new document.
     */
    private void documentPreSet()
    {
        txtInput.getDocument().removeUndoableEditListener(undoEditListener);
        txtInput.getDocument().removeDocumentListener(documentChangedListener);
        undoManager.discardAllEdits();
    }

    /**
     * Registers listeners on current document and update undo/redo actions.
     * This method shall be called just after setting a new document.
     */
    private void documentPostSet()
    {
        documentChanged = false;
        txtInput.getDocument().addUndoableEditListener(undoEditListener);
        txtInput.getDocument().addDocumentListener(documentChangedListener);
        undoAction.update();
        redoAction.update();
    }

    /**
     * Class defining a label displaying the line number and the column
     * number of the caret in the text component it listens to.
     */
    class LineAndColumn extends JLabel implements CaretListener {
        LineAndColumn ()
        {
            super("Line: 1     Column: 0", SwingConstants.CENTER);
        }

        public void caretUpdate(CaretEvent e)
        {
            try
            {
                int dot = e.getDot();
                int line = txtInput.getLineOfOffset(dot);
                int column = dot - txtInput.getLineStartOffset(line);
                setText("Line: " + String.valueOf(line + 1) +
                        "     Column: " + String.valueOf(column));
            }
            catch (BadLocationException ble)
            {
                // This shall not happen
                ble.printStackTrace();
            }
        }
    }

    /**
     * Class defining an action to create a new document.
     */
    class NewDocumentAction extends AbstractAction
    {
        NewDocumentAction()
        {
            super("New");
        }

        public void actionPerformed(ActionEvent evt)
        {
            if (checkDocumentChanged())
            {
                documentPreSet();
                txtInput.setDocument(new PlainDocument());
                documentPostSet();
            }
        }
    }

    /**
     * Class defining an action to open a document.
     */
    class OpenDocumentAction extends AbstractAction
    {
        OpenDocumentAction()
        {
            super("Open...");
        }

        public void actionPerformed(ActionEvent evt)
        {
            if (checkDocumentChanged())
            {
                int returnVal = fc.showOpenDialog(MiniGUI.this);

                if (returnVal == JFileChooser.APPROVE_OPTION)
                {
                    File file = fc.getSelectedFile();

                    try
                    {
                        documentPreSet();
                        Reader reader = new BufferedReader(new FileReader(file));
                        txtInput.read(reader, null);
                        reader.close();
                        documentPostSet();
                    }
                    catch (java.io.IOException err)
                    {
                        JOptionPane.showMessageDialog(MiniGUI.this,
                                                      err.getMessage(),
                                                      "I/O Error",
                                                      JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        }
    }

    /**
     * Class defining an action to save a document.
     */
    class SaveDocumentAction extends AbstractAction
    {
        SaveDocumentAction()
        {
            super("Save...");
        }

        public void actionPerformed(ActionEvent evt)
        {
            saveDocument();
        }
    }

    /**
     * Class defining the undo action.
     */
    class UndoAction extends AbstractAction
    {
        UndoAction()
        {
            super("Undo");
        }

        public void actionPerformed(ActionEvent evt)
        {
            try
            {
                undoManager.undo();
            }
            catch (CannotUndoException err)
            {
                // This shall not happen
                err.printStackTrace();
            }
            update();
            redoAction.update();
        }

        protected void update()
        {
            setEnabled(undoManager.canUndo());
        }
    }

    /**
     * Class defining the redo action.
     */
    class RedoAction extends AbstractAction
    {
        RedoAction()
        {
            super("Redo");
        }

        public void actionPerformed(ActionEvent evt)
        {
            try
            {
                undoManager.redo();
            }
            catch (CannotRedoException err)
            {
                // This shall not happen
                err.printStackTrace();
            }
            update();
            undoAction.update();
        }

        protected void update()
        {
            setEnabled(undoManager.canRedo());
        }
    }

    /**
     * Class defining an action to bring the Ray tracing parameters dialog.
     */
    class ComputeParametersAction extends AbstractAction
    {
        ComputeParametersAction()
        {
            super("Ray tracing parameters...");
        }

        public void actionPerformed(ActionEvent evt)
        {
            computeParametersDialog.pack();
            computeParametersDialog.setVisible(true);
        }
    }

    /**
     * Class defining a thread computing the image.  The renderer creation
     * is part of the run() method.  This thread may be suspended, resumed
     * and stopped and it updates the start/resume, suspend and stop actions
     * accordingly.
     */
    class ComputingImageThread extends Thread
    {
        private ImageFrame imageFrame;

        public void run()
        {
            Renderer renderer;

            // First disable start/resume action
            startAndResumeComputationAction.setEnabled(false);

            // Parse scene
            Scene scene = null;
            try {
                Reader in = new StringReader(txtInput.getText());
                ObjectReader reader = new ObjectReader(in);
                scene = (Scene) reader.readObject();
            }
            catch (IOException err) {
                txtLog.append(err.toString() + "\n");

                // Enable start/resume action for the next computation
                startAndResumeComputationAction.setEnabled(true);

                return;
            }

            // Init renderer
            Resolution resolution = new Resolution(computeParametersDialog.xResol,
                                                   computeParametersDialog.yResol);
            renderer = Util.getRenderer(scene,
                                        resolution,
                                        computeParametersDialog.exact,
                                        computeParametersDialog.depth,
                                        computeParametersDialog.diadic,
                                        computeParametersDialog.antialiasLevel);

            // Init image frame and show it
            BufferedImage image = renderer.getImage();
            imageFrame = new ImageFrame("Raja's image", image, 100);
            imageFrame.pack();
            imageFrame.setUpdating(true);
            imageFrame.setVisible(true);

            // Init progress bar
            progressBar.setModel(renderer.getModel());

            // Enable suspend and stop actions
            suspendComputationAction.setEnabled(true);
            stopComputationAction.setEnabled(true);

            // Compute, tuning thread priority...
            int oldPriority = getPriority();
            setPriority(Thread.MIN_PRIORITY);
            renderer.run();
            setPriority(oldPriority);

            // Computation finished

            // Disable suspend and stop actions
            suspendComputationAction.setEnabled(false);
            stopComputationAction.setEnabled(false);

            // Image frame should not update its image anymore
            imageFrame.setUpdating(false);

            // Reset progress bar
            progressBar.setValue(0);

            // Enable start/resume action for the next computation
            startAndResumeComputationAction.setEnabled(true);
        }

        void setResumed()
        {
            imageFrame.setUpdating(true);
            startAndResumeComputationAction.setEnabled(false);
            suspendComputationAction.setEnabled(true);
            super.resume();
        }

        void setSuspended()
        {
            imageFrame.setUpdating(false);
            suspendComputationAction.setEnabled(false);
            startAndResumeComputationAction.setEnabled(true);
            super.suspend();
        }

        void setStopped()
        {
            imageFrame.setUpdating(false);
            progressBar.setValue(0);
            suspendComputationAction.setEnabled(false);
            stopComputationAction.setEnabled(false);
            startAndResumeComputationAction.setEnabled(true);
            super.stop();
        }
    }

    /**
     * Class defining an action to start/resume the computation.
     */
    class StartAndResumeComputationAction extends AbstractAction
    {
        StartAndResumeComputationAction()
        {
            super("Start/resume");
        }

        public void actionPerformed(ActionEvent evt)
        {
            if ((computingImage == null) || (! computingImage.isAlive()))
            {
                // No currently running thread
                // Start a new one
                computingImage = new ComputingImageThread();
                computingImage.start();
            }
            else
            {
                // Resume currently running thread
                computingImage.setResumed();
            }
        }
    }

    /**
     * Class defining an action to suspend the computation.
     */
    class SuspendComputationAction extends AbstractAction
    {
        SuspendComputationAction()
        {
            super("Suspend");
        }

        public void actionPerformed(ActionEvent evt)
        {
            // Suspend currently running thread
            computingImage.setSuspended();
        }
    }

    /**
     * Class defining an action to stop the computation.
     */
    class StopComputationAction extends AbstractAction
    {
        StopComputationAction()
        {
            super("Stop");
        }

        public void actionPerformed(ActionEvent evt)
        {
            // Stop currently running thread
            computingImage.setStopped();
        }
    }

    /**
     * Main method. Starts a new MiniGUI.
     */
    public static void main(String args[])
    {
        MiniGUI rajaGUI = new MiniGUI();
        rajaGUI.pack();
        rajaGUI.setVisible(true);
        if (rajaGUI.fc == null)
        {
            // No access to local disk.  Inform the user.
            JOptionPane.showMessageDialog(rajaGUI,
                                          "Raja's Mini GUI is running in a restricted\n" +
                                          "environnment (no access to local disk).\n" +
                                          "Open/save functions are disabled.",
                                          "Warning",
                                          JOptionPane.WARNING_MESSAGE);
        }
    }
}


// =========================================
// File: /raja/ui/Util.java
// =========================================

/* $Id: Util.java,v 1.4 2001/02/25 01:28:40 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.ui;

import java.io.*;
import java.awt.image.BufferedImage;
import javax.swing.filechooser.FileFilter;

import raja.renderer.*;
import raja.io.*;


/**
 * Utility class providing static methods used by the Console UI and the Mini GUI.
 */
class Util
{
    static final String rajaVersion = "0.4.0-pre4";

    static final FileFilter rajaInputFileFilter = new FileFilter() {
            // Accept all directories and all .raj files.
            public boolean accept(File f)
            {
                if (f.isDirectory())
                {
                    return true;
                }

                String suffix = raja.util.FileHelper.getSuffix(f);
                return ((suffix != null) && suffix.equals("raj"));
            }

            // The description of this filter
            public String getDescription()
            {
                return "Raja input files (*.raj)";
            }
        };

    static final FileFilter imageFileFilter = new FileFilter() {
            // Accept all directories and all .png, .tiff, .jpg, .pnm and
            // .bmp files.
            public boolean accept(File f)
            {
                if (f.isDirectory())
                {
                    return true;
                }

                String codec = ImageIO.suffix2Codec(f);

                if (codec != null)
                {
                    return (codec.equals("PNG")  ||
                            codec.equals("TIFF") ||
                            codec.equals("JPEG") ||
                            codec.equals("PNM")  ||
                            codec.equals("BMP"));
                }
                return false;
            }

            // The description of this filter
            public String getDescription()
            {
                return "Image files";
            }
        };

    /**
     * Returns a string representing the given elapsed time given.
     */
    static String getTime(long totalMilliSeconds)
    {
        long milliSeconds = totalMilliSeconds % 1000;
        long totalSeconds = totalMilliSeconds / 1000;
        long seconds = totalSeconds % 60;
        long totalMinutes = totalSeconds / 60;
        long minutes = totalMinutes % 60;
        long totalHours = totalMinutes / 60;

        boolean display = false;
        String elapsedTime = "";

        if (totalHours > 0)
        {
            elapsedTime += totalHours + "h ";
            display = true;
        }
        if ((minutes > 0) || display)
        {
            elapsedTime += minutes + "m ";
            display = true;
        }
        if ((seconds > 0) || display)
        {
            elapsedTime += seconds + "s ";
            display = true;
        }

        elapsedTime += milliSeconds + "ms";

        return elapsedTime;
    }

    /**
     * Returns a renderer intialized with the given arguments.
     */
    static Renderer getRenderer(Scene scene,
                                Resolution resolution,
                                boolean exact,
                                int depth,
                                boolean diadic,
                                int antialiasLevel)
    {
        RayTracer rayTracer;

        if (exact) {
            rayTracer = new AdvancedRayTracer(scene.getWorld(), depth, 0);
        }
        else {
            rayTracer = new AdvancedRayTracer(scene.getWorld(), depth);
        }

        Sampler sampler;

        if (diadic) {
            sampler = new DiadicSampler();
        }
        else if (antialiasLevel > 0) {
            sampler = new NaiveSuperSampler(antialiasLevel);
        }
        else {
            sampler = new BasicSampler();
        }

        Renderer renderer = new BasicRenderer(scene.getCamera(),
                                              resolution,
                                              rayTracer,
                                              sampler,
                                              BufferedImage.TYPE_3BYTE_BGR);
        return renderer;
    }
}


// =========================================
// File: /raja/RGB.java
// =========================================

/* $Id: RGB.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja;

import raja.io.*;

import java.awt.Color;


/**
 * A class to encapsulate a high precision wavelength-dependent nonnegative
 * value.
 * The wavelength-dependent nonnegative value is defined by its
 * samples at the <b>R</b>ed, <b>G</b>reen and <b>B</b>lue wavelengths.
 * The samples can be any nonnegative double value; in particular,
 * {@link Double#POSITIVE_INFINITY} is allowed.  Note that for a color
 * the samples should range from 0 to 1 (see {@link #getColor}).
 *
 * @see Color
 *
 * @author Emmanuel Fleury
 * @author Grégoire Sutre
 */
public class RGB implements java.io.Serializable, Writable
{
    /**
     * The <i>red</i> sample.
     * @serial
     */
    private double r;

    /**
     * The <i>green</i> sample.
     * @serial
     */
    private double g;

    /**
     * The <i>blue</i> sample.
     * @serial
     */
    private double b;

    /**
     * The <code>RGB</code> wavelength-dependent value corresponding to the
     * black color.
     */
    public static final RGB black   = new RGB(0, 0, 0);

    /**
     * The <code>RGB</code> wavelength-dependent value corresponding to the
     * blue color.
     */
    public static final RGB blue    = new RGB(0, 0, 1);

    /**
     * The <code>RGB</code> wavelength-dependent value corresponding to the
     * cyan color.
     */
    public static final RGB cyan    = new RGB(0, 1, 1);

    /**
     * The <code>RGB</code> wavelength-dependent value corresponding to the
     * green color.
     */
    public static final RGB green   = new RGB(0, 1, 0);

    /**
     * The <code>RGB</code> wavelength-dependent value corresponding to the
     * magenta color.
     */
    public static final RGB magenta = new RGB(1, 0, 1);

    /**
     * The <code>RGB</code> wavelength-dependent value corresponding to the
     * red color.
     */
    public static final RGB red     = new RGB(1, 0, 0);

    /**
     * The <code>RGB</code> wavelength-dependent value corresponding to the
     * yellow color.
     */
    public static final RGB yellow  = new RGB(1, 1, 0);

    /**
     * The <code>RGB</code> wavelength-dependent value corresponding to the
     * white color.
     */
    public static final RGB white   = new RGB(1, 1, 1);

    /**
     * Creates an <code>RGB</code> wavelength-dependent value initialized
     * with the specified red, green, and blue samples.
     *
     * @param r a nonnegative double value corresponding to
     *          the red sample.
     * @param g a nonnegative double value corresponding to
     *          the green sample.
     * @param b a nonnegative double value corresponding to
     *          the blue sample.
     */
    public RGB(double r, double g, double b)
    {
        super();

        if ((r < 0) || (g < 0) || (b < 0) ||
            Double.isNaN(r) || Double.isNaN(g) || Double.isNaN(b))
        {
            throw new IllegalArgumentException("RGB parameter outside of expected range");
        }

        this.r = r;
        this.g = g;
        this.b = b;
    }

    /**
     * Creates an <code>RGB</code> constant value initialized with the
     * specified double value.
     *
     * @param c a nonnegative double value.
     */
    public RGB(double c)
    {
        this(c, c, c);
    }

    /**
     * Creates an <code>RGB</code> wavelength-dependent value corresponding
     * to the specified <code>Color</code>.
     *
     * @param c the color to be represented by the <code>RGB</code> object.
     * @see #getColor
     */
    public RGB(Color c)
    {
        this(((double) c.getRed()) / 255,
             ((double) c.getGreen()) / 255,
             ((double) c.getBlue()) / 255);
    }

    /**
     * Creates an <code>RGB</code> object from the specified
     * <code>ObjectReader</code>.
     *
     * @param reader the <code>ObjectReader</code> to read the
     *        fields from.
     */
    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        Number[] params = reader.readNumbers(3);

        return new RGB(params[0].doubleValue(),
                       params[1].doubleValue(),
                       params[2].doubleValue());
    }

    /**
     * Compares this object to the specified object.
     * The result is <code>true</code> if and only if the argument is not
     * <code>null</code> and is an <code>RGB</code> object that represents
     * the same wavelength-dependent value as this object (i.e. their
     * samples are the same).
     *
     * @param  obj the object to compare with.
     * @return <code>true</code> if the objects are the same;
     *         <code>false</code> otherwise.
     */
    public boolean equals(Object obj) {
        if ((obj != null) && (obj instanceof RGB))
        {
            RGB rgb = (RGB) obj;
            return ((r == rgb.r) && (g == rgb.g) && (b == rgb.b));
        }
        return false;
    }

    /**
     * Computes the <i>componentwise sum</i> of the two specified
     * <code>RGB</code> wavelength-dependent values.
     *
     * @param rgb1,&nbsp;rgb2 the <code>RGB</code> wavelength-dependent
     *                        values to sum.
     * @return an instance of <code>RGB</code> that is the componentwise
     *         sum of the two specified <code>RGB</code>
     *         wavelength-dependent values.
     */
    public static RGB sum(RGB rgb1, RGB rgb2)
    {
        return new RGB(rgb1.r + rgb2.r,
                       rgb1.g + rgb2.g,
                       rgb1.b + rgb2.b);
    }

    /**
     * Computes the <i>componentwise product</i> of the two specified
     * <code>RGB</code> wavelength-dependent values.
     *
     * @param rgb1,&nbsp;rgb2 the <code>RGB</code> wavelength-dependent
     *                        values to product.
     * @return an instance of <code>RGB</code> that is the componentwise
     *         product of the two specified <code>RGB</code>
     *         wavelength-dependent values.
     */
    public static RGB product(RGB rgb1, RGB rgb2)
    {
        return new RGB(rgb1.r * rgb2.r,
                       rgb1.g * rgb2.g,
                       rgb1.b * rgb2.b);
    }

    /**
     * Computes the <i>product</i> of the specified <code>RGB</code>
     * wavelength-dependent value with the specified double factor.
     *
     * @param rgb the <code>RGB</code> wavelength-dependent value
     *            to product with.
     * @param f   the double factor.
     * @return an instance of <code>RGB</code> that is the product of the
     *         specified <code>RGB</code> wavelength-dependent value with
     *         the specified double factor.
     */
    public static RGB product(RGB rgb, double f)
    {
        return new RGB(f * rgb.r,
                       f * rgb.g,
                       f * rgb.b);
    }

    /**
     * Computes the <i>componentwise max</i> of the two specified
     * <code>RGB</code> wavelength-dependent values.
     *
     * @param rgb1,&nbsp;rgb2 the <code>RGB</code> values to compare.
     * @return an instance of <code>RGB</code> that is the componentwise max
     *         of the two specified <code>RGB</code> wavelength-dependent
     *         values.
     */
    public static RGB max(RGB rgb1, RGB rgb2)
    {
        return new RGB(Math.max(rgb1.r, rgb2.r),
                       Math.max(rgb1.g, rgb2.g),
                       Math.max(rgb1.b, rgb2.b));
    }
	
	//////// ADDED by Murat Inan ///////////
    // Skaler ile çarpma
    public RGB multiply(double scalar) {
        return new RGB(
            this.r * scalar,
            this.g * scalar,
            this.b * scalar
        );
    }
    
    // Başka bir RGB ile çarpma (component-wise)
    public RGB multiply(RGB other) {
        return new RGB(
            this.r * other.getR(),
            this.g * other.getG(),
            this.b * other.getB()
        );
    }
    
    // Skaler ile çarpma ve mevcut nesneyi değiştirme (isteğe bağlı)
    public RGB multiplySelf(double scalar) {
        this.r *= scalar;
        this.g *= scalar;
        this.b *= scalar;
        return this;
    }
    
    /**
	 * Computes the componentwise sum of this RGB and the specified RGB.
	 * 
	 * @param other the RGB to add to this RGB
	 * @return a new RGB instance that is the componentwise sum of this RGB and the specified RGB
	 */
	public RGB add(RGB other) {
    return new RGB(this.r + other.getR(),
                   this.g + other.getG(), 
                   this.b + other.getB());
	}

    /**
     * İki RGB rengi arasında interpolasyon yapar
     * @param color1 İlk renk
     * @param color2 İkinci renk  
     * @param factor Interpolasyon faktörü (0.0 = color1, 1.0 = color2)
     * @return İnterpolasyon sonucu oluşan yeni RGB
     */
    public static RGB interpolate(RGB color1, RGB color2, double factor) {
        // Factor'ı [0,1] aralığına clamp et
        double t = Math.max(0.0, Math.min(1.0, factor));
        
        // Lineer interpolasyon
        double r = color1.getR() + (color2.getR() - color1.getR()) * t;
        double g = color1.getG() + (color2.getG() - color1.getG()) * t;
        double b = color1.getB() + (color2.getB() - color1.getB()) * t;
        
        return new RGB(r, g, b);
    }
    
    /**
     * Instance method olarak da ekleyelim (opsiyonel)
     * @param other Diğer renk
     * @param factor Interpolasyon faktörü (0.0 = this, 1.0 = other)
     * @return İnterpolasyon sonucu
     */
    public RGB interpolate(RGB other, double factor) {
        return RGB.interpolate(this, other, factor);
    }
	/////////////////////
	
    private static double inverse(double d)
    {
        if (d == 0)
        {
            return Double.POSITIVE_INFINITY;
        }
        else
        {
            return 1/d;
        }
    }

    /**
     * Computes the <i>componentwise inverse</i> of the specified
     * <code>RGB</code> wavelength-dependent value.
     * The inverse of a zero sample is {@link Double#POSITIVE_INFINITY}.
     *
     * @param rgb the <code>RGB</code> value to inverse.
     * @return an instance of <code>RGB</code> that is the componentwise
     *         inverse of the specified <code>RGB</code>
     *         wavelength-dependent value.
     */
    public static RGB inverse(RGB rgb)
    {
        return new RGB(inverse(rgb.r),
                       inverse(rgb.g),
                       inverse(rgb.b));
    }

    /**
     * Compares this <code>RGB</code> wavelength-dependent value with the
     * specified <code>RGB</code> wavelength-dependent value.
     *
     * @param rgb the <code>RGB</code> value to compare with.
     * @return <code>true</code> if this <code>RGB</code>
     *         wavelength-dependent value is smaller than the specified
     *         <code>RGB</code> wavelength-dependent value;
     *         <code>false</code> otherwise.
     */
    public boolean isSmaller(RGB rgb)
    {
        return (r <= rgb.r) && (g <= rgb.g) && (b <= rgb.b);
    }

    /**
     * Returns the <code>Color</code> corresponding to this <code>RGB</code>
     * wavelength-dependent value.
     * Each sample greater than 1 is truncated to 1 as this is the maximal
     * value for a <code>Color</code>'s component.
     *
     * @return a <code>Color</code> object corresponding to this
     *         <code>RGB</code> wavelength-dependent value.
     */
    public Color getColor()
    {
        return new Color(Math.min(1, (float) r),
                         Math.min(1, (float) g),
                         Math.min(1, (float) b));
    }
	
	// ADDED by Murat Inan
	public double getR() {
		return this.r;
	}
	
	public double getG() {
		return this.g;
	}
	
	public double getB() {
		return this.b;
	}
	
	public String toParametersString() {
		String s = ("" + r + ", " + g + ", " + b + "");
		return s;
	}
	/////////////////////
	
    /**
     * Returns a textual <code>String</code> representation of this
     * <code>RGB</code> object.
     */
    public String toString()
    {
        return ObjectWriter.toString(this);
    }

    /**
     * Writes the contents of this <code>RGB</code> object to the specified
     * <code>ObjectWriter</code>.
     *
     * @param writer the <code>ObjectWriter</code> to write the
     *        fields to.
     */
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        writer.write(" " + r + " ; " + g + " ; " + b + " ");
    }
}


// =========================================
// File: /raja/light/LightSource.java
// =========================================

/* $Id: LightSource.java,v 1.2 2001/02/25 01:31:46 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.light;

import raja.*;


/**
 * The interface for objects which represent light sources.
 *
 * @see World
 * @see LightRay
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
public interface LightSource
{
    /**
     * Returns the <code>LightRay</code> from the specified <code>Point3D</code> to the <code>LightSource</code>.
     * If the <code>LightSource</code> does not directly illuminate the specified <code>Point3D</code>, then this method
     * returns <code>null</code>.
     * @param p a specified <code>Point3D</code>.
     * @return the <code>LightRay</code> from the specified <code>Point3D</code> to the <code>LightSource</code> if
     *         the <code>LightSource</code> directly illuminates this point;
     *	       <code>null</code> otherwise.
     */
    public LightRay getLightRay(Point3D p);

    public RGB getMax();
    
    // ADDED by Murat Inan
    abstract public String getUsageInformation();
    abstract public LightSource getInstance(String info);
    abstract public String toExampleString();
    /////////
}


// =========================================
// File: /raja/light/PointLightSource.java
// =========================================

/* $Id: PointLightSource.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.light;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class PointLightSource implements LightSource, java.io.Serializable, Writable
{
    private RGB light;
    private Point3D origin;

    public PointLightSource(Point3D p, RGB light)
    {
        origin = p;
        this.light = light;
    }
    public PointLightSource(double x, double y, double z, RGB light)
    {
        origin = new Point3D(x, y, z);
        this.light = light;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("origin",null);
	map.put("light",null);

	/* Parsing */
	reader.readFields(map);
	
	return new PointLightSource((Point3D) map.get("origin"),
				    (RGB) map.get("light"));
    }

    public LightRay getLightRay(Point3D p)
    {
	return new LightRay(p, origin, light);
    }
    public RGB getMax()
    {
        return light;
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation()
	{
		String POINT_LIGHT_STR = "Constructor is: PointLightSource(double x, double y, double z, RGB light);\nExample:\n-3,0,5,  1.0, 1.0, 1.0\nEnter your values after three diyez symbol\n###\n";
		return POINT_LIGHT_STR;
	}
	
  private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public LightSource getInstance(String info)
	{
		this.exampleString = info;
		
		LightSource ls = new PointLightSource(
			new Point3D(-3.0, 0.0, 5.0), 
			new RGB(1.0, 1.0, 1.0)
		);
		
		String str = info.trim();
				
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return ls;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.length () < 11) return ls;
	
		String [] split = str.split (",");
		if (split == null) return ls;
		if (split.length < 6) return ls;
		
		try {
				double pdx = Double.parseDouble(split[0]);
				double pdy = Double.parseDouble(split[1]);
				double pdz = Double.parseDouble(split[2]);
	    
				double r = Double.parseDouble(split[3]);
				double g = Double.parseDouble(split[4]);
				double b = Double.parseDouble(split[5]);
				
				ls = new PointLightSource(pdx, pdy, pdz, new RGB(r, g, b));
				return ls;
		} catch (NumberFormatException nfe) {
			nfe.printStackTrace();
			return ls;
		}
	}
	////////////////

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "origin", origin },
                              { "light", light } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/light/DirectionalLightSource.java
// =========================================

/* $Id: DirectionalLightSource.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.light;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class DirectionalLightSource implements LightSource, java.io.Serializable, Writable
{
    private RGB light;
    private Vector3D direction;

    public DirectionalLightSource(Vector3D v, RGB light)
    {
        direction = v;
        this.light = light;
    }
    public DirectionalLightSource(double x, double y, double z, RGB light)
    {
        direction = new Vector3D(x, y, z);
        this.light = light;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("direction",null);
	map.put("light",null);

	/* Parsing */
	reader.readFields(map);

        return new DirectionalLightSource((Vector3D) map.get("direction"),
                                          (RGB) map.get("light"));
    }

    public LightRay getLightRay(Point3D p)
    {
	return new LightRay(p, Vector3D.opposite(direction), light, Double.POSITIVE_INFINITY);
    }
    public RGB getMax()
    {
        return light;
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation()
	{
		String DIRECTIONAL_LIGHT_STR = "Constructor is: DirectionalLightSource(double x, double y, double z, RGB light);\nExample:\n0,0,-1,  1.0, 1.0, 1.0\nEnter your values after three diyez symbol\n###\n";
		return DIRECTIONAL_LIGHT_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public LightSource getInstance(String info)
	{
		this.exampleString = info;
		
		LightSource ls = new DirectionalLightSource(
			new Vector3D(-5.0, 0.0, 5.0), 
			new RGB(1.0, 1.0, 1.0)
		);
		
		String str = info.trim();
				
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return ls;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.length () < 11) return ls;
	
		String [] split = str.split (",");
		if (split == null) return ls;
		if (split.length < 6) return ls;
		
		try {
				double pdx = Double.parseDouble(split[0]);
				double pdy = Double.parseDouble(split[1]);
				double pdz = Double.parseDouble(split[2]);
	    
				double r = Double.parseDouble(split[3]);
				double g = Double.parseDouble(split[4]);
				double b = Double.parseDouble(split[5]);

				ls = new DirectionalLightSource(pdx, pdy, pdz, new RGB(r, g, b));
				return ls;
		} catch (NumberFormatException nfe) {
			nfe.printStackTrace();
			return ls;
		}
	}
	////////////////

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "direction", direction },
                              { "light", light } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/light/SpotLightSource.java
// =========================================

// Murat Inan
package raja.light;

import raja.*;
import raja.io.*;
import java.util.HashMap;

public class SpotLightSource implements LightSource, java.io.Serializable, Writable
{
    private RGB light;
    private Point3D origin;
    private Vector3D direction;
    private double cutoffAngle; // in degrees
    private double exponent;    // falloff exponent

    public SpotLightSource(Point3D origin, Vector3D direction, double cutoffAngle, double exponent, RGB light)
    {
        this.origin = origin;
        this.direction = direction.normalization();
        this.cutoffAngle = cutoffAngle;
        this.exponent = exponent;
        this.light = light;
    }

    public SpotLightSource(double x, double y, double z, 
                          double dx, double dy, double dz,
                          double cutoffAngle, double exponent, RGB light)
    {
        this.origin = new Point3D(x, y, z);
        this.direction = new Vector3D(dx, dy, dz).normalization();
        this.cutoffAngle = cutoffAngle;
        this.exponent = exponent;
        this.light = light;
    }

    public static Object build(ObjectReader reader) throws java.io.IOException
    {
        HashMap map = new HashMap();
        map.put("origin", null);
        map.put("direction", null);
        map.put("cutoffAngle", null);
        map.put("exponent", null);
        map.put("light", null);

        reader.readFields(map);
        
        return new SpotLightSource((Point3D) map.get("origin"),
                                 (Vector3D) map.get("direction"),
                                 (Double) map.get("cutoffAngle"),
                                 (Double) map.get("exponent"),
                                 (RGB) map.get("light"));
    }

    public LightRay getLightRay(Point3D p)
    {
        Vector3D toLight = new Vector3D(p, origin);
        double distance = toLight.magnitude();
        Vector3D toLightNormalized = toLight.normalization();
        
        // Calculate angle between spotlight direction and vector to point
        double cosTheta = Vector3D.dotProduct(Vector3D.opposite(direction), toLightNormalized);
        double theta = Math.acos(cosTheta) * 180.0 / Math.PI;
        
        // If point is outside cutoff angle, no light
        if (theta > cutoffAngle) {
            return null;
        }
        
        // Calculate attenuation based on angle
        double cosCutoff = Math.cos(cutoffAngle * Math.PI / 180.0);
        double attenuation = Math.pow(cosTheta, exponent);
        
        // Apply attenuation to light intensity
        RGB attenuatedLight = new RGB(
            light.getR() * attenuation,
            light.getG() * attenuation, 
            light.getB() * attenuation
        );
        
        return new LightRay(p, origin, attenuatedLight);
    }

    public RGB getMax()
    {
        return light;
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation()
	{
		String SPOT_LIGHT_STR = "Constructor is: SpotLightSource(double x, double y, double z, double dx, double dy, double dz, double cutoffAngle, double exponent, RGB light);\nExample:\n-3,0,5,  0,1,0,  5.0, 25,  1.0, 1.0, 1.0\nEnter your values after three diyez symbol\n###\n";
		return SPOT_LIGHT_STR;
	}
	
   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
  
	@Override
    public LightSource getInstance(String info)
	{
		this.exampleString = info;
		
		LightSource ls = new SpotLightSource(
			-3.0, 0.0, 5.0, 
			0, 1, 0, 
			5.0, 25.0,
			RGB.white
		);

		String str = info.trim();
				
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return ls;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.length () < 11) return ls;
	
		String [] split = str.split (",");
		if (split == null) return ls;
		if (split.length < 6) return ls;
		
		try {
				double px = Double.parseDouble(split[0]);
				double py = Double.parseDouble(split[1]);
				double pz = Double.parseDouble(split[2]);
				
				double dx = Double.parseDouble(split[3]);
				double dy = Double.parseDouble(split[4]);
				double dz = Double.parseDouble(split[5]);
				
				double ca = Double.parseDouble(split[6]);
				double ep = Double.parseDouble(split[7]);
				
				double r = Double.parseDouble(split[8]);
				double g = Double.parseDouble(split[9]);
				double b = Double.parseDouble(split[10]);

				ls = new SpotLightSource(px, py, pz, dx, dy, dz, ca, ep, new RGB(r, g, b));
				return ls;
		} catch (NumberFormatException nfe) {
			nfe.printStackTrace();
			return ls;
		}
	}
	////////////////

    public String toString()
    {
        return ObjectWriter.toString(this);
    }

    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { 
            { "origin", origin },
            { "direction", direction },
            { "cutoffAngle", cutoffAngle },
            { "exponent", exponent },
            { "light", light }
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/util/DirectedGraph.java
// =========================================

/* $Id: DirectedGraph.java,v 1.1.1.1 2001/01/08 23:10:15 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.util;

import java.util.Collection;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;

import raja.io.*;


public class DirectedGraph implements java.io.Serializable, Writable
{
    public class Edge implements java.io.Serializable, Writable
    {
        private Object source;
        private Object dest;

        public Edge(Object source, Object dest)
        {
            this.source = source;
            this.dest = dest;
        }

        public Object getSource()
        {
            return source;
        }
        public Object getDest()
        {
            return dest;
        }

        public String toString()
        {
            return ObjectWriter.toString(this);
        }
        public void write(ObjectWriter writer) throws java.io.IOException
        {
            writer.writeIndent();
            writer.writeObject(source);
            writer.write(" >> ");
            writer.writeObject(dest);
        }
    }

    private Map postSets;

    public DirectedGraph()
    {
        postSets = new HashMap();
    }

    public void addEdge(Object source, Object dest)
    {
        Set post = (Set) postSets.get(source);

        if (post == null) {
            post = new HashSet();
            postSets.put(source, post);
        }
        post.add(dest);
    }
    public boolean hasEdge(Object source, Object dest)
    {
        Set post = (Set) postSets.get(source);
        return ((post != null) && post.contains(dest));
    }
    public boolean hasEdges(Object source, Collection dest)
    {
        if (dest.isEmpty())
        {
            return true;
        }

        Set post = (Set) postSets.get(source);
        return ((post != null) && post.containsAll(dest));
    }
    public Iterator edges()
    {
        class EdgeIterator implements Iterator
        {
            private boolean hasNext;
            private Object currentSource;
            Iterator iterPosts;
            Iterator iterSuccessors;

            EdgeIterator()
            {
                iterPosts = postSets.entrySet().iterator();
                init();
            }
            private void init()
            {
                hasNext = iterPosts.hasNext();

                if (hasNext)
                {
                    Map.Entry currentPost = (Map.Entry) iterPosts.next();
                    currentSource = currentPost.getKey();
                    iterSuccessors = ((Set) currentPost.getValue()).iterator();
                }
            }

            public boolean hasNext()
            {
                return hasNext;
            }
            public Object next()
            {
                if (! hasNext)
                {
                    throw new java.util.NoSuchElementException();
                }

                Edge e = new Edge(currentSource, iterSuccessors.next());
                if (! (iterSuccessors.hasNext()))
                {
                    init();
                }
                return e;
            }
            public void remove()
            {
                throw new UnsupportedOperationException();
            }
        }

        return new EdgeIterator();
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        writer.write("[[\n");
        writer.incrementIndent();

        boolean putComma = false;

        for(Iterator iterEdges = edges() ; iterEdges.hasNext() ;)
        {
            Edge currentEdge = (Edge) iterEdges.next();
            if (putComma)
            {
                writer.write(",\n");
            }
            writer.writeIndent();
            writer.writeObject(currentEdge);
            putComma = true;
        }

        writer.decrementIndent();
        writer.writeIndent();
        writer.write("]]");
    }
}


// =========================================
// File: /raja/util/List.java
// =========================================

/* $Id: List.java,v 1.1.1.1 2001/01/08 23:10:15 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.util;

import raja.io.*;
import java.util.*;


public class List extends LinkedList implements java.io.Serializable, Writable
{
    public List()
    {
        super();
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Iterator iter = iterator();
        writer.write("[\n");
        writer.incrementIndent();
        int maxIndex = size() - 1;
        for (int i = 0; i <= maxIndex; i++) {
            Object obj = iter.next();
            writer.writeIndent();
            writer.writeObject(obj);
            if (i < maxIndex)
            {
                writer.write(",");
            }
            writer.write("\n");
        }
        writer.decrementIndent();
        writer.writeIndent();
        writer.write("]");
    }
}


// =========================================
// File: /raja/util/FileHelper.java
// =========================================

/* $Id: FileHelper.java,v 1.1 2001/02/16 00:57:03 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.util;

import java.io.File;


public final class FileHelper
{
    /**
     * Don't let anyone instantiate this class.
     */
    private FileHelper()
    {
    }

    /**
     * Returns the suffix of the given file name.  This method returns
     * <code>null</code> if the given file name has no suffix.
     */
    public static String getSuffix(String fileName)
    {
        String suffix = null;
        int i = fileName.lastIndexOf('.');

        if ((i > 0) && (i < (fileName.length() - 1)))
        {
            suffix = fileName.substring(i+1).toLowerCase();
        }

        return suffix;
    }

    /**
     * Returns the suffix of the given file's name.  This method returns
     * <code>null</code> if the given file's name has no suffix.
     */
    public static String getSuffix(File f)
    {
        return getSuffix(f.getName());
    }
}


// =========================================
// File: /raja/Vector3D.java
// =========================================

/* $Id: Vector3D.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja;

import raja.io.*;


/**
 * The <code>Vector3D</code> class defines a high precision vector in the 3
 * dimensional space, given by its 3D coordinates.  This class provides
 * most of the classical operations on vectors (norm, dot product, cross
 * product, projection...).
 *
 * @see Point3D
 *
 * @author Emmanuel Fleury
 * @author Grégoire Sutre
 */
public class Vector3D implements java.io.Serializable, Writable
{
    /**
     * The <i>x</i> coordinate.
     * @serial
     */
    public double x;

    /**
     * The <i>y</i> coordinate.
     * @serial
     */
    public double y;

    /**
     * The <i>z</i> coordinate.
     * @serial
     */
    public double z;

    /**
     * Creates a <code>Vector3D</code> object initialized with the
     * specified 3D coordinates.
     * 
     * @param x,&nbsp;y,&nbsp;z the coordinates to which to set the newly
     *                          constructed <code>Vector3D</code>.
     */
    public Vector3D(double x, double y, double z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * Initializes a newly created <code>Vector3D</code> object so that it
     * represents the same 3 dimensional vector as the argument.  In other
     * words, the newly created <code>Vector3D</code> is a copy of the
     * specified <code>Vector3D</code>.
     * 
     * @param p a <code>Vector3D</code> object.
     */
    public Vector3D(Vector3D v)
    {
        this(v.x, v.y, v.z);
    }

    /**
     * Initializes a newly created <code>Vector3D</code> object so that it
     * represents the vector <i>connecting</i> the two specified 3D points.
     * 
     * @param source the source <code>Point3D</code>.
     * @param dest the destination <code>Point3D</code>.
     */
    public Vector3D(Point3D source, Point3D dest)
    {
        this(dest.x - source.x,
             dest.y - source.y,
             dest.z - source.z);
    }

    /**
     * Creates a <code>Vector3D</code> object from the specified
     * <code>ObjectReader</code>.
     *
     * @param reader the <code>ObjectReader</code> to read the
     *        fields from.
     */
    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        Number[] params = reader.readNumbers(3);

        return new Vector3D(params[0].doubleValue(),
                            params[1].doubleValue(),
                            params[2].doubleValue());
    }

    /**
     * Computes the <i>norm</i> of this <code>Vector3D</code>.
     *
     * @return the norm of this <code>Vector3D</code>.
     */
    public double norm()
    {
        return Math.sqrt(normSq());
    }

    /**
     * Computes the <i>square of the norm</i> of this <code>Vector3D</code>.
     *
     * @return the square of the norm of this <code>Vector3D</code>.
     */
    public double normSq()
    {
        return (x*x + y*y + z*z);
    }

    /**
     * Computes a normed version of the specified <code>Vector3D</code>.
     * The norm of the <code>Vector3D</code> argument is assumed to be non
     * zero.
     *
     * @param v a <code>Vector3D</code> object, whose norm is non zero.
     * @return a normed version of the specified <code>Vector3D</code>.
     */
    public static Vector3D normalization(Vector3D v)
    {
        return product(v, 1.0 / v.norm());
    }
	
	/**
	* ADDED by Murat Inan
	* Returns a new vector that is the negation of this vector.
	* Each component of the resulting vector is the negative of the corresponding component in this vector.
	* 
	* @return A new Vector3D representing the negation of this vector
	*/
	public Vector3D negation() {
		return new Vector3D(-x, -y, -z);
	}
	
	// ADDED by Murat Inan
	public static Vector3D difference(Vector3D v1, Vector3D v2) {
		return new Vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
	}

	/**
	* Returns the magnitude (length) of this vector.
	* This is equivalent to the norm of the vector.
	*
	* ADDED by Murat Inan
	* @return the magnitude of this vector.
	*/
	public double magnitude() {
		return Math.sqrt(x * x + y * y + z * z);
	}

	// ADDED by Murat Inan, This give more transparan shapes
    public Vector3D normalization3()
    {
		double nm = 1.0 / norm();
		Vector3D vc = new Vector3D(nm * x, nm * y, nm * z);
        return product(vc, nm);
    }
    
    // ADDED by Murat Inan
	public Vector3D normalization()
	{
		double n = norm();
		if (n == 0) return new Vector3D(0, 0, 0); // avoid div by zero
		return new Vector3D(x / n, y / n, z / n);
	}
	
	// ADDED by Murat Inan
	public Vector3D normalization2()
	{
		double magnitude = norm();
		if (magnitude <= 1e-10) { // floating point tolerance
			return new Vector3D(0, 0, 0);
		}
		double scale = 1.0 / magnitude;
		return new Vector3D(x * scale, y * scale, z * scale);
	}

   /**
     * Computes the <i>dot product</i> of the two specified
     * <code>Vector3D</code>.
     *
     * @param v1,&nbsp;v2 the two <code>Vector3D</code> to dot product.
     * @return the dot product of the two specified
     * <code>Vector3D</code>.
     */
    public static double dotProduct(Vector3D v1, Vector3D v2)
    {
        return ((v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z));
    }

    /**
     * Computes the <i>product</i> of the specified <code>Vector3D</code>
     * with the specified double factor.
     *
     * @param v the <code>Vector3D</code> product with.
     * @param f the double factor.
     * @return an instance of <code>Vector3D</code> that is the product of
     * the specified <code>Vector3D</code> with the specified double factor.
     */
    public static Vector3D product(Vector3D v, double f)
    {
        return new Vector3D(f * v.x,
                            f * v.y,
                            f * v.z);
    }

    /**
     * Computes the <i>cross product</i> of the two specified
     * <code>Vector3D</code>.
     *
     * @param v1,&nbsp;v2 the two <code>Vector3D</code> to cross product.
     * @return an instance of <code>Vector3D</code> that is the cross
     * product of the two specified <code>Vector3D</code>.
     */
    public static Vector3D crossProduct(Vector3D v1, Vector3D v2)
    {
        return new Vector3D((v1.y * v2.z) - (v1.z * v2.y),
                            (v1.z * v2.x) - (v1.x * v2.z),
                            (v1.x * v2.y) - (v1.y * v2.x));
    }

    /**
     * Computes the <i>sum</i> of the two specified <code>Vector3D</code>.
     *
     * @param v1,&nbsp;v2 the two <code>Vector3D</code> to sum.
     * @return an instance of <code>Vector3D</code> that is the sum of the
     * two specified <code>Vector3D</code>.
     */
    public static Vector3D sum(Vector3D v1, Vector3D v2)
    {
        return new Vector3D((v1.x + v2.x),
                            (v1.y + v2.y),
                            (v1.z + v2.z));
    }

    /**
     * Computes the <i>opposite</i> of the specified <code>Vector3D</code>.
     *
     * @param v the <code>Vector3D</code> to compute the opposite of.
     * @return an instance of <code>Vector3D</code> that is the
     *         opposite of the specified <code>Vector3D</code>.
     */
    public static Vector3D opposite(Vector3D v)
    {
        return new Vector3D(- v.x,
                            - v.y,
                            - v.z);
    }

    /**
     * Computes the <i>projection</i> of the specified <code>Vector3D</code>
     * on the hyperplane given by the specified normal.
     *
     * @param v the <code>Vector3D</code> project.
     * @param n the normal of the hyperplane to project the specified
     *        <code>Vector3D</code> on.
     * @return an instance of <code>Vector3D</code> that is the projection
     * of the specified <code>Vector3D</code> on the hyperplane given by the
     * specified normal.
     */
    public static Vector3D projection(Vector3D v, Vector3D n)
    {
        double sc = dotProduct(v, n);
        return Vector3D.sum(v, Vector3D.product(n, -sc));
    }

    /**
     * Returns a textual <code>String</code> representation of this
     * <code>Vector3D</code> object.
     */
    public String toString()
    {
        return ObjectWriter.toString(this);
    }

	/**
	* Returns the squared length (norm squared) of this vector.
	* This is equivalent to x*x + y*y + z*z.
	*
	* ADDED by Murat Inan
	* @return the squared length of this vector.
	*/
	public double lengthSquared() {
		return x * x + y * y + z * z;
	}

    /**
     * Writes the contents of this <code>Vector3D</code> object to the
     * specified <code>ObjectWriter</code>.
     *
     * @param writer the <code>ObjectWriter</code> to write the
     *        fields to.
     */
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Number[] fields = { new Double(x), new Double(y), new Double(z) };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/renderer/Camera.java
// =========================================

/* $Id: Camera.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.Ray;


public abstract class Camera implements java.io.Serializable
{
    abstract Ray getRay(double x, double y);
    
    // ADDED by Murat Inan
    abstract public String getUsageInformation();
    abstract public Camera getInstance(String info);
	abstract public String toExampleString();
    /////////
}


// =========================================
// File: /raja/renderer/World.java
// =========================================

/* $Id: World.java,v 1.1 2001/02/25 01:25:18 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.*;
import raja.light.LightSource;
import raja.shape.*;
import raja.io.*;
import raja.util.List;

import java.util.HashMap;
import java.util.Iterator;


public class World implements java.io.Serializable, Writable
{
	private static final long serialVersionUID = 123456789L;
	    
    private Solid solid;
    private List lights;
    private RGB backgroundLight;
    private RGB ambiantLight;
    private Volume ambiantVolume;
	
	// ADDED by Murat Inan for easier writing to objectoutputStream
	private Camera camera = new HorizontalCamera(
      new Point3D(-3.0, 0.0, 0.0),
      new Vector3D(1.0, 0.0, 0.0),
      1.8, 2.0, 1.5
    );
	private int imageWidth = 800;
	private int imageHeight = 600;
	private int imageDepth = 3;
	//////////////////////
	
    public World(Solid solid)
    {
        this.solid = solid;
        lights = new List();
        backgroundLight = RGB.black;
        ambiantLight = RGB.black;
        ambiantVolume = new IsotropicVolume(1.0);
    }

    public World(Solid solid, 
		 List lights, 
		 RGB backgroundLight, 
		 RGB ambiantLight, 
		 Volume ambiantVolume)
    {
        this.solid = solid;
        this.lights = lights;
        this.backgroundLight = backgroundLight;
        this.ambiantLight = ambiantLight;
        this.ambiantVolume = ambiantVolume;
    }    
	
	// ADDED by Murat Inan ////
	public Camera getCamera() {
		return this.camera;
	}
	
	public int getImageWidth() {
		return this.imageWidth;
	}
	
	public int getImageHeight() {
		return this.imageHeight;
	}
	
	public int getImageDepth() {
		return this.imageDepth;
	}
	
	public void setCamera(Camera c) {
		this.camera = c;
	}
	
	public void setImageWidth(int nw) {
		this.imageWidth = nw;
	}
	
	public void setImageHeight(int nh) {
		this.imageHeight = nh;
	}
	
	public void setImageDepth(int dp) {
		this.imageDepth = dp;
	}
	//////////////////////////
	
    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("lights", new List());
	map.put("solid", null);
	map.put("ambiantLight", RGB.black);
	map.put("backgroundLight", RGB.black);
	map.put("ambiantVolume", new IsotropicVolume(1.0));

	/* Parsing */
	reader.readFields(map);
       
	return new World((Solid) map.get("solid"),
                         (List) map.get("lights"),
                         (RGB) map.get("backgroundLight"),
                         (RGB) map.get("ambiantLight"),
                         (Volume) map.get("ambiantVolume"));
    }

    public void addLightSource(LightSource light)
    {
        lights.add(light);
    }
    public Iterator lightIterator()
    {
        return lights.iterator();
    }
    public Solid getSolid()
    {
        return solid;
    }
    public void setBackgroundLight(RGB light)
    {
        backgroundLight = light;
    }
    public void setAmbiantLight(RGB light)
    {
        ambiantLight = light;
    }
    public void setAmbiantVolume(Volume v)
    {
        ambiantVolume = v;
    }
    public RGB getBackgroundLight()
    {
        return backgroundLight;
    }
    public RGB getAmbiantLight()
    {
        return ambiantLight;
    }
    public double getAmbiantRefractiveIndex(Point3D p)
    {
        return ambiantVolume.refractiveIndex(p);
    }
	
	public String toImportantParametersString() {
		StringBuffer sb = new StringBuffer();
		sb.append("Width: "+Integer.toString(imageWidth)+"\n");
		sb.append("Height: "+Integer.toString(imageHeight)+"\n");
		sb.append("Depth: "+Integer.toString(imageDepth)+"\n");
		sb.append("Volume: "+Double.toString(ambiantVolume.refractiveIndex(null))+"\n\n");
		sb.append("BGColor: "+backgroundLight.toParametersString()+"\n");
		sb.append("Ambiant/Shadow Color: "+ambiantLight.toParametersString()+"\n");
		//sb.append("Camera: "+camera.toString()+"\n\n");
		
		return sb.toString();
	}
	
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "solid", solid },
                              { "lights", lights },
                              { "backgroundLight", backgroundLight },
                              { "ambiantLight", ambiantLight },
                              { "ambiantVolume", ambiantVolume } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/renderer/Resolution.java
// =========================================

/* $Id: Resolution.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

public class Resolution implements java.io.Serializable
{
    /**
     * The width resolution.
     *
     * @serial
     */
    public int width;

    /**
     * The height resolution.
     *
     * @serial
     */
    public int height;

    /**
     * Constructs a Resolution and initializes it to the specified width and
     * specified height.
     * @param width the specified width resolution
     * @param height the specified height resolution
     */
    public Resolution(int width, int height) {
	this.width = width;
	this.height = height;
    }

    /**
     * Returns a textual <code>String</code> representation of this
     * <code>Resolution</code> object.
     */
    public String toString()
    {
        return width + "x" + height;
    }
}


// =========================================
// File: /raja/renderer/Sampler.java
// =========================================

/* $Id: Sampler.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import java.awt.image.BufferedImage;
import javax.swing.BoundedRangeModel;


public interface Sampler
{
    public void compute(Camera camera, RayTracer rt, BoundedRangeModel model, BufferedImage image);
    public void compute(Camera camera, RayTracer rt, BufferedImage image);
}


// =========================================
// File: /raja/renderer/AdvancedRayTracer.java
// =========================================

/* $Id: AdvancedRayTracer.java,v 1.2 2001/02/25 01:25:18 gregoire Exp $
 * Copyright (C) 1999-2001 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.*;
import raja.light.LightSource;
import raja.shape.*;

import java.awt.image.BufferedImage;
import java.util.Iterator;


public class AdvancedRayTracer implements RayTracer
{
    private World world;
    private RGB cutLevel;
    private int maxDepth;

    public AdvancedRayTracer(World world, int maxDepth, float accuracy)
    {
        this.world = world;
        this.maxDepth = maxDepth;
        computeCutLevel(accuracy);
    }
    public AdvancedRayTracer(World world, int maxDepth)
    {
        this(world, maxDepth, 1);
    }

    private void computeCutLevel(float accuracy)
    {
        RGB maxLight = RGB.max(world.getAmbiantLight(), world.getBackgroundLight());

        for(Iterator iterLight = world.lightIterator() ; iterLight.hasNext() ;)
        {
            LightSource currentLightSource = (LightSource) iterLight.next();
            maxLight = RGB.sum(maxLight, currentLightSource.getMax());
        }
        cutLevel = RGB.product(RGB.product(RGB.inverse(maxLight), 1.0 / (3 * 255)), accuracy);
    }

    public RGB getLight(Ray ray)
    {
        return acceleratedRecursiveRay(maxDepth, ray, RGB.white);
    }
    private RGB acceleratedRecursiveRay(int depth, Ray ray, RGB coeff)
    {
        // Cherche le point d'intersection du rayon ray avec les objets et :
        // 1. s'il n'y a pas d'intersection : on renvoie la lumi�re de fond
        // 2. sinon, on renvoie la somme de localLight, et de reflectedLight
        // au point d'intersection (et de refractedLight... a implementer)

        if ((depth <= 0) || coeff.isSmaller(cutLevel))
        {
            return RGB.black;
        }

        SolidLocalGeometry intersection = world.getSolid().intersection(ray);

        if (intersection == null)
        {
            // Le rayon n'a rencontr� aucun objet 3D du monde
            // On colorie donc le pixel avec la couleur de fond

            return RGB.product(world.getBackgroundLight(), coeff);
        }
        else
        {
            // Le rayon a rencontr� un objet. Le premier objet qu'il 
            // rencontr� est donn� par la variable "solid" et l'intersection
            // se fait au point donn� par la variable "intersection"

            Vector3D normalAtIntersection = intersection.getNormal();
            double sc = Vector3D.dotProduct(normalAtIntersection, ray.direction);
            Vector3D mirrorDirection = Vector3D.sum(ray.direction, Vector3D.product(normalAtIntersection, - 2 * sc));

            boolean rayIntersectsIn = (sc > 0);

            LocalTexture localTexture;
            if (rayIntersectsIn) {
                localTexture = intersection.getInLocalTexture();
            }
            else {
                localTexture = intersection.getOutLocalTexture();
            }

            RGB krg = localTexture.getKrg();
            RGB ktg = localTexture.getKtg();

            RGB result = RGB.product(localLight(ray, intersection, normalAtIntersection, mirrorDirection, localTexture, rayIntersectsIn), coeff);

            if (! (RGB.product(ktg, coeff)).isSmaller(cutLevel)) {
                double nI;
                double nT;

                if (rayIntersectsIn) {
                    if (intersection.inVolumeUndefined()) {
                        nI = world.getAmbiantRefractiveIndex(intersection);
                    }
                    else {
                        nI = intersection.getInRefractiveIndex();
                    }

                    if (intersection.outVolumeUndefined()) {
                        nT = world.getAmbiantRefractiveIndex(intersection);
                    }
                    else {
                        nT = intersection.getOutRefractiveIndex();
                    }
                }
                else {
                    if (intersection.inVolumeUndefined()) {
                        nT = world.getAmbiantRefractiveIndex(intersection);
                    }
                    else {
                        nT = intersection.getInRefractiveIndex();
                    }

                    if (intersection.outVolumeUndefined()) {
                        nI = world.getAmbiantRefractiveIndex(intersection);
                    }
                    else {
                        nI = intersection.getOutRefractiveIndex();
                    }
                }

                double k = nI / nT;

/*
                double thetaI = Math.acos(Math.abs(sc));
                double thetaT = Math.asin(k * Math.sin(thetaI));

                if (Double.isNaN(thetaT)) {
                    // R�flexion totale : pas de rayon r�fract�
                    krg = RGB.sum(krg, ktg);
                }
                else {
                    double reflex = 0.5 * (Math.pow(Math.sin(thetaI - thetaT), 2) / Math.pow(Math.sin(thetaI + thetaT), 2))
                                        * (1 + (Math.pow(Math.cos(thetaI + thetaT), 2) / Math.pow(Math.cos(thetaI - thetaT), 2)));

                    krg = RGB.sum(krg, RGB.product(ktg, reflex));
                    ktg = RGB.product(ktg, 1 - reflex);

                    double square = 1 - (k*k * (1 - sc*sc));
                    double sc2;

                    if (rayIntersectsIn) {
                        sc2 = Math.sqrt(square);
                    }
                    else {
                        sc2 = - Math.sqrt(square);
                    }
*/

                double cosThetaI = Math.abs(sc);
                double sinThetaI = Math.sqrt(1 - cosThetaI*cosThetaI);
                double sinThetaT = k * sinThetaI;

                if (sinThetaT > 1) {
                    // R�flexion totale : pas de rayon r�fract�
                    krg = RGB.sum(krg, ktg);
                }
                else {
                    double cosThetaT = Math.sqrt(1 - sinThetaT*sinThetaT);

                    double tmp1, tmp2;

                    tmp1 = sinThetaT*cosThetaI;
                    tmp2 = cosThetaT*sinThetaI;
                    double sinThetaIplusThetaT  = tmp1 + tmp2;
                    double sinThetaImoinsThetaT = tmp1 - tmp2;

                    tmp1 = cosThetaI*cosThetaT;
                    tmp2 = sinThetaI*sinThetaT;
                    double cosThetaIplusThetaT  = tmp1 - tmp2;
                    double cosThetaImoinsThetaT = tmp1 + tmp2;

                    double reflex = 0.5 * ((sinThetaImoinsThetaT*sinThetaImoinsThetaT) / (sinThetaIplusThetaT*sinThetaIplusThetaT))
                                        * (1 + ((cosThetaIplusThetaT*cosThetaIplusThetaT) / (cosThetaImoinsThetaT*cosThetaImoinsThetaT)));

                    krg = RGB.sum(krg, RGB.product(ktg, reflex));
                    ktg = RGB.product(ktg, 1 - reflex);

                    double sc2;

                    if (rayIntersectsIn) {
                        sc2 = cosThetaT;
                    }
                    else {
                        sc2 = - cosThetaT;
                    }

                    Vector3D transmissionDirection = Vector3D.sum(Vector3D.product(ray.direction, k),
                                                                  Vector3D.product(normalAtIntersection, sc2 - (k * sc)));
                    Ray refractedRay = new Ray(intersection, transmissionDirection);
                    result = RGB.sum(result, acceleratedRecursiveRay(depth - 1, refractedRay, RGB.product(ktg, coeff)));
                }
            }
            Ray reflectedRay = new Ray(intersection, mirrorDirection);
            result = RGB.sum(result, acceleratedRecursiveRay(depth - 1, reflectedRay, RGB.product(krg, coeff)));

            return result;
        }
    }
    private RGB localLight(Ray ray, Point3D intersection, Vector3D normalAtIntersection, Vector3D mirrorDirection, LocalTexture localTexture, boolean rayIntersectsIn)
    {
        // On d�termine la lumi�re re�ue par le point d'intersection

        RGB outgoingLightAtIntersection = RGB.product(world.getAmbiantLight(), localTexture.getKd());

        for(Iterator iterLight = world.lightIterator() ; iterLight.hasNext() ;)
        {
            LightSource currentLightSource = (LightSource) iterLight.next();
            LightRay rayToLightSource = currentLightSource.getLightRay(intersection);

	    if (rayToLightSource == null) {
		continue;
	    }

	    double dotProduct;

            if (rayIntersectsIn) {
                dotProduct = - Vector3D.dotProduct(normalAtIntersection, rayToLightSource.direction);
            }
            else {
                dotProduct = Vector3D.dotProduct(normalAtIntersection, rayToLightSource.direction);
            }

            boolean isInShadow = false;

            // On d�termine si le point d'intersection est dans l'ombre
            // de la lumi�re en cours de traitement

            if (dotProduct < 0) {
                isInShadow = true;
            }
            else if (world.getSolid().intersects(rayToLightSource)) {
                isInShadow = true;
            }

            if (! isInShadow)
            {
                // Le point d'intersection est illumin� par la source de lumi�re en cours de traitement
                // et on ajoute donc la contribution de cette source de lumi�re

                RGB diffusionLight = RGB.product(RGB.product(rayToLightSource.light, dotProduct), localTexture.getKd());
                double scHalo = Vector3D.dotProduct(rayToLightSource.direction, mirrorDirection);
                RGB reflectionLight = RGB.product(rayToLightSource.light, Math.pow(Math.max(0, scHalo), localTexture.getNs()));
                RGB localLight = RGB.sum(diffusionLight, RGB.product(reflectionLight, localTexture.getKrl()));
                outgoingLightAtIntersection = RGB.sum(outgoingLightAtIntersection, localLight);
            }
        }
        return outgoingLightAtIntersection;
    }
}


// =========================================
// File: /raja/renderer/Renderer.java
// =========================================

/* $Id: Renderer.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import java.awt.image.BufferedImage;
import javax.swing.BoundedRangeModel;


public interface Renderer extends Runnable
{
    public BufferedImage getImage();
    public BoundedRangeModel getModel();
}


// =========================================
// File: /raja/renderer/NaiveSuperSampler.java
// =========================================

/* $Id: NaiveSuperSampler.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.*;

import java.awt.image.BufferedImage;
import javax.swing.BoundedRangeModel;


public class NaiveSuperSampler implements Sampler
{
    private int antialiasLevel;

    public NaiveSuperSampler(int antialiasLevel)
    {
        if (antialiasLevel < 1) {
            throw new IllegalArgumentException("antialiasLevel < 1");
        }

        this.antialiasLevel = antialiasLevel;
    }

    public void compute(Camera camera, RayTracer rt, BoundedRangeModel model, BufferedImage image)
    {
        if (image == null) {
            throw new IllegalArgumentException("null image");
        }

        if (model == null) {
            compute(camera, rt, image);
        }

        model.setMinimum(1);
        model.setMaximum(image.getWidth() * image.getHeight());
        model.setValue(1);

        int width = image.getWidth();
        int height = image.getHeight();

        double decalX = 1.0 / (antialiasLevel * width);
        double decalY = 1.0 / (antialiasLevel * height);

        for (int i = 0 ; i < width ; i++)
        {
            for (int j = 0 ; j < height ; j++)
            {
                double px = (0.5 * decalX) + (((double) i) / width);
                double py = (0.5 * decalY) + (((double) j) / height);

                RGB light = RGB.black;

                for (int kx = 0 ; kx < antialiasLevel ; kx++)
                {
                    for (int ky = 0 ; ky < antialiasLevel ; ky++)
                    {
                        Ray ray = camera.getRay(px + (kx * decalX),
                                                py + (ky * decalY));
                        light = RGB.sum(light, rt.getLight(ray));
                    }
                }

                light = RGB.product(light, 1.0 / (antialiasLevel * antialiasLevel));
                image.setRGB(i, j, light.getColor().getRGB());
                model.setValue(model.getValue() + 1);
            }
        }
    }
    public void compute(Camera camera, RayTracer rt, BufferedImage image)
    {
        if (image == null) {
            throw new IllegalArgumentException("null image");
        }

        int width = image.getWidth();
        int height = image.getHeight();

        double decalX = 1.0 / (antialiasLevel * width);
        double decalY = 1.0 / (antialiasLevel * height);

        for (int i = 0 ; i < width ; i++)
        {
            for (int j = 0 ; j < height ; j++)
            {
                double px = (0.5 * decalX) + (((double) i) / width);
                double py = (0.5 * decalY) + (((double) j) / height);

                RGB light = RGB.black;

                for (int kx = 0 ; kx < antialiasLevel ; kx++)
                {
                    for (int ky = 0 ; ky < antialiasLevel ; ky++)
                    {
                        Ray ray = camera.getRay(px + (kx * decalX),
                                                py + (ky * decalY));
                        light = RGB.sum(light, rt.getLight(ray));
                    }
                }

                light = RGB.product(light, 1.0 / (antialiasLevel * antialiasLevel));
                image.setRGB(i, j, light.getColor().getRGB());
            }
        }
    }
}


// =========================================
// File: /raja/renderer/StereoCamera.java
// =========================================

/* $Id: StereoCamera.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class StereoCamera extends Camera
{
    private Camera camera;
    private Vector3D trans;

    public StereoCamera(Camera camera, Vector3D trans)
    {
        super();
        this.camera = camera;
        this.trans = trans;
    }

    public StereoCamera(Point3D origin, Vector3D direction, double focal, double screenWidth, double screenHeight, double step, boolean cross)
    {
        this(new HorizontalCamera(origin, direction, focal, screenWidth, screenHeight),
             cross ? Vector3D.product(Vector3D.normalization(new Vector3D(direction.y, -direction.x, 0)), step / 2)
                   : Vector3D.product(Vector3D.normalization(new Vector3D(-direction.y, direction.x, 0)), step / 2));
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
        /* Initialisation */
	HashMap map = new HashMap();

	map.put("screenWidth",null);
	map.put("screenHeight",null);
	map.put("focal",null);
	map.put("direction",null);
	map.put("origin",null);
	map.put("pixelwidth",null);
	map.put("pixelheight",null);
        map.put("step",null);
        map.put("cross",null);

	/* Parsing */
	reader.readFields(map);

        return new StereoCamera((Point3D) map.get("origin"),
                                (Vector3D) map.get("direction"),
                                ((Number) map.get("focal")).doubleValue(),
                                ((Number) map.get("screenWidth")).doubleValue(),
                                ((Number) map.get("screenHeight")).doubleValue(),
                                ((Number) map.get("step")).doubleValue(),
                                false);
    }

    Ray getRay(double x, double y)
    {
        Ray r;

        if (x < 0.5) {
            r = camera.getRay(2*x, y);
            r.origin.translate(trans);
        }
        else {
            r = camera.getRay(2*x - 1, y);
            r.origin.translate(Vector3D.opposite(trans));
        }

        return r;
    }
    
    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		String STEREO_CAMERA_STR = "Constructor is: StereoCamera(Point3D origin, Vector3D direction, double focal, double screenWidth, double screenHeight, double step, boolean cross);\nExample:\n-5,0,0,  1,0,0,  1.8, 2, 1.5, 2.0, true\nEnter your values after three diyez symbol\n###\n";
		return STEREO_CAMERA_STR;
	}
	
    private String exampleString = "null";
    @Override
    public String toExampleString() {
      return this.exampleString;
    }
   
	@Override
    public Camera getInstance(String info)
	{
		this.exampleString = info;
		
		Camera xcam = new HorizontalCamera(
			new Point3D(-3.0, 0.0, 0.0),    // Point
			new Vector3D(1.0, 0.0, 0.0),   // X eksenine bak
			1.8, 2.0, 1.5                  // Focal, screen width/height
		);
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return xcam;
		
		str = str.substring(diyezIndex+3);		
		str = str.replaceAll(" ", "");
		str = str.replaceAll("\n", "");
		
		if (str.length () < 17) return xcam;
	
		String [] split = str.split (",");
		if (split == null) return xcam;
		if (split.length < 9) return xcam;
		
		try {
			double px = Double.parseDouble(split[0]);
			double py = Double.parseDouble(split[1]);
			double pz = Double.parseDouble(split[2]);
	    
			double dx = Double.parseDouble(split[3]);
			double dy = Double.parseDouble(split[4]);
			double dz = Double.parseDouble(split[5]);
	    
			double focal = Double.parseDouble(split[6]);
			double scrw = Double.parseDouble(split[7]);
			double scrh = Double.parseDouble(split[8]);
			
			double step = Double.parseDouble (split[9]);
			boolean cross = Boolean.parseBoolean (split[10]);
				
			xcam = new StereoCamera (
					new Point3D(px, py, pz), new Vector3D(dx, dy, dz), 
					focal, scrw, scrh, step, cross
			);
			return xcam;
		} catch (NumberFormatException nfe) {
			nfe.printStackTrace();
			return xcam;
		}
	}
	////////////////
}


// =========================================
// File: /raja/renderer/DiadicSampler.java
// =========================================

/* $Id: DiadicSampler.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.*;
import java.awt.image.BufferedImage;
import javax.swing.BoundedRangeModel;
import java.util.Vector;


public class DiadicSampler implements Sampler
{
    public void compute(Camera camera, RayTracer rt, BoundedRangeModel model, BufferedImage image)
    {
        if (image == null) {
            throw new IllegalArgumentException("null image");
        }

        if (model == null) {
            compute(camera, rt, image);
        }

        model.setMinimum(1);
        model.setMaximum(image.getWidth() * image.getHeight());
        model.setValue(0);

        int width = image.getWidth();
        int height = image.getHeight();

        int[] currentXpix = {0, width - 1};
        int[] currentYpix = {0, height - 1};

        computePixels(camera, rt, model, image, currentXpix, currentYpix, width, height);

        while(true)
        {
            int[] newXpix = holes(currentXpix);
            int[] newYpix = holes(currentYpix);

            if ((newXpix.length == 0) && (newYpix.length == 0)) {
                break;
            }

            computePixels(camera, rt, model, image, newXpix, newYpix, width, height);
            computePixels(camera, rt, model, image, currentXpix, newYpix, width, height);
            computePixels(camera, rt, model, image, newXpix, currentYpix, width, height);

            currentXpix = merge(currentXpix, newXpix);
            currentYpix = merge(currentYpix, newYpix);
        }
    }
    public void compute(Camera camera, RayTracer rt, BufferedImage image)
    {
        if (image == null) {
            throw new IllegalArgumentException("null image");
        }

        int width = image.getWidth();
        int height = image.getHeight();

        int[] currentXpix = {0, width - 1};
        int[] currentYpix = {0, height - 1};

        computePixels(camera, rt, image, currentXpix, currentYpix, width, height);

        while(true)
        {
            int[] newXpix = holes(currentXpix);
            int[] newYpix = holes(currentYpix);

            if ((newXpix.length == 0) && (newYpix.length == 0)) {
                break;
            }

            computePixels(camera, rt, image, newXpix, newYpix, width, height);
            computePixels(camera, rt, image, currentXpix, newYpix, width, height);
            computePixels(camera, rt, image, newXpix, currentYpix, width, height);

            currentXpix = merge(currentXpix, newXpix);
            currentYpix = merge(currentYpix, newYpix);
        }
    }
    private void computePixels(Camera camera, RayTracer rt, BoundedRangeModel model, BufferedImage image, int [] xPix, int [] yPix, int width, int height)
    {
        for(int k = 0 ; k < xPix.length ; k++)
        {
            for(int l = 0 ; l < yPix.length ; l++)
            {
                int i = xPix[k];
                int j = yPix[l];

                Ray ray = camera.getRay(((double) i + 0.5) / width,
                                        ((double) j + 0.5) / height);
                RGB light = rt.getLight(ray);
                image.setRGB(i, j, light.getColor().getRGB());
                model.setValue(model.getValue() + 1);
            }
        }
    }
    private void computePixels(Camera camera, RayTracer rt, BufferedImage image, int [] xPix, int [] yPix, int width, int height)
    {
        for(int k = 0 ; k < xPix.length ; k++)
        {
            for(int l = 0 ; l < yPix.length ; l++)
            {
                int i = xPix[k];
                int j = yPix[l];

                Ray ray = camera.getRay(((double) i + 0.5) / width,
                                        ((double) j + 0.5) / height);
                RGB light = rt.getLight(ray);
                image.setRGB(i, j, light.getColor().getRGB());
            }
        }
    }
    private int[] holes(int[] t)
    {
        Vector holes = new Vector();

        for(int i = 1 ; i < t.length ; i++)
        {
            if (t[i] > t[i-1] + 1) {
                holes.add(new Integer(t[i-1] + (t[i] - t[i-1]) / 2));
            }
        }

        int[] result = new int[holes.size()];

        for(int i = 0 ; i < result.length ; i++)
        {
            result[i] = ((Integer) holes.elementAt(i)).intValue();
        }

        return result;
    }
    private int[] merge(int[] t1, int[] t2)
    {
        int[] result = new int[t1.length + t2.length];

        int k1, k2, i;

        for(k1 = 0, k2 = 0, i = 0 ; (k1 < t1.length) && (k2 < t2.length) ; i++)
        {
            if (t1[k1] <= t2[k2]) {
                result[i] = t1[k1++];
            }
            else {
                result[i] = t2[k2++];
            }
        }

        if (k1 < t1.length) {
            for(; i < result.length ; k1++, i++)
            {
                result[i] = t1[k1];
            }
        }
        else if (k2 < t2.length) {
            for(; i < result.length ; k2++, i++)
            {
                result[i] = t2[k2];
            }
        }

        return result;
    }
}


// =========================================
// File: /raja/renderer/RayTracer.java
// =========================================

/* $Id: RayTracer.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.*;


public interface RayTracer
{
    public RGB getLight(Ray ray);
}


// =========================================
// File: /raja/renderer/BasicSampler.java
// =========================================

/* $Id: BasicSampler.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.*;
import java.awt.image.BufferedImage;
import javax.swing.BoundedRangeModel;


public class BasicSampler implements Sampler
{
    public void compute(Camera camera, RayTracer rt, BoundedRangeModel model, BufferedImage image)
    {
        if (image == null) {
            throw new IllegalArgumentException("null image");
        }

        if (model == null) {
            compute(camera, rt, image);
        }

        model.setMinimum(1);
        model.setMaximum(image.getWidth() * image.getHeight());
        model.setValue(1);

        int width = image.getWidth();
        int height = image.getHeight();

        for (int i = 0 ; i < width ; i++)
        {
            for (int j = 0 ; j < height ; j++)
            {
                Ray ray = camera.getRay(((double) i + 0.5) / width,
                                        ((double) j + 0.5) / height);
                RGB light = rt.getLight(ray);
                image.setRGB(i, j, light.getColor().getRGB());
                model.setValue(model.getValue() + 1);
            }
        }
    }
    public void compute(Camera camera, RayTracer rt, BufferedImage image)
    {
        if (image == null) {
            throw new IllegalArgumentException("null image");
        }

        int width = image.getWidth();
        int height = image.getHeight();

        for (int i = 0 ; i < width ; i++)
        {
            for (int j = 0 ; j < height ; j++)
            {
                Ray ray = camera.getRay(((double) i + 0.5) / width,
                                        ((double) j + 0.5) / height);
                RGB light = rt.getLight(ray);
                image.setRGB(i, j, light.getColor().getRGB());
            }
        }
    }
}


// =========================================
// File: /raja/renderer/BasicRenderer.java
// =========================================

/* $Id: BasicRenderer.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import java.awt.image.BufferedImage;
import javax.swing.BoundedRangeModel;
import javax.swing.DefaultBoundedRangeModel;


public class BasicRenderer implements Renderer
{
    private Camera camera;
    private RayTracer rt;
    private Sampler sampler;
    private BufferedImage image;
    private BoundedRangeModel model;

    public BasicRenderer(Camera camera, Resolution res, RayTracer rt, Sampler sampler, int imageType)
    {
        this.camera = camera;
        this.rt = rt;
        this.sampler = sampler;

        image = new BufferedImage(res.width, res.height, imageType);
        model = new DefaultBoundedRangeModel();
    }
    public BufferedImage getImage()
    {
        return image;
    }
    public BoundedRangeModel getModel()
    {
        return model;
    }
    public void run()
    {
        sampler.compute(camera, rt, model, image);
    }
}


// =========================================
// File: /raja/renderer/Scene.java
// =========================================

/* $Id: Scene.java,v 1.2 2001/02/25 01:25:18 gregoire Exp $
 * Copyright (C) 1999-2001 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.io.*;

import java.util.HashMap;
import java.util.Iterator;


public class Scene implements java.io.Serializable, Writable
{
    private World world;
    private Camera camera;

    public Scene(World world, Camera camera)
    {
        this.world = world;
        this.camera = camera;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("world", null);
	map.put("camera", null);

	/* Parsing */
	reader.readFields(map);

	return new Scene((World) map.get("world"),
                         (Camera) map.get("camera"));
    }

    public World getWorld()
    {
        return world;
    }
    public Camera getCamera()
    {
        return camera;
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "world", world },
                              { "camera", camera } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/renderer/HorizontalCamera.java
// =========================================

/* $Id: HorizontalCamera.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.renderer;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class HorizontalCamera extends Camera implements Writable
{
    private double screenWidth, screenHeight;
    private Vector3D direction;   // vecteur normé
    private double focal;
    private Point3D origin, screenTopLeft, screenTopRight, screenBottomLeft;

    public HorizontalCamera(Point3D origin, Vector3D direction, double focal, double screenWidth, double screenHeight)
    {
        super();
        this.origin = origin;
        this.direction = Vector3D.normalization(direction);
        this.focal = focal;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;


        // Computation of the screen's corners

        Vector3D d = this.direction;
        Point3D screenCenter = new Point3D(origin);
        screenCenter.translate(Vector3D.product(d, focal));

        Vector3D u = Vector3D.normalization(new Vector3D(-d.y, d.x, 0));
        Vector3D v = Vector3D.crossProduct(d, u);
        Vector3D uc = Vector3D.product(u, screenWidth / 2);
        Vector3D vc = Vector3D.product(v, screenHeight / 2);

        screenTopLeft = new Point3D(screenCenter, Vector3D.sum(uc, vc));
        screenTopRight = new Point3D(screenCenter, Vector3D.sum(Vector3D.opposite(uc), vc));
        screenBottomLeft = new Point3D(screenCenter, Vector3D.sum(uc, Vector3D.opposite(vc)));
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("screenWidth",null);
	map.put("screenHeight",null);
	map.put("focal",null);
	map.put("direction",null);
	map.put("origin",null);
	map.put("pixelWidth",null);
	map.put("pixelHeight",null);

	/* Parsing */
	reader.readFields(map);
       
	return new HorizontalCamera((Point3D) map.get("origin"),
                                    (Vector3D) map.get("direction"),
                                    ((Number) map.get("focal")).doubleValue(),
                                    ((Number) map.get("screenWidth")).doubleValue(),
                                    ((Number) map.get("screenHeight")).doubleValue());
    }
	
	// ADDED by Murat Inan
	@Override
	public String getUsageInformation()
	{
		String HORIZONTAL_CAMERA_STR = "Constructor is: HorizontalCamera(Point3D origin, Vector3D direction, double focal, double screenWidth, double screenHeight);\nExample:\n-5,0,0,  1,0,0,  1.8,  2,  1.5\nEnter your values after three diyez symbol\n###\n";
		return HORIZONTAL_CAMERA_STR;
	}
	
	private String exampleString = "null";
    @Override
    public String toExampleString() {
      return this.exampleString;
    }
   
	@Override
    public Camera getInstance(String info)
	{
		this.exampleString = info;
		
		Camera xcam = new HorizontalCamera(
			new Point3D(-3.0, 0.0, 0.0),    // Point
			new Vector3D(1.0, 0.0, 0.0),   // X eksenine bak
			1.8, 2.0, 1.5                  // Focal, screen width/height
		);
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return xcam;
		
		str = str.substring(diyezIndex+3);		
		str = str.replaceAll(" ", "");
		str = str.replaceAll("\n", "");
		
		if (str.length () < 17) return xcam;
	
		String [] split = str.split (",");
		if (split == null) return xcam;
		if (split.length < 9) return xcam;
		
		try {
			double px = Double.parseDouble(split[0]);
			double py = Double.parseDouble(split[1]);
			double pz = Double.parseDouble(split[2]);
	    
			double dx = Double.parseDouble(split[3]);
			double dy = Double.parseDouble(split[4]);
			double dz = Double.parseDouble(split[5]);
	    
			double focal = Double.parseDouble(split[6]);
			double scrw = Double.parseDouble(split[7]);
			double scrh = Double.parseDouble(split[8]);
			
			xcam = new HorizontalCamera (
				new Point3D(px, py, pz), new Vector3D(dx, dy, dz), focal, scrw, scrh
			);
			return xcam;
		} catch (NumberFormatException nfe) {
			nfe.printStackTrace();
			return xcam;
		}
	}
	////////////////
	
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "origin", origin },
                              { "direction", direction },
                              { "focal", new Double(focal) },
                              { "screenWidth", new Double(screenWidth) },
                              { "screenHeight", new Double(screenHeight) } };
        writer.writeFields(fields);
    }
	
	/**
	// ADDED by Murat Inan
	Ray getRay(double x, double y)
	{
		Point3D pixel = new Point3D(
			screenTopLeft.x + (x * (screenTopRight.x - screenTopLeft.x)) + (y * (screenBottomLeft.x - screenTopLeft.x)),
			screenTopLeft.y + (x * (screenTopRight.y - screenTopLeft.y)) + (y * (screenBottomLeft.y - screenTopLeft.y)),
			screenTopLeft.z + (x * (screenTopRight.z - screenTopLeft.z)) + (y * (screenBottomLeft.z - screenTopLeft.z))
		);

		Vector3D direct = new Vector3D(origin, pixel);
    
		// Ray kamera origin'den başlamalı, pixel'e doğru gitmeli
		return new Ray(origin, direct);  // Correct
	}
	*/
	
    Ray getRay(double x, double y)
    {
        Point3D pixel = new Point3D(screenTopLeft.x + (x * (screenTopRight.x - screenTopLeft.x)) + (y * (screenBottomLeft.x - screenTopLeft.x)),
                                    screenTopLeft.y + (x * (screenTopRight.y - screenTopLeft.y)) + (y * (screenBottomLeft.y - screenTopLeft.y)),
                                    screenTopLeft.z + (x * (screenTopRight.z - screenTopLeft.z)) + (y * (screenBottomLeft.z - screenTopLeft.z)));

        Vector3D direct = new Vector3D(origin, pixel);
        return new Ray(pixel, direct);
    }

}


// =========================================
// File: /raja/Point2D.java
// =========================================

// Murat Inan
package raja;

public class Point2D implements java.io.Serializable {

    public double u, v;
    
    public Point2D(double u, double v) { 
		this.u = u; this.v = v; 
    }
    
}


// =========================================
// File: /raja/material/PrismTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class PrismTexture implements Texture, java.io.Serializable, Writable {
    private double time = 0.0;

    public PrismTexture() {}

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double r = (Math.sin(time + p.x * 5) + 1) * 0.5;
        double g = (Math.sin(time + p.y * 5 + 2) + 1) * 0.5;
        double b = (Math.sin(time + p.z * 5 + 4) + 1) * 0.5;
        
        RGB prismColor = new RGB(r, g, b);

        return new LocalTexture(
            prismColor,
            new RGB(r * 0.8, g * 0.8, b * 0.8),
            new RGB(0.0, 0.0, 0.0),
            300, 50
        );
    }
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: PrismTexture();\nPress Set button please.";
    }

    private String exampleString = "null";
    
    @Override
    public String toExampleString() {
        return this.exampleString;
    }

    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        return new PrismTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new PrismTexture();
    }
}


// =========================================
// File: /raja/material/CheckerboardTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class CheckerboardTexture implements Texture, java.io.Serializable, Writable
{
    private RGB kd1, kd2, kr, kt;
    private int ns, nt;
    private double step, x0, y0, z0;
    
    public CheckerboardTexture(RGB kd1, RGB kd2, RGB kr, RGB kt, 
                               int ns, int nt, 
                               double step, double x0, double y0, double z0)
    {
        this.kd1 = kd1;
        this.kd2 = kd2;
        this.kr = kr;
        this.kt = kt;
        this.ns = ns;
        this.nt = nt;
        this.step = step;
        this.x0 = x0;
        this.y0 = y0;
        this.z0 = z0;
    }

    /**
     * Builds the object from ObjectReader.
     */
    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        /* Initialisation */
        HashMap map = new HashMap();

        map.put("kdUn", null);
        map.put("kdDeux", null);
        map.put("kr", null);
        map.put("kt", null);
        map.put("ns", null);
        map.put("nt", null);
        map.put("step", null);
        map.put("x", null);
        map.put("y", null);
        map.put("z", null);

        /* Parsing */
        reader.readFields(map);

        return new CheckerboardTexture(
            (RGB) map.get("kdUn"),
            (RGB) map.get("kdDeux"),
            (RGB) map.get("kr"),
            (RGB) map.get("kt"),
            ((Number) map.get("ns")).intValue(),
            ((Number) map.get("nt")).intValue(),
            ((Number) map.get("step")).doubleValue(),
            ((Number) map.get("x")).doubleValue(),
            ((Number) map.get("y")).doubleValue(),
            ((Number) map.get("z")).doubleValue()
        );
    }
	
	@Override
    public LocalTexture getLocalTexture(Point3D p)
    {
            // 3D checkerboard pattern - works on all surfaces including boxes
            double i = Math.floor((p.x - x0) / step);
            double j = Math.floor((p.y - y0) / step);
            double k = Math.floor((p.z - z0) / step);

            if ((i + j + k) % 2 == 0) {
                return new LocalTexture(kd1, kr, kt, ns, nt);
            } else {
                return new LocalTexture(kd2, kr, kt, ns, nt);
            }
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		String CHECKERBOARD_STR="Constructor is: CheckerboardTexture(RGB kd1, RGB kd2, RGB kr, RGB kt, int ns, int nt, double step, double x0, double y0, double z0);\nExample:\n1.0,1.0,1.0,  0.0,0.0,0.0,  0.0,1.0,0.0,  0.5,0.5,0.5,  100, 10, 4.5, 0.0, 0.0, 0.0\nEnter your values after three diyez symbol\n###\n";
		return CHECKERBOARD_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return texture;

			//1.0,1.0,1.0,  0.0,0.0,0.0,  0.0,1.0,0.0,  0.5,0.5,0.5,  
			//100, 10, 
			//0.5, 0.0, 0.0, 0.0, true
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double c3r = Double.parseDouble(split[6]);
				double c3g = Double.parseDouble(split[7]);
				double c3b = Double.parseDouble(split[8]);
				
				double c4r = Double.parseDouble(split[9]);
				double c4g = Double.parseDouble(split[10]);
				double c4b = Double.parseDouble(split[11]);
				
				int ns = Integer.parseInt(split[12]);
				int nt = Integer.parseInt(split[13]);
				
				double step = Double.parseDouble(split[14]);
				double ud = Double.parseDouble(split[15]);
				double vd = Double.parseDouble(split[16]);
				double zd = Double.parseDouble(split[17]);
												
				texture = new CheckerboardTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					new RGB(c3r, c3g, c3b),
					new RGB(c4r, c4g, c4b),
					ns, nt, step, ud, vd, zd);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	   
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { 
            { "kdUn", kd1 },
            { "kdDeux", kd2 },
            { "kr", kr },
            { "kt", kt },
            { "ns", new Integer(ns) },
            { "nt", new Integer(nt) },
            { "step", new Double(step) },
            { "x", new Double(x0) },
            { "y", new Double(y0) },
            { "z", new Double(z0) },
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/material/StripesTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class StripesTexture implements Texture, java.io.Serializable, Writable {
    private RGB stripeColor1;
    private RGB stripeColor2;
    private boolean horizontal;
    private double stripeWidth;
    
    // Default constructor
    public StripesTexture() {
        this(new RGB(1, 1, 1), new RGB(0, 0, 0), true, 0.2);
    }
    
    // Custom constructor
    public StripesTexture(RGB stripeColor1, RGB stripeColor2, boolean horizontal, double stripeWidth) {
        this.stripeColor1 = stripeColor1;
        this.stripeColor2 = stripeColor2;
        this.horizontal = horizontal;
        this.stripeWidth = stripeWidth;
    }
    
    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double coord = horizontal ? p.y : p.x;
        double position = Math.abs(coord % (stripeWidth * 2));
        RGB surfaceColor = position < stripeWidth ? stripeColor1 : stripeColor2;
        
        return new LocalTexture(
            surfaceColor,
            surfaceColor.multiply(0.4),
            new RGB(0.2, 0.2, 0.2),
            10,
            1
        );
    }
    
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("stripeColor1", new RGB(1,1,1));
        map.put("stripeColor2", new RGB(0,0,0));
        map.put("horizontal", true);
        map.put("stripeWidth", 0.2);
        
        reader.readFields(map);
        
        return new StripesTexture(
            (RGB) map.get("stripeColor1"),
            (RGB) map.get("stripeColor2"),
            (Boolean) map.get("horizontal"),
            ((Number) map.get("stripeWidth")).doubleValue()
        );
    }
    
    @Override
    public String getUsageInformation() {
        String STRIPES_STR = "Constructor: StripesTexture(RGB stripeColor1, RGB stripeColor2, boolean horizontal, double stripeWidth)\n" +
                            "Examples:\n" +
                            "-1                              # Black-white horizontal stripes\n" +
                            "1,0,0,  0,0,1,  true,   0.3     # Red-blue horizontal stripes\n" +
                            "0,1,0,  1,0,1,  false,  0.15    # Green-purple vertical stripes\n" +
                            "Enter values after ###\n###\n";
        return STRIPES_STR;
    }
    
    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        Texture texture = null;
        String str = info.trim();
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return texture;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "").replaceAll(" ", "");
        
        if (str.equals("-1")) return new StripesTexture();
        
        String[] split = str.split(",");
        if (split == null || split.length != 8) return texture;
        
        try {
            double r1 = Double.parseDouble(split[0]);
            double g1 = Double.parseDouble(split[1]);
            double b1 = Double.parseDouble(split[2]);
            double r2 = Double.parseDouble(split[3]);
            double g2 = Double.parseDouble(split[4]);
            double b2 = Double.parseDouble(split[5]);
            boolean horiz = Boolean.parseBoolean(split[6]);
            double width = Double.parseDouble(split[7]);
            
            texture = new StripesTexture(new RGB(r1, g1, b1), new RGB(r2, g2, b2), horiz, width);
            return texture;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }
    
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"stripeColor1", stripeColor1},
            {"stripeColor2", stripeColor2},
            {"horizontal", horizontal},
            {"stripeWidth", stripeWidth}
        };
        writer.writeFields(fields);
    }
    
    // Getters
    public RGB getStripeColor1() { return stripeColor1; }
    public RGB getStripeColor2() { return stripeColor2; }
    public boolean isHorizontal() { return horizontal; }
    public double getStripeWidth() { return stripeWidth; }
}


// =========================================
// File: /raja/material/AuroraCeramicTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class AuroraCeramicTexture implements Texture, java.io.Serializable, Writable {
    private RGB baseColor = new RGB(0.96, 0.96, 0.86);    // Açık bej seramik
    private RGB auroraColor = new RGB(0.0, 1.0, 0.5);     // Yeşil aurora
    private double auroraIntensity = 0.45;
    private double time = 0.0;

    public AuroraCeramicTexture() {}

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double x = p.x * 7.0;
        double y = p.y * 7.0;
        double z = p.z * 7.0;
        
        // Aurora akış pattern'leri
        double flow1 = Math.sin(x * 1.2 + Math.cos(y * 0.8) + Math.sin(z * 1.5));
        double flow2 = Math.cos(x * 0.7 + Math.sin(y * 1.3) + Math.cos(z * 0.9));
        double flow3 = Math.sin(x * 2.1 + y * 1.7 + z * 0.5);
        
        double auroraPattern = (flow1 * 0.4 + flow2 * 0.3 + flow3 * 0.3);
        double normalizedPattern = (auroraPattern + 1.0) * 0.5;
        
        // Zaman efekti
        double timeEffect = Math.sin(time * 2.0 + y * 0.5) * 0.2 + 0.8;
        
        RGB surfaceColor;
        if (normalizedPattern < auroraIntensity) {
            // Aurora glow efekti
            double intensity = normalizedPattern / auroraIntensity * timeEffect;
            surfaceColor = createAuroraGlow(baseColor, auroraColor, intensity);
        } else {
            // Seramik base with subtle glow
            double intensity = (normalizedPattern - auroraIntensity) / (1.0 - auroraIntensity);
            surfaceColor = addCeramicGlow(baseColor, auroraColor, intensity * 0.3 * timeEffect);
        }

        return new LocalTexture(
            surfaceColor,
            new RGB(0.25, 0.25, 0.25), // Orta reflection
            new RGB(0.0, 0.0, 0.0),    // Işık yok
            55, 10              // Seramik parlaklık
        );
    }
    
    private RGB createAuroraGlow(RGB base, RGB glow, double intensity) {
        return new RGB(
            base.getR() * (1 - intensity) + glow.getR() * intensity + glow.getR() * intensity * 0.5,
            base.getG() * (1 - intensity) + glow.getG() * intensity + glow.getG() * intensity * 0.5,
            base.getB() * (1 - intensity) + glow.getB() * intensity + glow.getB() * intensity * 0.5
        );
    }
    
    private RGB addCeramicGlow(RGB base, RGB glow, double intensity) {
        return new RGB(
            Math.min(1.0, base.getR() + glow.getR() * intensity * 0.3),
            Math.min(1.0, base.getG() + glow.getG() * intensity * 0.4),
            Math.min(1.0, base.getB() + glow.getB() * intensity * 0.2)
        );
    }
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: AuroraCeramicTexture();\nPress Set button please.";
    }

    @Override
    public String toExampleString() {
        return "AuroraCeramicTexture";
    }

    @Override
    public Texture getInstance(String info) {
        return new AuroraCeramicTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseColor", baseColor},
            {"auroraColor", auroraColor},
            {"auroraIntensity", Double.valueOf(auroraIntensity)},
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new AuroraCeramicTexture();
    }
}


// =========================================
// File: /raja/material/XRayTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

public class XRayTexture implements Texture, java.io.Serializable, Writable {
    private RGB baseColor;
    private double transparency;
    private int reflectivity;
    private int plane; // 0: XY, 1: XZ, 2: YZ (opsiyonel, ama tutarlılık için)

    public XRayTexture() {
        // Varsayılan: açık mavi, yarı şeffaf
        this(new RGB(0.15, 0.6, 1.0), 0.92, 5);
    }

    public XRayTexture(RGB baseColor, double transparency, int reflectivity) {
        this(baseColor, transparency, reflectivity, 0);
    }

    public XRayTexture(RGB baseColor, double transparency, int reflectivity, int plane) {
        this.baseColor = baseColor;
        this.transparency = Math.min(1.0, Math.max(0.0, transparency));
        this.reflectivity = reflectivity;
        this.plane = plane;
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // X-ray efekti: nesnenin merkezine olan mesafeye göre solma
        double depth = p.length(); // orijine olan Öklid mesafesi
        double intensity = Math.exp(-depth * 0.5);

        // Sadece mavi ve yeşil kanalları solmaya bırak (tipik X-ray estetiği)
        RGB color = new RGB(
            baseColor.getR(),                    // Kırmızı sabit (genelde düşük)
            baseColor.getG() * intensity,        // Yeşil soluyor
            baseColor.getB() * intensity         // Mavi soluyor
        );

        // Ambient = diffuse = color (basit, fakat etkili)
        // Specular çok düşük — X-ray parlak değil
        RGB ambient = color.multiply(0.3);
        RGB diffuse = color;
        RGB specular = new RGB(0.1, 0.1, 0.1); // çok hafif

        int shininess = 10; // düşük parlaklık

        return new LocalTexture(
            diffuse,
            ambient,
            specular,
            shininess,
            reflectivity
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		String XRAY_STR="Constructor is: XRayTexture(RGB baseColor, double transparency, int reflectivity, int plane);\nExample:\n1.0,0.3,0.1,  0.85,  3,  0|1|2(xy/xz/yz)\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return XRAY_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new XRayTexture();

		String [] split = str.split (",");
		if (split == null) return texture;
		
			//XRayTexture(RGB baseColor, double transparency, int reflectivity, int plane)
			//1.0,0.3,0.1,  0.85,  3,  0
			try {
				double r = Double.parseDouble(split[0]);
				double g = Double.parseDouble(split[1]);
				double b = Double.parseDouble(split[2]);
				
				double tr = Double.parseDouble(split[3]);
				
				int rf = Integer.parseInt(split[4]);
				int pl = Integer.parseInt(split[5]);
				
				texture = new XRayTexture(new RGB(r, g, b), tr, rf, pl);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////

    // --- IO Desteği ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("baseColor", null);
        map.put("transparency", 0.92);
        map.put("reflectivity", 0.05);
        map.put("plane", 0);

        reader.readFields(map);

        return new XRayTexture(
            (RGB) map.get("baseColor"),
            ((Number) map.get("transparency")).doubleValue(),
            ((Number) map.get("reflectivity")).intValue(),
            ((Number) map.get("plane")).intValue()
        );
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseColor", baseColor},
            {"transparency", transparency},
            {"reflectivity", reflectivity},
            {"plane", plane}
        };
        writer.writeFields(fields);
    }

    // --- Getter'lar ---
    public RGB getBaseColor() { return baseColor; }
    public double getTransparency() { return transparency; }
    public double getReflectivity() { return reflectivity; }
    public int getPlane() { return plane; }
    
}

/**
// Standart X-ray görünümü
Texture xray = new XRayTexture();

// Özel renkli X-ray (örneğin: kızılötesi tarzı)
Texture thermalXray = new XRayTexture(
    new RGB(1.0, 0.3, 0.1), // Turuncu-kırmızı
    0.85,                   // Şeffaflık
    3,                      // Çok düşük yansıma
    0                       // XY düzlemi
);

// Duvar içi boru taraması gibi
Texture pipeScan = new XRayTexture(
    new RGB(0.0, 0.8, 1.0),
    0.9,
    4,
    1 // XZ düzlemi
);
*/


// =========================================
// File: /raja/material/HologramTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class HologramTexture implements Texture, java.io.Serializable, Writable {
    private RGB baseColor = new RGB(0.3, 0.8, 1.0);
    private double time = 0.0;

    public HologramTexture() {}

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double pulse = (Math.sin(time * 5) + 1) * 0.3;
        RGB emissive = new RGB(baseColor.getR() + pulse, baseColor.getG() + pulse, baseColor.getB());
        
        return new LocalTexture(
			new RGB(0.1, 0.1, 0.1),  // kd
			new RGB(0.0, 0.0, 0.0),  // kr  
			emissive,                 // kt
			100,                      // ns
			200                       // nt
		);
    }
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: HologramTexture();\nPress Set button please.";
    }

    private String exampleString = "null";
    
    @Override
    public String toExampleString() {
        return this.exampleString;
    }

    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        return new HologramTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseColor", baseColor},
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new HologramTexture();
    }
}


// =========================================
// File: /raja/material/ImageSpheringTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import javax.imageio.ImageIO;

public class ImageSpheringTexture implements Texture, java.io.Serializable, Writable {
    private BufferedImage texture;
    private String imagePath;
    private RGB kd, kr, kt;
    private int ns, nt;
    private double reflectivity;
    private double uOffset = 0.0;
    private double vOffset = 0.0;
    private double uScale = 1.0;
    private double vScale = 1.0;
    
    // EKLENEN SATIRLAR
    private transient Point3D sphereWorldCenter;
    private transient Matrix4 inverseTransform;

    public ImageSpheringTexture(BufferedImage texture, RGB kd, RGB kr, RGB kt, 
                               int ns, int nt, double reflectivity,
                               double uOffset, double vOffset, double uScale, double vScale) {
        this.texture = texture;
        this.kd = kd;
        this.kr = kr;
        this.kt = kt;
        this.ns = ns;
        this.nt = nt;
        this.reflectivity = reflectivity;
        this.uOffset = uOffset;
        this.vOffset = vOffset;
        this.uScale = uScale;
        this.vScale = vScale;
    }

    public ImageSpheringTexture(BufferedImage texture) {
        this(texture, new RGB(0.5, 0.5, 0.5), new RGB(0.2, 0.2, 0.2), 
             new RGB(0.0, 0.0, 0.0), 50, 10, 0.1, 0.0, 0.0, 1.0, 1.0);
    }

    // EKLENEN METOD
    public void setSphereInfo(Point3D worldCenter, Matrix4 inverseTransform) {
        this.sphereWorldCenter = worldCenter;
        this.inverseTransform = inverseTransform;
    }

@Override
public LocalTexture getLocalTexture(Point3D p) {
    if (texture == null) {
        return new LocalTexture(kd, kr, kt, ns, nt);
    }

    // EKLENEN KOD: World → Local dönüşüm
    Point3D localPoint;
    if (inverseTransform != null) {
        localPoint = inverseTransform.transformPoint(p);
    } else {
        localPoint = p;
    }

    // Normalize
    double len = Math.sqrt(localPoint.x * localPoint.x + localPoint.y * localPoint.y + localPoint.z * localPoint.z);
    double nx = localPoint.x / len;
    double ny = localPoint.y / len;
    double nz = localPoint.z / len;

    // DÜZ PROJEKSİYON - Y ve Z koordinatları (90 derece düzeltme)
    double u = 0.5 - (ny * 0.5);  // Y yukarı-aşağı → sağ-sol
    double v = 0.5 - (nz * 0.5);  // Z sağ-sol → yukarı-aşağı

    // Offset ve scale
    u = (u + uOffset) * uScale;
    v = (v + vOffset) * vScale;

    // Sınır kontrolü
    u = Math.max(0.0, Math.min(1.0, u));
    v = Math.max(0.0, Math.min(1.0, v));

    // Texture pixel
    int x = (int) (u * (texture.getWidth() - 1));
    int y = (int) (v * (texture.getHeight() - 1));

    x = Math.max(0, Math.min(texture.getWidth() - 1, x));
    y = Math.max(0, Math.min(texture.getHeight() - 1, y));

    int argb = texture.getRGB(x, y);
    int alpha = (argb >> 24) & 0xFF;

    // DEĞİŞEN KOD: KTV transparency kontrolü
    if (alpha < 5) {
        // KTV değerine göre transparency ayarla
        // KTV = 1.0 → tam transparent, KTV = 0.1 → hafif transparent
        RGB transparentKt = new RGB(kt.getR(), kt.getG(), kt.getB()); // Orijinal KTV değerini kullan
        
        return new LocalTexture(
            new RGB(0.0, 0.0, 0.0),     // diffuse siyah
            new RGB(0.0, 0.0, 0.0),     // reflection yok
            transparentKt,               // KTV değeri transparency'yi kontrol eder
            5, 1
        );
    }

    int red = (argb >> 16) & 0xFF;
    int green = (argb >> 8) & 0xFF;
    int blue = argb & 0xFF;

    RGB textureColor = new RGB(red / 255.0, green / 255.0, blue / 255.0);
    RGB finalKr = kr.multiply(reflectivity);
    
    return new LocalTexture(textureColor, finalKr, kt, ns, nt);
}

    public void setImagePath(String path) {
        this.imagePath = path;
    }

    public String getImagePath() {
        return this.imagePath;
    }

    public void setTexture(BufferedImage texture) {
        this.texture = texture;
    }

    // Offset ve Scale setter'ları
    public void setOffset(double uOffset, double vOffset) {
        this.uOffset = uOffset;
        this.vOffset = vOffset;
    }

    public void setScale(double uScale, double vScale) {
        this.uScale = uScale;
        this.vScale = vScale;
    }

    // --- IO Support ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("kd", null);
        map.put("kr", null);
        map.put("kt", null);
        map.put("ns", null);
        map.put("nt", null);
        map.put("reflectivity", 0.1);
        map.put("uOffset", 0.0);
        map.put("vOffset", 0.0);
        map.put("uScale", 1.0);
        map.put("vScale", 1.0);

        reader.readFields(map);

        return new ImageSpheringTexture(
            null,
            (RGB) map.get("kd"),
            (RGB) map.get("kr"),
            (RGB) map.get("kt"),
            ((Number) map.get("ns")).intValue(),
            ((Number) map.get("nt")).intValue(),
            ((Number) map.get("reflectivity")).doubleValue(),
            ((Number) map.get("uOffset")).doubleValue(),
            ((Number) map.get("vOffset")).doubleValue(),
            ((Number) map.get("uScale")).doubleValue(),
            ((Number) map.get("vScale")).doubleValue()
        );
    }

    @Override
    public String getUsageInformation() {
        return "Constructor is: ImageSpheringTexture(BufferedImage texture, RGB kd, RGB kr, RGB kt, int ns, int nt, double reflectivity, double uOffset, double vOffset, double uScale, double vScale);\n" +
               "Example:\n\"textures/sun.png\", 0.5,0.5,0.5, 0.2,0.2,0.2, 0.0,0.0,0.0, 50, 10, 0.1, 0.0, 0.0, 1.0, 1.0\n" +
               "RGB kt value:\n" +
               "  - 1.0,1.0,1.0 --> full transparent background\n" +
               "  - 0.0,0.0,0.0 --> opaque background\n" +
               "Enter your values after three diyez symbol\n###\n";
    }

    private String exampleString = "null";
    
    @Override
    public String toExampleString() {
        return this.exampleString;
    }

    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        String str = info.trim();
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return null;
        
        str = str.substring(diyezIndex + 3);
        str = str.replaceAll("\n", "").replaceAll(" ", "");
        
        String[] split = str.split(",");
        if (split == null) return null;

        try {
            String imagePath = split[0].replaceAll("\"", "");
            BufferedImage img = ImageIO.read(new File(imagePath));
            
            double kdR = Double.parseDouble(split[1]);
            double kdG = Double.parseDouble(split[2]);
            double kdB = Double.parseDouble(split[3]);
            
            double krR = Double.parseDouble(split[4]);
            double krG = Double.parseDouble(split[5]);
            double krB = Double.parseDouble(split[6]);
            
            double ktR = Double.parseDouble(split[7]);
            double ktG = Double.parseDouble(split[8]);
            double ktB = Double.parseDouble(split[9]);
            
            int ns = Integer.parseInt(split[10]);
            int nt = Integer.parseInt(split[11]);
            double reflectivity = Double.parseDouble(split[12]);
            double uOffset = Double.parseDouble(split[13]);
            double vOffset = Double.parseDouble(split[14]);
            double uScale = Double.parseDouble(split[15]);
            double vScale = Double.parseDouble(split[16]);

            ImageSpheringTexture texture = new ImageSpheringTexture(
                img, new RGB(kdR, kdG, kdB), new RGB(krR, krG, krB),
                new RGB(ktR, ktG, ktB), ns, nt, reflectivity,
                uOffset, vOffset, uScale, vScale
            );
            texture.setImagePath(imagePath);
            
            return texture;
            
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        writer.write("// ImageSpheringTexture Path: " + imagePath + "\n");
        
        Object[][] fields = {
            {"kd", kd},
            {"kr", kr},
            {"kt", kt},
            {"ns", Integer.valueOf(ns)},
            {"nt", Integer.valueOf(nt)},
            {"reflectivity", Double.valueOf(reflectivity)},
            {"uOffset", Double.valueOf(uOffset)},
            {"vOffset", Double.valueOf(vOffset)},
            {"uScale", Double.valueOf(uScale)},
            {"vScale", Double.valueOf(vScale)}
        };
        writer.writeFields(fields);
    }
    
}

/**
// Dünya haritası için
Texture earth = new ImageSpheringTexture(
    earthImage, 
    new RGB(0.5, 0.5, 0.5), // diffuse
    new RGB(0.3, 0.3, 0.3), // reflection  
    new RGB(0.0, 0.0, 0.0), // transparency (KTV = 0,0,0 → opak background)
    100, 10, 0.2,            // shininess, transparency, reflectivity
    0.0, 0.0,
    1.0, 1.0
);

// Transparent background için
Texture transparentSphere = new ImageSpheringTexture(
    transparentImage,
    new RGB(0.5, 0.5, 0.5), // diffuse
    new RGB(0.3, 0.3, 0.3), // reflection
    new RGB(1.0, 1.0, 1.0), // KTV = 1,1,1 → tam transparent background
    100, 10, 0.2,
    0.0, 0.0,
    1.0, 1.0
);

// Hafif transparent background için  
Texture semiTransparentSphere = new ImageSpheringTexture(
    semiTransparentImage,
    new RGB(0.5, 0.5, 0.5), // diffuse
    new RGB(0.3, 0.3, 0.3), // reflection
    new RGB(0.1, 0.1, 0.1), // KTV = 0.1,0.1,0.1 → hafif transparent background
    100, 10, 0.2,
    0.0, 0.0,
    1.0, 1.0
);
*/


// =========================================
// File: /raja/material/PlasticTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class PlasticTexture implements Texture, java.io.Serializable, Writable {
    private RGB plasticColor;
    private double shininess;
    private double glossiness;
    
    // Default constructor
    public PlasticTexture() {
        this(new RGB(0.8, 0.8, 0.8), 50.0, 0.3);
    }
    
    // Custom constructor
    public PlasticTexture(RGB plasticColor, double shininess, double glossiness) {
        this.plasticColor = plasticColor;
        this.shininess = shininess;
        this.glossiness = glossiness;
    }
    
    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Simple plastic material with specular highlights
        return new LocalTexture(
            plasticColor,
            plasticColor.multiply(0.3),
            new RGB(glossiness, glossiness, glossiness),
            (int) shininess,
            1
        );
    }
    
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("plasticColor", new RGB(0.8, 0.8, 0.8));
        map.put("shininess", 50.0);
        map.put("glossiness", 0.3);
        
        reader.readFields(map);
        
        return new PlasticTexture(
            (RGB) map.get("plasticColor"),
            ((Number) map.get("shininess")).doubleValue(),
            ((Number) map.get("glossiness")).doubleValue()
        );
    }
    
    @Override
    public String getUsageInformation() {
        String PLASTIC_STR = "Constructor: PlasticTexture(RGB plasticColor, double shininess, double glossiness)\n" +
                            "Examples:\n" +
                            "-1                   # Default gray plastic\n" +
                            "1,0,0,    80,  0.5   # Red shiny plastic\n" +
                            "0,0.5,1,  30,  0.2   # Blue matte plastic\n" +
                            "Enter values after ###\n###\n";
        return PLASTIC_STR;
    }
    
    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        Texture texture = null;
        String str = info.trim();
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return texture;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "").replaceAll(" ", "");
        
        if (str.equals("-1")) return new PlasticTexture();
        
        String[] split = str.split(",");
        if (split == null || split.length != 5) return texture;
        
        try {
            double r = Double.parseDouble(split[0]);
            double g = Double.parseDouble(split[1]);
            double b = Double.parseDouble(split[2]);
            double shine = Double.parseDouble(split[3]);
            double gloss = Double.parseDouble(split[4]);
            
            texture = new PlasticTexture(new RGB(r, g, b), shine, gloss);
            return texture;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }
    
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"plasticColor", plasticColor},
            {"shininess", shininess},
            {"glossiness", glossiness}
        };
        writer.writeFields(fields);
    }
    
    // Getters
    public RGB getPlasticColor() { return plasticColor; }
    public double getShininess() { return shininess; }
    public double getGlossiness() { return glossiness; }
}


// =========================================
// File: /raja/material/DreamMistTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class DreamMistTexture implements Texture, java.io.Serializable, Writable {
    private RGB baseColor;
    private RGB fogColor;
    private double transparency;
    private double glowIntensity;
    
    // Default constructor
    public DreamMistTexture() {
        this(new RGB(0.9, 0.95, 1.0),    // Light blue-white
             new RGB(0.8, 0.9, 1.0),     // Fog color
             0.7,                        // 70% transparency
             0.3);                       // Glow intensity
    }
    
    // Custom constructor
    public DreamMistTexture(RGB baseColor, RGB fogColor, double transparency, double glowIntensity) {
        this.baseColor = baseColor;
        this.fogColor = fogColor;
        this.transparency = transparency;
        this.glowIntensity = glowIntensity;
    }
    
    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Dreamy mist effect with depth-based fog
        double depthEffect = Math.sin(p.x * 5) * Math.cos(p.y * 5) * 0.3 + 0.7;
        RGB surfaceColor = interpolateColor(baseColor, fogColor, depthEffect);
        
        // Add glow effect
        RGB glow = new RGB(glowIntensity, glowIntensity, glowIntensity);
        RGB finalColor = surfaceColor.add(glow.multiply(0.2));
        
        return new LocalTexture(
            finalColor,
            finalColor.multiply(0.6),    // High ambient for dreamy look
            new RGB(0.3, 0.3, 0.4),      // Soft specular
            15,                          // Medium shininess
            1
        );
    }
    
    private RGB interpolateColor(RGB color1, RGB color2, double factor) {
        factor = Math.max(0, Math.min(1, factor));
        return new RGB(
            color1.getR() * (1 - factor) + color2.getR() * factor,
            color1.getG() * (1 - factor) + color2.getG() * factor,
            color1.getB() * (1 - factor) + color2.getB() * factor
        );
    }
    
    // IO methods
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("baseColor", new RGB(0.9, 0.95, 1.0));
        map.put("fogColor", new RGB(0.8, 0.9, 1.0));
        map.put("transparency", 0.7);
        map.put("glowIntensity", 0.3);

        reader.readFields(map);

        return new DreamMistTexture(
            (RGB) map.get("baseColor"),
            (RGB) map.get("fogColor"),
            ((Number) map.get("transparency")).doubleValue(),
            ((Number) map.get("glowIntensity")).doubleValue()
        );
    }

    @Override
    public String getUsageInformation() {
        String DREAM_MIST_STR = "Constructor: DreamMistTexture(RGB baseColor, RGB fogColor, double transparency, double glowIntensity)\n" +
                               "Examples:\n" +
                               "-1                             # Default dream mist\n" +
                               "0.9,0.95,1.0,  0.8,0.9,1.0,   0.7,  0.3  # Blue dream mist\n" +
                               "1.0,0.95,0.9,  0.9,0.85,0.8,  0.8,  0.4  # Warm golden mist\n" +
                               "Enter values after ###\n###\n";
        return DREAM_MIST_STR;
    }

    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        Texture texture = null;
        
        String str = info.trim();
        
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return texture;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "");
        str = str.replaceAll(" ", "");
        
        if (str.equals("-1")) return new DreamMistTexture();
        
        String[] split = str.split(",");
        if (split == null || split.length != 8) return texture;
        
        try {
            double r1 = Double.parseDouble(split[0]);
            double g1 = Double.parseDouble(split[1]);
            double b1 = Double.parseDouble(split[2]);
            double r2 = Double.parseDouble(split[3]);
            double g2 = Double.parseDouble(split[4]);
            double b2 = Double.parseDouble(split[5]);
            double transparency = Double.parseDouble(split[6]);
            double glow = Double.parseDouble(split[7]);
            
            texture = new DreamMistTexture(
                new RGB(r1, g1, b1),
                new RGB(r2, g2, b2),
                transparency,
                glow
            );
            return texture;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseColor", baseColor},
            {"fogColor", fogColor},
            {"transparency", transparency},
            {"glowIntensity", glowIntensity}
        };
        writer.writeFields(fields);
    }

    // Getters
    public RGB getBaseColor() { return baseColor; }
    public RGB getFogColor() { return fogColor; }
    public double getTransparency() { return transparency; }
    public double getGlowIntensity() { return glowIntensity; }
}


// =========================================
// File: /raja/material/StormTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class StormTexture implements Texture, java.io.Serializable, Writable {
    private double time = 0.0;

    public StormTexture() {}

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double cloud = Math.sin(time + p.x * 2 + p.y * 3) * 0.2;
        double lightning = Math.random() > 0.98 ? 1.0 : 0.0;
        
        RGB stormColor = new RGB(
            0.3 + cloud * 0.1,
            0.3 + cloud * 0.1,
            0.4 + cloud * 0.1
        );

        RGB emissive = new RGB(
            lightning * 0.8,
            lightning * 0.9,
            lightning * 1.0
        );

        return new LocalTexture(
            stormColor,
            new RGB(0.1, 0.1, 0.2),
            emissive,
            30, 10
        );
    }
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: StormTexture();\nPress Set button please.";
    }

    private String exampleString = "null";
    
    @Override
    public String toExampleString() {
        return this.exampleString;
    }

    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        return new StormTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new StormTexture();
    }
}


// =========================================
// File: /raja/material/NorwegianRoseTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

public class NorwegianRoseTexture implements Texture, java.io.Serializable, Writable {
    private RGB woodColor;
    private RGB roseColor;
    private int plane; // 0: XY, 1: XZ, 2: YZ
    private double tileSize; // Tile büyüklüğü (varsayılan: 2.0)

    // Phong/boyalı ahşap sabitleri
    private static final double AMBIENT_FACTOR = 0.4;
    private static final double SPECULAR_FACTOR = 0.2;
    private static final RGB SPECULAR_COLOR = new RGB(220.0/255.0, 220.0/255.0, 220.0/255.0);
    private static final int REFLECTIVITY = 1;
    private static final int SHININESS = 30;

    private static final double TWO_PI = Math.PI * 2;
    private static final double THREE_PI = Math.PI * 3;

    // Varsayılan kurucu
    public NorwegianRoseTexture() {
        this(
            new RGB(101.0/255.0, 67.0/255.0, 33.0/255.0), // Kahverengi ahşap
            new RGB(200.0/255.0, 50.0/255.0, 50.0/255.0), // Kırmızı rosemål
            0,     // varsayılan: XY düzlemi
            2.0    // varsayılan tile boyutu
        );
    }

    public NorwegianRoseTexture(RGB woodColor, RGB roseColor) {
        this(woodColor, roseColor, 0, 2.0);
    }

    public NorwegianRoseTexture(RGB woodColor, RGB roseColor, int plane) {
        this(woodColor, roseColor, plane, 2.0);
    }

    public NorwegianRoseTexture(RGB woodColor, RGB roseColor, double tileSize, int plane) {
        this.woodColor = woodColor;
        this.roseColor = roseColor;
        this.tileSize = tileSize;
        this.plane = plane;
    }
    
    public NorwegianRoseTexture(RGB woodColor, RGB roseColor, int plane, double tileSize) {
        this.woodColor = woodColor;
        this.roseColor = roseColor;
        this.plane = plane;
        this.tileSize = tileSize;
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double u, v;

        // Düzlem seçimi
        switch (plane) {
            case 1: // XZ - duvar
                u = p.x;
                v = p.z;
                break;
            case 2: // YZ - yan duvar
                u = p.y;
                v = p.z;
                break;
            default: // XY - zemin/ahşap yüzey
                u = p.x;
                v = p.y;
                break;
        }

        // Tile büyüklüğünü ayarla (daha büyük = desen daha net)
        u = u / tileSize;
        v = v / tileSize;

        // Tile içi koordinatlar [0,1)
        double tileU = u - Math.floor(u);
        double tileV = v - Math.floor(v);

        // Ahşap doku + rosemål deseni
        RGB woodBase = addWoodGrain(woodColor, u, v);
        RGB surfaceColor = createRosemalPattern(woodBase, tileU, tileV);

        // Boyalı ahşap malzeme özellikleri
        RGB ambient = surfaceColor.multiply(AMBIENT_FACTOR);
        RGB diffuse = surfaceColor;
        RGB specular = SPECULAR_COLOR.multiply(SPECULAR_FACTOR);

        return new LocalTexture(
            diffuse,
            ambient,
            specular,
            SHININESS,
            REFLECTIVITY
        );
    }

    private RGB addWoodGrain(RGB baseWood, double u, double v) {
        // Ahşap damar efekti
        double grain = Math.sin(u * 3.0) * 0.15 + Math.sin(v * 1.5) * 0.1;
        double factor = 0.85 + grain;

        return new RGB(
            Math.min(1.0, Math.max(0.0, baseWood.getR() * factor)),
            Math.min(1.0, Math.max(0.0, baseWood.getG() * factor)),
            Math.min(1.0, Math.max(0.0, baseWood.getB() * factor))
        );
    }

    private RGB createRosemalPattern(RGB woodBase, double tileU, double tileV) {
        // 1. Kenarlık
        if (tileU < 0.1 || tileU > 0.9 || tileV < 0.1 || tileV > 0.9) {
            return roseColor;
        }

        // 2. Merkez çiçek
        double dx = tileU - 0.5;
        double dy = tileV - 0.5;
        double distSq = dx * dx + dy * dy;

        if (distSq < 0.04) { // yarıçap ~0.2
            if (distSq > 0.01) { // iç boşluk
                double angle = Math.atan2(dy, dx);
                double petal = Math.sin(angle * 6) * 0.5 + 0.5;
                if (petal > 0.7) {
                    return roseColor;
                }
            }
            // Merkez dolu değil → ahşap kalır
        }

        // 3. Dalgalı ve geometrik desenler
        double diffUV = Math.abs(tileU - tileV);
        double sumUV = Math.abs(tileU + tileV - 1.0);

        if (diffUV < 0.03 ||
            sumUV < 0.03 ||
            Math.sin(tileU * THREE_PI) > 0.8 ||
            Math.sin(tileV * THREE_PI) > 0.8 ||
            Math.cos(tileU * TWO_PI) > 0.7 ||
            Math.cos(tileV * TWO_PI) > 0.7) {
            return roseColor;
        }

        // 4. Köşe süslemeleri
        if ((Math.abs(tileU - 0.25) < 0.04 && Math.abs(tileV - 0.25) < 0.04) ||
            (Math.abs(tileU - 0.75) < 0.04 && Math.abs(tileV - 0.75) < 0.04) ||
            (Math.abs(tileU - 0.25) < 0.04 && Math.abs(tileV - 0.75) < 0.04) ||
            (Math.abs(tileU - 0.75) < 0.04 && Math.abs(tileV - 0.25) < 0.04)) {
            return roseColor;
        }

        return woodBase;
    }

    // --- IO Desteği ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("woodColor", null);
        map.put("roseColor", null);
        map.put("plane", 0);
        map.put("tileSize", 2.0);

        reader.readFields(map);

        return new NorwegianRoseTexture(
            (RGB) map.get("woodColor"),
            (RGB) map.get("roseColor"),
            ((Number) map.get("plane")).intValue(),
            ((Number) map.get("tileSize")).doubleValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		// NorwegianRoseTexture(RGB woodColor, RGB roseColor, double tileSize, int plane)
		//0.4,0.2,0.1,  0.7,0.2,0.2,  0.2,  0|1|2(xyPlane/xz/yzSphere)
		String NORWEGIANROSE_STR="Constructor is: NorwegianRoseTexture(RGB woodColor, RGB roseColor, double tileSize, int plane);\nExample:\n0.4,0.2,0.1,  0.7,0.2,0.2,  4.0,  0|1|2(xy/xz/yz)\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return NORWEGIANROSE_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new NorwegianRoseTexture();
		
		String [] split = str.split (",");
		if (split == null) return texture;

		// NorwegianRoseTexture(RGB woodColor, RGB roseColor, double tileSize, int plane)
		//0.4,0.2,0.1,  0.7,0.2,0.2,  4.0,  0|1|2(xy/xz/yz)
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double sc = Double.parseDouble(split[6]);
				
				int pl = Integer.parseInt(split[7]);

				texture = new NorwegianRoseTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					sc, pl);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"woodColor", woodColor},
            {"roseColor", roseColor},
            {"plane", plane},
            {"tileSize", tileSize}
        };
        writer.writeFields(fields);
    }

    // --- Getter'lar ---
    public RGB getWoodColor() { return woodColor; }
    public RGB getRoseColor() { return roseColor; }
    public int getPlane() { return new Integer(plane); }
    public double getTileSize() { return new Double(tileSize); }
    
}

/**
// Varsayılan tile boyutu (2.0)
Texture norwegianFloor = new NorwegianRoseTexture(
    new RGB(0.4, 0.26, 0.13),   // Ahşap kahverengisi
    new RGB(0.78, 0.2, 0.2),    // Kırmızı rosemål
    0                           // XY düzlemi
);

// Özel tile boyutu
Texture largeTile = new NorwegianRoseTexture(
    new RGB(0.4, 0.26, 0.13),
    new RGB(0.78, 0.2, 0.2),
    0,                          // XY düzlemi
    4.0                         // Büyük desenler
);

// Duvar paneli
Texture wallPanel = new NorwegianRoseTexture(
    new RGB(0.5, 0.35, 0.2),
    new RGB(0.2, 0.6, 0.8),     // Mavi rosemål alternatifi
    1,                          // XZ düzlemi
    1.5                         // Orta boy desenler
);
*/


// =========================================
// File: /raja/material/SandTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class SandTexture implements Texture, java.io.Serializable, Writable {
    private RGB baseSandColor;
    private RGB darkSandColor;
    private double grainSize;
    private double roughness;
    
    // Default constructor
    public SandTexture() {
        this(new RGB(0.76, 0.70, 0.50),   // Light sand color
             new RGB(0.65, 0.58, 0.38),   // Dark sand color
             0.05,                        // Grain size
             0.8);                        // Roughness
    }
    
    // Custom constructor
    public SandTexture(RGB baseSandColor, RGB darkSandColor, double grainSize, double roughness) {
        this.baseSandColor = baseSandColor;
        this.darkSandColor = darkSandColor;
        this.grainSize = grainSize;
        this.roughness = roughness;
    }
    
    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Simple noise-like sand pattern
        double noise = improvedNoise(p.x * 10, p.y * 10, p.z * 10);
        double grainPattern = Math.sin(p.x * 100 * grainSize) * Math.cos(p.y * 100 * grainSize);
        
        RGB surfaceColor = interpolateColor(baseSandColor, darkSandColor, (noise + grainPattern) * 0.5);
        
        return new LocalTexture(
            surfaceColor,
            surfaceColor.multiply(0.5),  // High ambient - soft shadows
            new RGB(0.1, 0.1, 0.1),      // Low specular
            5,                           // Low shininess
            1
        );
    }
    
    private double improvedNoise(double x, double y, double z) {
        // Simple perlin noise-like function
        return (Math.sin(x * 12.9898 + y * 78.233 + z * 45.164) * 43758.5453) % 1.0;
    }
    
    private RGB interpolateColor(RGB color1, RGB color2, double factor) {
        factor = Math.max(0, Math.min(1, (factor + 1) * 0.5));
        return new RGB(
            color1.getR() * (1 - factor) + color2.getR() * factor,
            color1.getG() * (1 - factor) + color2.getG() * factor,
            color1.getB() * (1 - factor) + color2.getB() * factor
        );
    }
    
    // IO methods
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("baseSandColor", new RGB(0.76, 0.70, 0.50));
        map.put("darkSandColor", new RGB(0.65, 0.58, 0.38));
        map.put("grainSize", 0.05);
        map.put("roughness", 0.8);

        reader.readFields(map);

        return new SandTexture(
            (RGB) map.get("baseSandColor"),
            (RGB) map.get("darkSandColor"),
            ((Number) map.get("grainSize")).doubleValue(),
            ((Number) map.get("roughness")).doubleValue()
        );
    }

    @Override
    public String getUsageInformation() {
        String SAND_STR = "Constructor: SandTexture(RGB baseSandColor, RGB darkSandColor, double grainSize, double roughness)\n" +
                         "Examples:\n" +
                         "-1                             # Default sand texture\n" +
                         "0.76,0.70,0.50,  0.65,0.58,0.38,  0.05,  0.8  # Golden sand\n" +
                         "0.9,0.85,0.7,    0.8,0.75,0.6,    0.03,  0.9  # White beach sand\n" +
                         "Enter values after ###\n###\n";
        return SAND_STR;
    }

    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        Texture texture = null;
        
        String str = info.trim();
        
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return texture;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "");
        str = str.replaceAll(" ", "");
        
        if (str.equals("-1")) return new SandTexture();
        
        String[] split = str.split(",");
        if (split == null || split.length != 8) return texture;
        
        try {
            double r1 = Double.parseDouble(split[0]);
            double g1 = Double.parseDouble(split[1]);
            double b1 = Double.parseDouble(split[2]);
            double r2 = Double.parseDouble(split[3]);
            double g2 = Double.parseDouble(split[4]);
            double b2 = Double.parseDouble(split[5]);
            double grainSize = Double.parseDouble(split[6]);
            double roughness = Double.parseDouble(split[7]);
            
            texture = new SandTexture(
                new RGB(r1, g1, b1),
                new RGB(r2, g2, b2),
                grainSize,
                roughness
            );
            return texture;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseSandColor", baseSandColor},
            {"darkSandColor", darkSandColor},
            {"grainSize", grainSize},
            {"roughness", roughness}
        };
        writer.writeFields(fields);
    }

    // Getters
    public RGB getBaseSandColor() { return baseSandColor; }
    public RGB getDarkSandColor() { return darkSandColor; }
    public double getGrainSize() { return grainSize; }
    public double getRoughness() { return roughness; }
}


// =========================================
// File: /raja/material/WoodTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

public class WoodTexture implements Texture, java.io.Serializable, Writable {
    private RGB baseColor;
    private RGB ringColor;
    private double scale;
    private double grainStrength;

    // Phong parameters for matte painted or natural wood
    private static final double AMBIENT_FACTOR = 0.3;
    private static final double SPECULAR_FACTOR = 0.2;
    private static final RGB SPECULAR_COLOR = new RGB(0.9, 0.9, 0.9);
    private static final int REFLECTIVITY = 1;
    private static final int SHININESS = 30;

    public WoodTexture() {
        this(
            new RGB(0.65, 0.45, 0.3),   // warm brown base
            new RGB(0.4, 0.25, 0.15),   // darker rings
            8.0,
            0.3
        );
    }

    public WoodTexture(RGB baseColor, RGB ringColor, double scale, double grainStrength) {
        this.baseColor = baseColor;
        this.ringColor = ringColor;
        this.scale = Math.max(0.1, scale);
        this.grainStrength = Math.min(1.0, Math.max(0.0, grainStrength));
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Use XY plane for standard wood flooring or paneling
        double u = p.x * scale;
        double v = p.y * scale;

        // Simulate annual rings using radial distance from origin (or pseudo-origin)
        // To avoid singularity at (0,0), add small offset
        double dx = p.x + 0.001;
        double dy = p.y + 0.001;
        double radial = Math.sqrt(dx * dx + dy * dy) * scale * 0.5;

        // Annual rings: sine wave along radial direction
        double rings = Math.sin(radial * 2.0 * Math.PI) * 0.5 + 0.5;

        // Wood fiber: subtle vertical grain using sine noise
        double fiber = Math.sin(u * 3.0) * 0.1 + Math.sin(v * 1.5) * 0.05;
        double grain = 1.0 + fiber * grainStrength;

        // Blend base and ring colors based on ring intensity
        RGB color;
        if (rings < 0.4) {
            color = ringColor;
        } else if (rings < 0.6) {
            double blend = (rings - 0.4) / 0.2;
            color = RGB.interpolate(ringColor, baseColor, blend);
        } else {
            color = baseColor;
        }

        // Apply grain modulation (slight brightness variation)
        color = new RGB(
            Math.min(1.0, Math.max(0.0, color.getR() * grain)),
            Math.min(1.0, Math.max(0.0, color.getG() * grain)),
            Math.min(1.0, Math.max(0.0, color.getB() * grain))
        );

        return new LocalTexture(
            color,
            color.multiply(AMBIENT_FACTOR),
            SPECULAR_COLOR.multiply(SPECULAR_FACTOR),
            SHININESS,
            REFLECTIVITY
        );
    }

    // --- IO Support ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("baseColor", null);
        map.put("ringColor", null);
        map.put("scale", 8.0);
        map.put("grainStrength", 0.3);

        reader.readFields(map);

        return new WoodTexture(
            (RGB) map.get("baseColor"),
            (RGB) map.get("ringColor"),
            ((Number) map.get("scale")).doubleValue(),
            ((Number) map.get("grainStrength")).doubleValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//WoodTexture(RGB baseColor, RGB ringColor, double scale, double grainStrength) 
		//0.7,0.5,0.3,  0.4,0.3,0.2,  6.0, 0.25
		String WOOD_STR="Constructor is: WoodTexture(RGB baseColor, RGB ringColor, double scale, double grainStrength);\nExample:\n0.7,0.5,0.3,  0.4,0.3,0.2,  6.0, 0.25\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return WOOD_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new WoodTexture();
		
		String [] split = str.split (",");
		if (split == null) return texture;

		//WoodTexture(RGB baseColor, RGB ringColor, double scale, double grainStrength) 
		//0.7,0.5,0.3,  0.4,0.3,0.2,  6.0, 0.25
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double sc = Double.parseDouble(split[6]);
				double gs = Double.parseDouble(split[7]);

				texture = new WoodTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					sc, gs);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseColor", baseColor},
            {"ringColor", ringColor},
            {"scale", scale},
            {"grainStrength", grainStrength}
        };
        writer.writeFields(fields);
    }

    // --- Getters ---
    public RGB getBaseColor() { return baseColor; }
    public RGB getRingColor() { return ringColor; }
    public double getScale() { return scale; }
    public double getGrainStrength() { return grainStrength; }
    
}

/**
// Natural oak
Texture oak = new WoodTexture(
    new RGB(0.7, 0.5, 0.35),
    new RGB(0.45, 0.3, 0.2),
    10.0,
    0.4
);

// Dark walnut
Texture walnut = new WoodTexture(
    new RGB(0.35, 0.25, 0.2),
    new RGB(0.15, 0.1, 0.08),
    6.0,
    0.25
);
*/


// =========================================
// File: /raja/material/LambertianTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;
import java.util.HashMap;

public class LambertianTexture implements Texture, java.io.Serializable, Writable {
    private RGB albedo;

    public LambertianTexture() {
        this(new RGB(0.7, 0.7, 0.7));
    }

    public LambertianTexture(RGB albedo) {
        this.albedo = albedo;
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Tamamen diffuse, tamamen mat
        return new LocalTexture(
            albedo,
            albedo.multiply(0.1),  // minimal ambient
            new RGB(0, 0, 0),      // NO specular
            1,                     // minimum shininess
            0                      // NO reflection
        );
    }

    // --- IO ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("albedo", null);
        reader.readFields(map);
        return new LambertianTexture((RGB) map.get("albedo"));
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		String LAMBERTIAN_STR = "Constructor is: LambertianTexture(RGB albedo);\nExample:\n0.0, 0.7, 0.0\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return LAMBERTIAN_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new LambertianTexture();
		 
		String [] split = str.split (",");
		if (split == null) return texture;
		//0.85,0.85,0.0
			try {
				double r = Double.parseDouble(split[0]);
				double g = Double.parseDouble(split[1]);
				double b = Double.parseDouble(split[2]);
								
				texture = new LambertianTexture(new RGB(r, g, b));
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        writer.writeFields(new Object[][] { {"albedo", albedo} });
    }

    public RGB getAlbedo() { return albedo; }
    
}


// =========================================
// File: /raja/material/MetalTexture.java
// =========================================

// Murat Inan
package raja.material;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

import raja.*;
import raja.shape.*;
import raja.io.*;

public class MetalTexture implements Texture, java.io.Serializable, Writable
{
    private RGB kd, kr, kt;
    private int ns, nt;
    private double step, x0, y0;
    
    // Ana constructor - metal rengi ve özellikleri ile
    public MetalTexture(RGB metalColor, double reflectivity, double shininess)
    {
        // Metal için otomatik renk ayarları
        this.kd = metalColor.multiply(0.3);  // Diffuse kısım koyu
        this.kr = metalColor.multiply(reflectivity);  // Reflection metal renginde
        this.kt = new RGB(0.0, 0.0, 0.0);  // Metals are not transparent
        
        // Shininess ayarı - yüksek shininess = parlak metal
        this.ns = (int)(shininess * 1000);
        this.nt = 1;
        
        // Damier pattern için varsayılan değerler
        this.step = 0.5;
        this.x0 = 0.0;
        this.y0 = 0.0;
    }
    
    // Basit constructor - sadece metal rengi
    public MetalTexture(RGB metalColor)
    {
        this(metalColor, 0.8, 0.9);  // Varsayılan: yüksek reflectivity ve shininess
    }
    
    // RGB ve pattern parametreleri ile constructor
    public MetalTexture(RGB kd, RGB kr, RGB kt, int ns, int nt, double step, double x0, double y0)
    {
        this.kd = kd;
        this.kr = kr;
        this.kt = kt;
        this.ns = ns;
        this.nt = nt;
        this.step = step;
        this.x0 = x0;
        this.y0 = y0;
    }

    // Predefined metal types - kolay kullanım için static factory methods
    public static MetalTexture createGold()
    {
        RGB goldColor = new RGB(1.0, 0.84, 0.0);  // Altın rengi
        return new MetalTexture(goldColor, 0.9, 0.95);
    }
    
    public static MetalTexture createSilver()
    {
        RGB silverColor = new RGB(0.75, 0.75, 0.75);  // Gümüş rengi
        return new MetalTexture(silverColor, 0.95, 0.98);
    }
    
    public static MetalTexture createCopper()
    {
        RGB copperColor = new RGB(0.72, 0.45, 0.20);  // Bakır rengi
        return new MetalTexture(copperColor, 0.85, 0.9);
    }
    
    public static MetalTexture createBronze()
    {
        RGB bronzeColor = new RGB(0.55, 0.47, 0.14);  // Bronz rengi
        return new MetalTexture(bronzeColor, 0.8, 0.85);
    }
    
    public static MetalTexture createSteel()
    {
        RGB steelColor = new RGB(0.65, 0.65, 0.67);  // Çelik rengi
        return new MetalTexture(steelColor, 0.7, 0.8);
    }
    
    public static MetalTexture createAluminum()
    {
        RGB aluminumColor = new RGB(0.77, 0.77, 0.80);  // Alüminyum rengi
        return new MetalTexture(aluminumColor, 0.9, 0.92);
    }
    
    public static MetalTexture createPlatinum()
    {
        RGB platinumColor = new RGB(0.90, 0.89, 0.89);  // Platin rengi
        return new MetalTexture(platinumColor, 0.92, 0.96);
    }

    /**
     * Builds the object LocalTexture from a StreamLexer.
     */
    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        /* Initialisation */
        HashMap map = new HashMap();

        map.put("kd", null);
        map.put("kr", null);
        map.put("kt", null);
        map.put("ns", null);
        map.put("nt", null);
        map.put("step", null);
        map.put("x", null);
        map.put("y", null);

        /* Parsing */
        reader.readFields(map);

        return new MetalTexture((RGB) map.get("kd"),
                               (RGB) map.get("kr"),
                               (RGB) map.get("kt"),
                               ((Number) map.get("ns")).intValue(),
                               ((Number) map.get("nt")).intValue(),
                               ((Number) map.get("step")).doubleValue(),
                               ((Number) map.get("x")).doubleValue(),
                               ((Number) map.get("y")).doubleValue());
    }
    
	@Override
	public LocalTexture getLocalTexture(Point3D p)
	{
		// TAMAMEN DÜZ METAL
		return new LocalTexture(kd, kr, kt, ns, nt);
	}

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		String METAL_STR="Constructor is: MetalTexture(RGB kd, RGB kr, RGB kt, int ns, int nt, double step, double x0, double y0);\nExample:\n1.0,1.0,0.0,  1.0,0.0,0.0,  0.3,0.3,0.3,  100, 10, 4.5, 0.0, 0.0\nEnter your values after three diyez symbol\n###\n";
		return METAL_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return texture;

			//1.0,1.0,0.0,  1.0,0.0,0.0,  0.3,0.3,0.3,  100, 10, 4.5, 0.0, 0.0
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double c3r = Double.parseDouble(split[6]);
				double c3g = Double.parseDouble(split[7]);
				double c3b = Double.parseDouble(split[8]);
				
				int ns = Integer.parseInt(split[9]);
				int nt = Integer.parseInt(split[10]);
				
				double step = Double.parseDouble(split[11]);
				double xd = Double.parseDouble(split[12]);
				double yd = Double.parseDouble(split[13]);

				texture = new MetalTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					new RGB(c3r, c3g, c3b),
					ns, nt, step, xd, yd);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "kd", kd },
                              { "kr", kr },
                              { "kt", kt },
                              { "ns", new Integer(ns) },
                              { "nt", new Integer(nt) },
                              { "step", new Double(step) },
                              { "x", new Double(x0) },
                              { "y", new Double(y0) } };
        writer.writeFields(fields);
    }
    
    // Getter methods
    public RGB getKd() { return kd; }
    public RGB getKr() { return kr; }
    public RGB getKt() { return kt; }
    public int getNs() { return ns; }
    public int getNt() { return nt; }
    public double getStep() { return step; }
    public double getX0() { return x0; }
    public double getY0() { return y0; }
    
    // Setter methods
    public void setStep(double step) { this.step = step; }
    public void setX0(double x0) { this.x0 = x0; }
    public void setY0(double y0) { this.y0 = y0; }
    
}


// =========================================
// File: /raja/material/HokusaiTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

public class HokusaiTexture implements Texture, java.io.Serializable, Writable {
    public static final int PLANE_MODE = 0;
    public static final int SPHERE_MODE = 1;

    private RGB waterColor;
    private RGB foamColor;
    private double scale;
    private int mode; // 0: plane, 1: sphere
    private double radius; // sadece küre modunda kullanılır

    // Phong sabitleri (su/sıvı için optimize)
    private static final double AMBIENT_FACTOR = 0.2;
    private static final double SPECULAR_FACTOR = 0.9;
    private static final RGB SPECULAR_COLOR = new RGB(1.0, 1.0, 1.0);
    private static final int REFLECTIVITY = 6;
    private static final int SHININESS = 300; // parlak su

    // Varsayılan kurucu
    public HokusaiTexture() {
        this(new RGB(0.1, 0.2, 0.5),   // Koyu mavi su
             new RGB(1.0, 1.0, 1.0),   // Beyaz köpük
             4.0,                      // scale
             PLANE_MODE,
             1.0);                     // radius (küre için)
    }

    public HokusaiTexture(RGB waterColor, RGB foamColor, double scale, int mode, double radius) {
        this.waterColor = waterColor;
        this.foamColor = foamColor;
        this.scale = Math.max(0.1, scale);
        this.mode = (mode == SPHERE_MODE) ? SPHERE_MODE : PLANE_MODE;
        this.radius = Math.max(0.1, radius);
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double u, v;

        if (mode == SPHERE_MODE) {
            // Küre üzerinde enlem-boylam (latitude-longitude)
            double len = p.length();
            if (len < 1e-6) {
                u = 0; v = 0;
            } else {
                // Normalize et (küre varsayımı)
                double x = p.x / len;
                double y = p.y / len;
                double z = p.z / len;

                // Enlem (latitude): -π/2 → π/2
                double lat = Math.asin(Math.max(-1.0, Math.min(1.0, y)));
                // Boylam (longitude): -π → π
                double lon = Math.atan2(z, x);

                u = (lon / (2 * Math.PI)) + 0.5; // [0,1)
                v = (lat / Math.PI) + 0.5;       // [0,1)
            }
        } else {
            // Düzlem modu: XY düzlemi
            u = p.x * scale;
            v = p.y * scale;
        }

        // Tile içi koordinatlar
        u = u - Math.floor(u);
        v = v - Math.floor(v);

        // Hokusai dalga deseni
        RGB color = createHokusaiWave(u, v);

        // Su malzemesi özellikleri
        RGB ambient = color.multiply(AMBIENT_FACTOR);
        RGB diffuse = color;
        RGB specular = SPECULAR_COLOR.multiply(SPECULAR_FACTOR);

        return new LocalTexture(
            diffuse,
            ambient,
            specular,
            SHININESS,
            REFLECTIVITY
        );
    }

    private RGB createHokusaiWave(double u, double v) {
        // Dalga yönü: soldan sağa
        double waveX = u * 8.0;      // 8 tekrar
        double waveY = v * 2.0;      // dikeyde yavaş değişim

        // Temel dalga formu (Hokusai tarzı kavis)
        double baseWave = Math.sin(waveX - waveY * 0.5) * 0.5 + 0.5;

        // Köpük efekti: dalga tepeciklerinde
        double foam = 0.0;
        if (baseWave > 0.85) {
            // Dinamik köpük: dalga yüksekliği arttıkça köpük yoğunlaşır
            foam = (baseWave - 0.85) * 6.0;
            foam = Math.min(1.0, foam);
        }

        // Derinlik solması (alt kısım daha koyu)
        double depthFade = Math.exp(-v * 3.0); // alta doğru solma

        // Renk karışımı
        RGB water = waterColor.multiply(depthFade);
        RGB blended = RGB.interpolate(water, foamColor, foam);

        return blended;
    }

    // --- IO Desteği ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("waterColor", null);
        map.put("foamColor", null);
        map.put("scale", 4.0);
        map.put("mode", PLANE_MODE);
        map.put("radius", 1.0);

        reader.readFields(map);

        return new HokusaiTexture(
            (RGB) map.get("waterColor"),
            (RGB) map.get("foamColor"),
            ((Number) map.get("scale")).doubleValue(),
            ((Number) map.get("mode")).intValue(),
            ((Number) map.get("radius")).doubleValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//HokusaiTexture(RGB waterColor, RGB foamColor, double scale, int mode, double radius)		//0.4,0.2,0.1,  0.7,0.2,0.2,  4.0,  0|1|2(xy/xz/yz)
		//0.1,0.3,0.6,  0.9,0.9,1.0,  10.0,  0|1(plane/sphere),  2.5
		String HOKUSAI_STR="Constructor is: HokusaiTexture(RGB waterColor, RGB foamColor, double scale, int mode, double radius);\nExample:\n0.1,0.3,0.6,  0.9,0.9,1.0,  10.0,  0|1(plane/sphere),  2.5\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return HOKUSAI_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new HokusaiTexture();
		
		String [] split = str.split (",");
		if (split == null) return texture;

		//HokusaiTexture(RGB waterColor, RGB foamColor, double scale, int mode, double radius)		//0.4,0.2,0.1,  0.7,0.2,0.2,  4.0,  0|1|2(xy/xz/yz)
		//0.1,0.3,0.6,  0.9,0.9,1.0,  10.0,  0|1(plane/sphere),  2.5
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double sc = Double.parseDouble(split[6]);
				
				int pl = Integer.parseInt(split[7]);
				
				double rd = Double.parseDouble(split[8]);
				
				texture = new HokusaiTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					sc, pl, rd);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"waterColor", waterColor},
            {"foamColor", foamColor},
            {"scale", scale},
            {"mode", mode},
            {"radius", radius}
        };
        writer.writeFields(fields);
    }

    // --- Getter'lar ---
    public RGB getWaterColor() { return waterColor; }
    public RGB getFoamColor() { return foamColor; }
    public double getScale() { return scale; }
    public int getMode() { return mode; }
    public double getRadius() { return radius; }
    
}

/**
Texture oceanFloor = new HokusaiTexture(
    new RGB(0.05, 0.15, 0.4),   // Koyu mavi
    new RGB(1.0, 1.0, 1.0),     // Köpük
    6.0,                        // Daha büyük dalgalar
    HokusaiTexture.PLANE_MODE,
    1.0
);

Texture waterPlanet = new HokusaiTexture(
    new RGB(0.1, 0.3, 0.6),
    new RGB(0.95, 0.95, 1.0),
    10.0,                       // Kürede daha sık tekrar
    HokusaiTexture.SPHERE_MODE,
    2.5                         // Küre yarıçapı (RAJA'da nesne ölçeğiyle uyumlu)
);
*/


// =========================================
// File: /raja/material/ColorWheelTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class ColorWheelTexture implements Texture, java.io.Serializable, Writable {
    private boolean showColorNames;
    private double wheelSize;
    
    // Default constructor
    public ColorWheelTexture() {
        this(true, 0.8);
    }
    
    // Custom constructor
    public ColorWheelTexture(boolean showColorNames, double wheelSize) {
        this.showColorNames = showColorNames;
        this.wheelSize = wheelSize;
    }
    
    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double x = p.x - 0.5;
        double y = p.y - 0.5;
        double distance = Math.sqrt(x * x + y * y);
        double angle = Math.atan2(y, x);
        
        if (distance > wheelSize) {
            return new LocalTexture(
                new RGB(0.9, 0.9, 0.9),
                new RGB(0.36, 0.36, 0.36),
                new RGB(0.2, 0.2, 0.2),
                10,
                1
            );
        }
        
        // Convert angle to hue (0 to 1)
        double hue = (angle + Math.PI) / (2 * Math.PI);
        RGB color = hueToRGB(hue);
        
        return new LocalTexture(
            color,
            color.multiply(0.4),
            new RGB(0.2, 0.2, 0.2),
            10,
            1
        );
    }
    
    private RGB hueToRGB(double hue) {
        double r = Math.abs(hue * 6 - 3) - 1;
        double g = 2 - Math.abs(hue * 6 - 2);
        double b = 2 - Math.abs(hue * 6 - 4);
        
        return new RGB(
            Math.max(0, Math.min(1, r)),
            Math.max(0, Math.min(1, g)),
            Math.max(0, Math.min(1, b))
        );
    }
    
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("showColorNames", true);
        map.put("wheelSize", 0.8);
        
        reader.readFields(map);
        
        return new ColorWheelTexture(
            (Boolean) map.get("showColorNames"),
            ((Number) map.get("wheelSize")).doubleValue()
        );
    }
    
    @Override
    public String getUsageInformation() {
        String COLORWHEEL_STR = "Constructor: ColorWheelTexture(boolean showColorNames, double wheelSize)\n" +
                               "Examples:\n" +
                               "-1             # Default color wheel with names\n" +
                               "true,  0.9       # Large wheel with names\n" +
                               "false,  0.7      # Smaller wheel without names\n" +
                               "Enter values after ###\n###\n";
        return COLORWHEEL_STR;
    }
    
    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        Texture texture = null;
        String str = info.trim();
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return texture;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "").replaceAll(" ", "");
        
        if (str.equals("-1")) return new ColorWheelTexture();
        
        String[] split = str.split(",");
        if (split == null || split.length != 2) return texture;
        
        try {
            boolean showNames = Boolean.parseBoolean(split[0]);
            double size = Double.parseDouble(split[1]);
            
            texture = new ColorWheelTexture(showNames, size);
            return texture;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }
    
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"showColorNames", showColorNames},
            {"wheelSize", wheelSize}
        };
        writer.writeFields(fields);
    }
    
    // Getters
    public boolean isShowColorNames() { return showColorNames; }
    public double getWheelSize() { return wheelSize; }
    
}


// =========================================
// File: /raja/material/WaterTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class WaterTexture implements Texture, java.io.Serializable, Writable {
    private double time = 0.0;

    public WaterTexture() {}

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double wave = Math.sin(time * 2 + p.x * 3 + p.z * 2) * 0.1;
        double ripple = Math.cos(time * 3 + p.y * 4) * 0.05;
        
        RGB waterColor = new RGB(
            0.2 + wave * 0.1,
            0.4 + ripple * 0.2,
            0.8 + wave * 0.1
        );

        return new LocalTexture(
            waterColor,
            new RGB(0.7, 0.8, 0.9),
            new RGB(0.1, 0.2, 0.3),
            200, 100
        );
    }
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: WaterTexture();\nPress Set button please.";
    }

    private String exampleString = "null";
    
    @Override
    public String toExampleString() {
        return this.exampleString;
    }

    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        return new WaterTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new WaterTexture();
    }
}


// =========================================
// File: /raja/material/CeramicTileTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

public class CeramicTileTexture implements Texture, java.io.Serializable, Writable {
    private RGB tileColor1;  // Örneğin: Beyaz
    private RGB tileColor2;  // Örneğin: Siyah
    private RGB groutColor;
    private double tileSize;
    private double groutWidth;
    private int plane; // 0:XY, 1:XZ, 2:YZ

    // Damier (iki renkli) versiyon
    public CeramicTileTexture(RGB tileColor1, RGB tileColor2, RGB groutColor,
                              double tileSize, double groutWidth, int plane) {
        this.tileColor1 = tileColor1;
        this.tileColor2 = tileColor2;
        this.groutColor = groutColor;
        this.tileSize = tileSize;
        this.groutWidth = groutWidth;
        this.plane = plane;
    }

    // Zemin için (XY düzlemi) - iki renkli
    public CeramicTileTexture(RGB tileColor1, RGB tileColor2, RGB groutColor,
                              double tileSize, double groutWidth) {
        this(tileColor1, tileColor2, groutColor, tileSize, groutWidth, 0);
    }

    // Eski tek-renkli kullanım için uyumluluk (opsiyonel)
    public CeramicTileTexture(RGB tileColor, RGB groutColor, double tileSize, double groutWidth, int plane) {
        this(tileColor, tileColor, groutColor, tileSize, groutWidth, plane); // Aynı renk iki kez → tek renk
    }

@Override
public LocalTexture getLocalTexture(Point3D p) {
    double u, v;

    switch (plane) {
        case 0: // XY düzlemi - ZEMİN
            u = p.x;
            v = p.y;
            break;
        case 1: // XZ düzlemi - DUVAR
            u = p.x;
            v = p.z;
            break;
        case 2: // YZ düzlemi - YAN DUVAR
            u = p.y;
            v = p.z;
            break;
        default:
            u = p.x;
            v = p.y;
    }

    //  DOĞRU KARE İNDEKSİ HESAPLAMASI
    int kareU = (int) Math.floor(u / tileSize);
    int kareV = (int) Math.floor(v / tileSize);

    // Kare içindeki yer (0 ile tileSize arası)
    double localU = u - kareU * tileSize;
    double localV = v - kareV * tileSize;

    // Derz kontrolü — kenarlarda kesintisiz çizgi için
    boolean isGrout = (localU <= groutWidth) || 
                      (localU >= tileSize - groutWidth) ||
                      (localV <= groutWidth) || 
                      (localV >= tileSize - groutWidth);

    RGB baseColor;
    if (isGrout) {
        baseColor = groutColor;
    } else {
        // Damier desen
        baseColor = ((kareU + kareV) % 2 == 0) ? tileColor1 : tileColor2;
    }

    return new LocalTexture(
        baseColor,
        baseColor.multiply(0.4),
        new RGB(0.0, 0.0, 0.0),
        isGrout ? 100 : 500,
        1
    );
}

    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("tileColor1", null);
        map.put("tileColor2", null);
        map.put("groutColor", null);
        map.put("tileSize", 0.5);
        map.put("groutWidth", 0.03);
        map.put("plane", 0);

        reader.readFields(map);

        return new CeramicTileTexture(
            (RGB) map.get("tileColor1"),
            (RGB) map.get("tileColor2"),
            (RGB) map.get("groutColor"),
            ((Number) map.get("tileSize")).doubleValue(),
            ((Number) map.get("groutWidth")).doubleValue(),
            ((Number) map.get("plane")).intValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
      String CERAMICTILE_STR = "Constructor is: CeramicTileTexture (RGB tileColor1, RGB tileColor2, RGB groutColor, double tileSize, double groutWidth, int plane);\nExample:\n0.95,0.95,0.98,  0.1,0.1,0.1,  0.3,0.3,0.3,  0.4,  0.01,  0|1|2(xy/xz/yz)\nEnter your values after three diyez symbol\n###\n";
	  return CERAMICTILE_STR;                    
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
        Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
					
		String [] split = str.split (",");
		if (split == null) return texture;
		
		// CeramicTileTexture(RGB tileColor1, RGB tileColor2, RGB groutColor,
        // double tileSize, double groutWidth, int plane)
        try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double c3r = Double.parseDouble(split[6]);
				double c3g = Double.parseDouble(split[7]);
				double c3b = Double.parseDouble(split[8]);
				
				double ts = Double.parseDouble(split[9]);
				double gw = Double.parseDouble(split[10]);
				
				int pl = Integer.parseInt(split[11]);
				
				texture = new CeramicTileTexture(
				    new RGB(c1r, c1g, c1b), 
				    new RGB(c2r, c2g, c2b),
				    new RGB(c3r, c3g, c3b),
				    ts, gw, pl);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            { "tileColor1", tileColor1 },
            { "tileColor2", tileColor2 },
            { "groutColor", groutColor },
            { "tileSize", tileSize },
            { "groutWidth", groutWidth },
            { "plane", plane }
        };
        writer.writeFields(fields);
    }

    // Getter'lar
    public RGB getTileColor1() { return tileColor1; }
    public RGB getTileColor2() { return tileColor2; }
    public RGB getGroutColor() { return groutColor; }
    public double getTileSize() { return tileSize; }
    public double getGroutWidth() { return groutWidth; }
    public int getPlane() { return plane; }
    
}

/**
// Beyaz-Siyah satranç zemin (klasik damier)
Texture floor = new CeramicTileTexture(
    new RGB(0.95, 0.95, 0.98),  // Açık beyaz
    new RGB(0.1, 0.1, 0.12),    // Siyah
    new RGB(0.3, 0.3, 0.35),    // Gri derz
    0.4,                        // 40 cm kare
    0.01,                       // 1 cm derz
    0                           // XY düzlemi
);

// Kırmızı-Beyaz mutfak duvarı
Texture wall = new CeramicTileTexture(
    new RGB(0.9, 0.3, 0.3),     // Kırmızı
    new RGB(0.95, 0.95, 0.98),  // Beyaz
    new RGB(0.15, 0.15, 0.15),  // Siyah derz
    0.3,                        // 30 cm
    0.008,                      // 8 mm ince derz
    1                           // XZ düzlemi (duvar)
);

// Büyük tile, belirgin derz
new CeramicTileTexture(
    new RGB(1,1,1),
    new RGB(0,0,0),
    new RGB(0.2,0.2,0.2),
    1.0,    // 1m x 1m kareler
    0.05,   // 5 cm derz → çok belirgin
    1       // XZ duvar
);
*/
 


// =========================================
// File: /raja/material/AnodizedTexture.java
// =========================================

// Murat Inan
package raja.material;

import java.util.HashMap;

import raja.*;
import raja.shape.*;
import raja.io.*;

public class AnodizedTexture implements Texture, java.io.Serializable, Writable
{
    private RGB baseColor;
    private double reflectivity;
    private double shininess;
    private int ns, nt;
    private double patternScale;
    
    public AnodizedTexture(RGB baseColor, double reflectivity, double shininess, 
      int ns, int nt, double patternScale)
    {
        this.baseColor = baseColor;
        this.reflectivity = reflectivity;
        this.shininess = shininess;
        this.ns = ns;
        this.nt = nt;
        this.patternScale = patternScale;
    }
    
    // Basit constructor - varsayılan değerlerle
    public AnodizedTexture(RGB baseColor)
    {
        this(baseColor, 0.85, 120.0, 600, 1, 0.8);
    }
    
    // Varsayılan constructor
    public AnodizedTexture()
    {
        this(new RGB(0.15, 0.25, 0.75), 0.85, 120.0, 600, 1, 0.8);
    }
    
    // Predefined anodized colors - OPTIMIZED VALUES
    public static AnodizedTexture createAnodizedBlue()
    {
        // Classic anodized blue - deep rich color
        return new AnodizedTexture(new RGB(0.15, 0.25, 0.75), 0.85, 120.0, 600, 1, 0.8);
    }
    
    public static AnodizedTexture createAnodizedRed()
    {
        // Deep anodized red with slight purple undertone
        return new AnodizedTexture(new RGB(0.75, 0.12, 0.18), 0.82, 110.0, 550, 1, 0.9);
    }
    
    public static AnodizedTexture createAnodizedGreen()
    {
        // Rich emerald green
        return new AnodizedTexture(new RGB(0.12, 0.58, 0.25), 0.83, 115.0, 580, 1, 0.85);
    }
    
    public static AnodizedTexture createAnodizedPurple()
    {
        // Deep purple with blue hints
        return new AnodizedTexture(new RGB(0.48, 0.15, 0.72), 0.84, 125.0, 620, 1, 0.75);
    }
    
    public static AnodizedTexture createAnodizedGold()
    {
        // Warm champagne gold
        return new AnodizedTexture(new RGB(0.88, 0.72, 0.18), 0.90, 140.0, 700, 1, 0.6);
    }
    
    public static AnodizedTexture createAnodizedTitanium()
    {
        // Cool titanium gray with subtle rainbow
        return new AnodizedTexture(new RGB(0.42, 0.44, 0.48), 0.88, 130.0, 650, 1, 1.0);
    }
    
    public static AnodizedTexture createAnodizedBlack()
    {
        // Matte black anodized
        return new AnodizedTexture(new RGB(0.08, 0.08, 0.10), 0.75, 90.0, 450, 1, 1.2);
    }
    
    public static AnodizedTexture createAnodizedPink()
    {
        // Rose gold / pink anodized
        return new AnodizedTexture(new RGB(0.82, 0.45, 0.52), 0.86, 125.0, 600, 1, 0.7);
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p)
    {
        // Enhanced thin-film interference pattern
        double filmThickness = calculateFilmThickness(
            p.x * patternScale, 
            p.y * patternScale, 
            p.z * patternScale
        );
        
        // Apply enhanced interference effect
        RGB anodizedColor = applyEnhancedInterference(baseColor, filmThickness);
        
        RGB kr = anodizedColor.multiply(reflectivity);
        
        return new LocalTexture(anodizedColor, kr, new RGB(0.0, 0.0, 0.0), ns, nt);
    }
    
    private double calculateFilmThickness(double x, double y, double z)
    {
        // Multi-scale smooth noise for realistic oxide layer variation
        // Frequencies optimized for natural-looking anodized surface
        
        // Large-scale variation (main color zones)
        double large = Math.sin(x * 0.6) * Math.cos(y * 0.55) * Math.sin(z * 0.5);
        
        // Medium-scale variation (secondary patterns)
        double medium = Math.sin(x * 1.3 + y * 1.1) * 
                       Math.cos(z * 1.5 - x * 0.8) * 
                       Math.sin(y * 1.4 + z * 0.9);
        
        // Fine-scale variation (micro detail)
        double fine = Math.sin(x * 2.8 + z * 2.5) * 
                     Math.cos(y * 3.1 - z * 2.2) *
                     Math.sin(x * 2.9 + y * 2.6);
        
        // Very fine detail (adds texture richness)
        double veryFine = Math.sin(x * 4.5 + y * 4.2 + z * 3.8) *
                         Math.cos(x * 3.9 - y * 4.1);
        
        // Weighted combination for natural appearance
        double thickness = large * 0.45 + 
                          medium * 0.30 + 
                          fine * 0.18 + 
                          veryFine * 0.07;
        
        // Apply smoothstep for more organic transitions
        thickness = thickness * 0.5 + 0.5; // [0, 1]
        return smoothstep(0.0, 1.0, thickness);
    }
    
    private RGB applyEnhancedInterference(RGB base, double thickness)
    {
        double r = base.getR();
        double g = base.getG();
        double b = base.getB();
        
        // Enhanced thin-film interference simulation
        // Phase shifts optimized for realistic anodized appearance
        
        // Red wavelength interference (~650nm)
        double redPhase = thickness * Math.PI * 2.2;
        double redInterference = 0.5 + 0.5 * Math.cos(redPhase);
        
        // Green wavelength interference (~550nm)
        double greenPhase = thickness * Math.PI * 2.6;
        double greenInterference = 0.5 + 0.5 * Math.cos(greenPhase);
        
        // Blue wavelength interference (~450nm)
        double bluePhase = thickness * Math.PI * 3.1;
        double blueInterference = 0.5 + 0.5 * Math.cos(bluePhase);
        
        // Apply interference with enhanced modulation depth
        double interferenceStrength = 0.35; // Increased for more visible effect
        r *= 0.75 + interferenceStrength * redInterference;
        g *= 0.75 + interferenceStrength * greenInterference;
        b *= 0.75 + interferenceStrength * blueInterference;
        
        // Subtle hue shift based on oxide thickness
        // Creates the characteristic anodized color travel
        double t1 = smoothstep(0.0, 0.5, thickness);
        double t2 = smoothstep(0.5, 1.0, thickness);
        
        // Color journey: base -> warmer mid-tones -> cooler highlights
        r *= 0.85 + 0.25 * t2 + 0.10 * Math.sin(thickness * Math.PI);
        g *= 0.90 + 0.15 * t1 - 0.10 * t2;
        b *= 0.95 + 0.20 * (1.0 - t1) + 0.15 * Math.cos(thickness * Math.PI * 1.5);
        
        // Add subtle saturation boost in mid-tones
        double saturationBoost = 1.0 + 0.15 * Math.sin(thickness * Math.PI);
        double avg = (r + g + b) / 3.0;
        r = avg + (r - avg) * saturationBoost;
        g = avg + (g - avg) * saturationBoost;
        b = avg + (b - avg) * saturationBoost;
        
        // Clamp to valid range
        r = Math.max(0.0, Math.min(1.0, r));
        g = Math.max(0.0, Math.min(1.0, g));
        b = Math.max(0.0, Math.min(1.0, b));
        
        return new RGB(r, g, b);
    }
    
    // Enhanced smoothstep with more natural curve
    private double smoothstep(double edge0, double edge1, double x)
    {
        double t = Math.max(0.0, Math.min(1.0, (x - edge0) / (edge1 - edge0)));
        // Smootherstep (Ken Perlin's improved version)
        return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
    }

    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        HashMap map = new HashMap();
        map.put("baseColor", null);
        map.put("reflectivity", new Double(0.85));
        map.put("shininess", new Double(120.0));
        map.put("ns", new Integer(600));
        map.put("nt", new Integer(1));
        map.put("patternScale", new Double(0.8));

        reader.readFields(map);

        return new AnodizedTexture((RGB) map.get("baseColor"),
                                 ((Number) map.get("reflectivity")).doubleValue(),
                                 ((Number) map.get("shininess")).doubleValue(),
                                 ((Number) map.get("ns")).intValue(),
                                 ((Number) map.get("nt")).intValue(),
                                 ((Number) map.get("patternScale")).doubleValue());
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
      String ANODIZED_STR = "Constructor is: AnodizedTexture(RGB baseColor, double reflectivity, double shininess, int ns, int nt, double patternScale);\nExample:\n0.15,0.25,0.75,  0.85,  120.0,  600,  1,  0.8\n-1 return empty constructor.\nEnter your values after three diyez symbol\n###\n";
	  return ANODIZED_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new AnodizedTexture();
			
		String [] split = str.split (",");
		if (split == null) return texture;
		
			//0.15,0.25,0.75,  0.85,  120.0,  600,  1,  0.8
			try {
				double r = Double.parseDouble(split[0]);
				double g = Double.parseDouble(split[1]);
				double b = Double.parseDouble(split[2]);
				
				double rf = Double.parseDouble(split[3]);
				double sh = Double.parseDouble(split[4]);
				
				int ns = Integer.parseInt(split[5]);
				int nt = Integer.parseInt(split[6]);
				
				double pt = Double.parseDouble(split[7]);
				
				texture = new AnodizedTexture(new RGB(r, g, b), rf, sh, ns, nt, pt);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { 
            { "baseColor", baseColor },
            { "reflectivity", new Double(reflectivity) },
            { "shininess", new Double(shininess) },
            { "ns", new Integer(ns) },
            { "nt", new Integer(nt) },
            { "patternScale", new Double(patternScale) }
        };
        writer.writeFields(fields);
    }
    
    // Getter methods
    public RGB getBaseColor() { return baseColor; }
    public double getReflectivity() { return reflectivity; }
    public double getShininess() { return shininess; }
    public int getNs() { return ns; }
    public int getNt() { return nt; }
    public double getPatternScale() { return patternScale; }
    
    // Setter methods
    public void setBaseColor(RGB baseColor) { this.baseColor = baseColor; }
    public void setReflectivity(double reflectivity) { this.reflectivity = reflectivity; }
    public void setShininess(double shininess) { this.shininess = shininess; }
    public void setNs(int ns) { this.ns = ns; }
    public void setNt(int nt) { this.nt = nt; }
    public void setPatternScale(double patternScale) { this.patternScale = patternScale; }
    
}


// =========================================
// File: /raja/material/NordicWeaveTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class NordicWeaveTexture implements Texture, java.io.Serializable, Writable {
    private RGB primaryColor = new RGB(0.55, 0.27, 0.07);   // Kahverengi
    private RGB secondaryColor = new RGB(0.0, 0.39, 0.39);  // Turkuaz
    private RGB accentColor = new RGB(0.86, 0.86, 0.86);    // Açık gri
    private double patternScale = 4.0;
    private double time = 0.0;

    public NordicWeaveTexture() {}

@Override
public LocalTexture getLocalTexture(Point3D p) {
    double x = p.x * patternScale;
    double y = p.y * patternScale;
    double z = p.z * patternScale;
    
    // Viking + Türk dokuma pattern'leri
    double pattern1 = Math.sin(x * 2.0) * Math.cos(y * 2.0);
    double pattern2 = Math.abs(Math.sin(x * 3.0 + y * 3.0));
    double pattern3 = Math.floor(x * 0.5) + Math.floor(y * 0.5);
    
    double combinedPattern = (pattern1 + pattern2 + pattern3 % 2.0) % 3.0;
    
    RGB surfaceColor;
    if (combinedPattern < 1.0) {
        surfaceColor = primaryColor;    // Kahverengi dokuma
    } else if (combinedPattern < 2.0) {
        surfaceColor = secondaryColor;  // Turkuaz dokuma
    } else {
        surfaceColor = accentColor;     // Gümüş gri aksan
    }

    return new LocalTexture(
        surfaceColor,
        new RGB(0.08, 0.08, 0.08),     // Çok düşük reflection
        new RGB(0.0, 0.0, 0.0),        // Işık yok
        15, 
        10
    );
}
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: NordicWeaveTexture();\nPress Set button please.";
    }

    @Override
    public String toExampleString() {
        return "NordicWeaveTexture";
    }

    @Override
    public Texture getInstance(String info) {
        return new NordicWeaveTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"primaryColor", primaryColor},
            {"secondaryColor", secondaryColor},
            {"accentColor", accentColor},
            {"patternScale", Double.valueOf(patternScale)},
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new NordicWeaveTexture();
    }
}


// =========================================
// File: /raja/material/TurkishTileTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

public class TurkishTileTexture implements Texture, java.io.Serializable, Writable {
    private RGB baseColor;
    private RGB patternColor;
    private double tileSize;
    private int plane; // 0: XY, 1: XZ, 2: YZ

    // Phong/seramik malzeme sabitleri
    private static final double AMBIENT_FACTOR = 0.4;
    private static final double SPECULAR_FACTOR = 0.8;
    private static final RGB SPECULAR_COLOR = new RGB(1.0, 1.0, 1.0);
    private static final int REFLECTIVITY = 3;
    private static final int SHININESS = 80;

    // Varsayılan kurucu
    public TurkishTileTexture() {
        this(
            new RGB(0.0, 0.4, 0.8),   // Mavi
            new RGB(1.0, 1.0, 1.0),   // Beyaz
            2.0,                      // Varsayılan tile boyutu
            0                         // XY düzlemi
        );
    }

    public TurkishTileTexture(RGB baseColor, RGB patternColor, double tileSize) {
        this(baseColor, patternColor, tileSize, 0);
    }

    public TurkishTileTexture(RGB baseColor, RGB patternColor, double tileSize, int plane) {
        this.baseColor = baseColor;
        this.patternColor = patternColor;
        this.tileSize = Math.max(0.5, tileSize);
        this.plane = plane;
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double u, v;

        // Düzlem seçimi
        switch (plane) {
            case 1: // XZ - duvar
                u = p.x;
                v = p.z;
                break;
            case 2: // YZ - yan duvar
                u = p.y;
                v = p.z;
                break;
            default: // XY - zemin
                u = p.x;
                v = p.y;
                break;
        }

        // Tile büyüklüğünü ayarla (NorwegianRose ile tutarlı)
        u = u / tileSize;
        v = v / tileSize;

        // Tile içi koordinatlar [0,1)
        double tileU = u - Math.floor(u);
        double tileV = v - Math.floor(v);

        // Desen rengini hesapla
        RGB surfaceColor = createCleanTurkishPattern(tileU, tileV);

        // Seramik malzeme özellikleri
        RGB ambient = surfaceColor.multiply(AMBIENT_FACTOR);
        RGB diffuse = surfaceColor;
        RGB specular = SPECULAR_COLOR.multiply(SPECULAR_FACTOR);

        return new LocalTexture(
            diffuse,
            ambient,
            specular,
            SHININESS,
            REFLECTIVITY
        );
    }

    private RGB createCleanTurkishPattern(double u, double v) {
        // 1. Kenarlık (10%)
        double border = 0.1;
        if (u < border || u > 1.0 - border || v < border || v > 1.0 - border) {
            return patternColor;
        }

        // 2. Merkezde sekiz yapraklı çiçek
        double centerX = 0.5;
        double centerY = 0.5;
        double dx = u - centerX;
        double dy = v - centerY;
        double dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 0.2) {
            if (dist < 0.05) {
                return patternColor; // Katı merkez
            }
            double angle = Math.atan2(dy, dx);
            double petal = Math.abs(Math.sin(4 * angle)); // 8 yaprak
            if (petal > 0.7 && dist > 0.05 && dist < 0.18) {
                return patternColor;
            }
        }

        // 3. Keskin geometrik çizgiler
        if (Math.abs(u - v) < 0.02 || Math.abs(u + v - 1.0) < 0.02) {
            return patternColor; // Çaprazlar
        }
        if (Math.abs(u - 0.5) < 0.015 || Math.abs(v - 0.5) < 0.015) {
            return patternColor; // Dikey/yatay eksenler
        }

        // 4. Köşe süslemeleri (basitleştirilmiş)
        double[][] corners = {
            {0.2, 0.2}, {0.8, 0.2}, 
            {0.2, 0.8}, {0.8, 0.8}
        };
        
        for (double[] corner : corners) {
            double cx = corner[0];
            double cy = corner[1];
            double cdx = u - cx;
            double cdy = v - cy;
            double cornerDist = Math.sqrt(cdx * cdx + cdy * cdy);
            
            if (cornerDist < 0.08) {
                double angle = Math.atan2(cdy, cdx);
                double star = Math.abs(Math.sin(4 * angle));
                if (star > 0.8) {
                    return patternColor;
                }
            }
        }

        return baseColor;
    }

    // --- IO Desteği ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("baseColor", null);
        map.put("patternColor", null);
        map.put("tileSize", 2.0);
        map.put("plane", 0);

        reader.readFields(map);

        return new TurkishTileTexture(
            (RGB) map.get("baseColor"),
            (RGB) map.get("patternColor"),
            ((Number) map.get("tileSize")).doubleValue(),
            ((Number) map.get("plane")).intValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//TurkishTileTexture(RGB baseColor, RGB patternColor, double tileSize, int plane)
		//0.0,0.4,0.8,  1,1,1,  0.2,  0|1|2(xyPlane/xz/yzSphere)
		String TURKISHTILE_STR="Constructor is: TurkishTileTexture(RGB baseColor, RGB patternColor, double tileSize, int plane);\nExample:\n0.0,0.4,0.8,  1,1,1,  20.0, 0|1|2(xy/xz/yz)\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return TURKISHTILE_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new TurkishTileTexture();
		
		String [] split = str.split (",");
		if (split == null) return texture;

		//TurkishTileTexture(RGB baseColor, RGB patternColor, double tileSize, int plane)
		//0.0,0.4,0.8,  1,1,1,  20.0, 0|1|2(xy/xz/yz)
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double sc = Double.parseDouble(split[6]);
				
				int pl = Integer.parseInt(split[7]);

				texture = new TurkishTileTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					sc, pl);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseColor", baseColor},
            {"patternColor", patternColor},
            {"tileSize", tileSize},
            {"plane", plane}
        };
        writer.writeFields(fields);
    }

    // --- Getter'lar ---
    public RGB getBaseColor() { return baseColor; }
    public RGB getPatternColor() { return patternColor; }
    public double getTileSize() { return tileSize; }
    public int getPlane() { return plane; }
    
}

/**
// Klasik mavi-beyaz Türk seramik zemini
Texture floor = new TurkishTileTexture(
    new RGB(0.0, 0.4, 0.8),   // Mavi
    new RGB(1.0, 1.0, 1.0),   // Beyaz
    2.0,                      // Tile boyutu
    0                         // XY düzlemi
);

// Büyük desenli zemin
Texture largeTile = new TurkishTileTexture(
    new RGB(0.0, 0.4, 0.8),
    new RGB(1.0, 1.0, 1.0),
    4.0                       // Daha büyük tile
);

// Duvara uygulamak için
Texture wall = new TurkishTileTexture(
    new RGB(0.8, 0.2, 0.2),   // Kırmızı
    new RGB(1.0, 1.0, 1.0),   // Beyaz
    1.5,                      // Küçük desenler
    1                         // XZ düzlemi
);
*/


// =========================================
// File: /raja/material/XPlainTexture.java
// =========================================

/* $Id: XPlainTexture.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.material;

import raja.Point3D;
import raja.RGB;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;


public class XPlainTexture implements Texture, java.io.Serializable, Writable
{
	private RGB kd = RGB.red;
	private RGB krl = RGB.green;
	private RGB krg = RGB.blue;
	private RGB ktl = RGB.magenta;
	private RGB ktg = RGB.yellow;
	int ns = 40;
	int nt = 10;
	
    public XPlainTexture()
    {}
	
	public XPlainTexture(RGB kd, RGB krl, RGB krg, RGB ktl, RGB ktg, int ns, int nt)
	{
		this.kd = kd;
		this.krl = krl;
		this.krg = krg;
		this.ktl = ktl;
		this.ktg = ktg;
		this.ns = ns;
		this.nt = nt;
	}
	
    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
        return new XPlainTexture();
    }
	
	@Override
    public LocalTexture getLocalTexture(Point3D p)
    {
		LocalTexture lcl = new LocalTexture(
			this.kd, 
			this.krl, 
			this.krg, 
			this.ktl, 
			this.ktg, 
			this.ns, 
			this.nt
		);

        return lcl;
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//XPlainTexture(RGB kd, RGB krl, RGB krg, RGB ktl, RGB ktg, int ns, int nt)
		//0.0,0.0,0.0,  0.0,1.0,0.0,  0.0,0.0,1.0,  0.3,0.3,0.3,  0.1,0.1,0.1,  40, 10
		String PLAIN_STR="Constructor is: XPlainTexture(RGB kd, RGB krl, RGB krg, RGB ktl, RGB ktg, int ns, int nt);\nExample:\n0.0,0.0,0.0,  0.0,0.0,0.0,  0.0,0.0,0.0,  0.9,0.9,0.9,  0.9,0.9,0.9,  100, 10\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return PLAIN_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new XPlainTexture();
		
		String [] split = str.split (",");
		if (split == null) return texture;

		//XPlainTexture(RGB kd, RGB krl, RGB krg, RGB ktl, RGB ktg, int ns, int nt)
		//1.0,0.0,0.0,  0.0,1.0,0.0,  0.0,0.0,1.0,  0.3,0.3,0.3,  0.1,0.1,0.1,  40, 10
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double c3r = Double.parseDouble(split[6]);
				double c3g = Double.parseDouble(split[7]);
				double c3b = Double.parseDouble(split[8]);
				
				double c4r = Double.parseDouble(split[9]);
				double c4g = Double.parseDouble(split[10]);
				double c4b = Double.parseDouble(split[11]);
				
				double c5r = Double.parseDouble(split[12]);
				double c5g = Double.parseDouble(split[13]);
				double c5b = Double.parseDouble(split[14]);
								
				int ns = Integer.parseInt(split[15]);
				int nt = Integer.parseInt(split[16]);
					
				texture = new XPlainTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					new RGB(c3r, c3g, c3b),
					new RGB(c4r, c4g, c4b),
					new RGB(c5r, c5g, c5b),
					ns, nt);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    public String toString()
    {
        return "";
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
    }
    
}


// =========================================
// File: /raja/material/AnisotropicMetalTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class AnisotropicMetalTexture implements Texture, java.io.Serializable, Writable {
    private RGB metalColor;
    private double anisotropy;
    private double roughnessX;
    private double roughnessY;
    
    // Default constructor
    public AnisotropicMetalTexture() {
        this(new RGB(0.7, 0.7, 0.75),    // Silver-gray metal
             0.8,                        // Anisotropy strength
             0.1,                        // Roughness in X direction
             0.4);                       // Roughness in Y direction
    }
    
    // Custom constructor
    public AnisotropicMetalTexture(RGB metalColor, double anisotropy, double roughnessX, double roughnessY) {
        this.metalColor = metalColor;
        this.anisotropy = anisotropy;
        this.roughnessX = roughnessX;
        this.roughnessY = roughnessY;
    }
    
    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Anisotropic effect - brush strokes pattern
        double brushPattern = Math.sin(p.x * 50) * anisotropy;
        double anisotropicEffect = (brushPattern + 1) * 0.5;
        
        RGB surfaceColor = metalColor.multiply(0.8 + anisotropicEffect * 0.4);
        
        return new LocalTexture(
            surfaceColor,
            surfaceColor.multiply(0.3),  // Medium ambient
            new RGB(0.8, 0.8, 0.85),     // High metallic specular
            80,                          // High shininess
            1
        );
    }
    
    // IO methods
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("metalColor", new RGB(0.7, 0.7, 0.75));
        map.put("anisotropy", 0.8);
        map.put("roughnessX", 0.1);
        map.put("roughnessY", 0.4);

        reader.readFields(map);

        return new AnisotropicMetalTexture(
            (RGB) map.get("metalColor"),
            ((Number) map.get("anisotropy")).doubleValue(),
            ((Number) map.get("roughnessX")).doubleValue(),
            ((Number) map.get("roughnessY")).doubleValue()
        );
    }

    @Override
    public String getUsageInformation() {
        String ANISOTROPIC_STR = "Constructor: AnisotropicMetalTexture(RGB metalColor, double anisotropy, double roughnessX, double roughnessY)\n" +
                                "Examples:\n" +
                                "-1                             # Default anisotropic metal\n" +
                                "0.7,0.7,0.75,  0.8,  0.1,   0.4      # Brushed silver\n" +
                                "0.9,0.8,0.5,   0.6,  0.05,  0.2      # Brushed gold\n" +
                                "Enter values after ###\n###\n";
        return ANISOTROPIC_STR;
    }

    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        Texture texture = null;
        
        String str = info.trim();
        
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return texture;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "");
        str = str.replaceAll(" ", "");
        
        if (str.equals("-1")) return new AnisotropicMetalTexture();
        
        String[] split = str.split(",");
        if (split == null || split.length != 6) return texture;
        
        try {
            double r = Double.parseDouble(split[0]);
            double g = Double.parseDouble(split[1]);
            double b = Double.parseDouble(split[2]);
            double anisotropy = Double.parseDouble(split[3]);
            double roughX = Double.parseDouble(split[4]);
            double roughY = Double.parseDouble(split[5]);
            
            texture = new AnisotropicMetalTexture(
                new RGB(r, g, b),
                anisotropy,
                roughX,
                roughY
            );
            return texture;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"metalColor", metalColor},
            {"anisotropy", anisotropy},
            {"roughnessX", roughnessX},
            {"roughnessY", roughnessY}
        };
        writer.writeFields(fields);
    }

    // Getters
    public RGB getMetalColor() { return metalColor; }
    public double getAnisotropy() { return anisotropy; }
    public double getRoughnessX() { return roughnessX; }
    public double getRoughnessY() { return roughnessY; }
}


// =========================================
// File: /raja/material/MarbleTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

public class MarbleTexture implements Texture, java.io.Serializable, Writable {
    private RGB veinColor;
    private RGB baseColor;
    private double scale;
    private int turbulenceLayers;
    private double turbulenceScale;

    // Phong parameters for polished stone
    private static final double AMBIENT_FACTOR = 0.3;
    private static final double SPECULAR_FACTOR = 0.7;
    private static final RGB SPECULAR_COLOR = new RGB(1.0, 1.0, 1.0);
    private static final int REFLECTIVITY = 4;
    private static final int SHININESS = 200;

    public MarbleTexture() {
        this(
            new RGB(0.9, 0.9, 0.9),   // base
            new RGB(0.3, 0.3, 0.4),   // vein
            4.0,
            4,
            2.0
        );
    }

    public MarbleTexture(RGB baseColor, RGB veinColor, double scale, int turbulenceLayers, double turbulenceScale) {
        this.baseColor = baseColor;
        this.veinColor = veinColor;
        this.scale = Math.max(0.1, scale);
        this.turbulenceLayers = Math.max(1, turbulenceLayers);
        this.turbulenceScale = Math.max(0.1, turbulenceScale);
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double u = p.x * scale;
        double v = p.y * scale;
        double w = p.z * scale;

        // Turbulence (simple noise approximation)
        double t = turbulence(u, v, w);

        // Sinus wave + turbulence -> veines
        double marble = Math.sin(u + t) * 0.5 + 0.5;

        // clear veines
        RGB color;
        if (marble < 0.3) {
            color = veinColor;
        } else if (marble < 0.7) {
            double blend = (marble - 0.3) / 0.4;
            color = RGB.interpolate(veinColor, baseColor, blend);
        } else {
            color = baseColor;
        }

        return new LocalTexture(
            color,
            color.multiply(AMBIENT_FACTOR),
            SPECULAR_COLOR.multiply(SPECULAR_FACTOR),
            SHININESS,
            REFLECTIVITY
        );
    }

    private double turbulence(double x, double y, double z) {
        double value = 0.0;
        double scale = 1.0;
        for (int i = 0; i < turbulenceLayers; i++) {
            value += noise(x * scale, y * scale, z * scale) / scale;
            scale *= turbulenceScale;
        }
        return value;
    }

    //Simple noise function 
    private double noise(double x, double y, double z) {
        int X = (int) Math.floor(x) & 255;
        int Y = (int) Math.floor(y) & 255;
        int Z = (int) Math.floor(z) & 255;

        // Deterministic "random" value
        long hash = (X * 73856093L) ^ (Y * 19349663L) ^ (Z * 83492791L);
        return (double)(hash % 256) / 256.0;
    }

    // --- IO Support ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("baseColor", null);
        map.put("veinColor", null);
        map.put("scale", 4.0);
        map.put("turbulenceLayers", 4);
        map.put("turbulenceScale", 2.0);

        reader.readFields(map);

        return new MarbleTexture(
            (RGB) map.get("baseColor"),
            (RGB) map.get("veinColor"),
            ((Number) map.get("scale")).doubleValue(),
            ((Number) map.get("turbulenceLayers")).intValue(),
            ((Number) map.get("turbulenceScale")).doubleValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//MarbleTexture(RGB baseColor, RGB veinColor, double scale, int turbulenceLayers, double turbulenceScale)
		String MARBLE_STR="Constructor is: MarbleTexture(RGB baseColor, RGB veinColor, double scale, int turbulenceLayers, double turbulenceScale);\nExample:\n0.85,0.9,0.85,  0.2,0.4,0.3,  6.0,  5,  2.5\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return MARBLE_STR;
	}
	
   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new MarbleTexture();
		
		String [] split = str.split (",");
		if (split == null) return texture;

		//MarbleTexture(RGB baseColor, RGB veinColor, double scale,
		//int turbulenceLayers, double turbulenceScale);
		//Example:\n0.85,0.9,0.85,  0.2,0.4,0.3,  6.0,  5,  2.5
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double sc = Double.parseDouble(split[6]);
				
				int tl = Integer.parseInt(split[7]);
				
				double ts = Double.parseDouble(split[8]);
								
				texture = new MarbleTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					sc, tl, ts);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseColor", baseColor},
            {"veinColor", veinColor},
            {"scale", scale},
            {"turbulenceLayers", turbulenceLayers},
            {"turbulenceScale", turbulenceScale}
        };
        writer.writeFields(fields);
    }

    // --- Getters ---
    public RGB getBaseColor() { return baseColor; }
    public RGB getVeinColor() { return veinColor; }
    public double getScale() { return scale; }
    public int getTurbulenceLayers() { return turbulenceLayers; }
    public double getTurbulenceScale() { return turbulenceScale; }
    
}

/**
Texture whiteMarble = new MarbleTexture();

Texture greenMarble = new MarbleTexture(
    new RGB(0.85, 0.9, 0.85),
    new RGB(0.2, 0.4, 0.3),
    6.0, 5, 2.5
);
*/


// =========================================
// File: /raja/material/KilimRosemalingTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class KilimRosemalingTexture implements Texture, java.io.Serializable, Writable {
    private RGB kilimColor = new RGB(0.77, 0.0, 0.0);      // Kırmızı kilim
    private RGB rosemalingColor = new RGB(0.0, 0.39, 0.39); // Turkuaz rosemaling
    private RGB accentColor = new RGB(1.0, 0.84, 0.0);     // Altın sarısı aksan
    private double time = 0.0;

    public KilimRosemalingTexture() {}

    @Override
public LocalTexture getLocalTexture(Point3D p) {
    double x = p.x * 12.0;
    double y = p.y * 12.0;
    double z = p.z * 12.0;
    
    // Basitleştirilmiş kültürel pattern'ler
    double kilimPattern1 = Math.abs(Math.sin(x * 2.0) + Math.cos(y * 2.0));
    double kilimPattern2 = (Math.floor(x * 1.2) + Math.floor(y * 1.2)) % 2.0;
    
    double rosePattern1 = Math.sin(x * 1.5) * Math.cos(y * 1.5 + Math.sin(z * 0.8));
    double rosePattern2 = Math.abs(Math.sin(x * 2.5 + y * 1.8) + Math.cos(y * 2.2));
    
    // Kültürel fusion pattern
    double combinedPattern = (kilimPattern1 * 0.3 + kilimPattern2 * 0.2 + 
                             rosePattern1 * 0.3 + rosePattern2 * 0.2);
    double normalizedPattern = (combinedPattern + 1.0) * 0.5;
    
    RGB surfaceColor;
    if (normalizedPattern < 0.3) {
        // Kilim arkaplan
        surfaceColor = kilimColor;
    } else if (normalizedPattern < 0.6) {
        // Rosemaling çiçek desenleri
        double intensity = (normalizedPattern - 0.3) / 0.3;
        surfaceColor = blendColors(rosemalingColor, lightenColor(rosemalingColor, 0.2), intensity);
    } else if (normalizedPattern < 0.8) {
        // Altın aksan detaylar
        surfaceColor = accentColor;
    } else {
        // Kenar bordürler
        double intensity = (normalizedPattern - 0.8) / 0.2;
        RGB borderColor = blendColors(kilimColor, rosemalingColor, 0.5);
        surfaceColor = darkenColor(borderColor, intensity * 0.4);
    }

    return new LocalTexture(
        surfaceColor,
        new RGB(0.1, 0.1, 0.1), // Düşük reflection
        new RGB(0.0, 0.0, 0.0), // Işık yok
        25, 
        10
    );
}
    
    // Basit color utility fonksiyonları
    private RGB blendColors(RGB color1, RGB color2, double ratio) {
        return new RGB(
            color1.getR() * (1 - ratio) + color2.getR() * ratio,
            color1.getG() * (1 - ratio) + color2.getG() * ratio,
            color1.getB() * (1 - ratio) + color2.getB() * ratio
        );
    }
    
    private RGB lightenColor(RGB color, double amount) {
        return new RGB(
            Math.min(1.0, color.getR() + amount),
            Math.min(1.0, color.getG() + amount),
            Math.min(1.0, color.getB() + amount)
        );
    }
    
    private RGB darkenColor(RGB color, double amount) {
        return new RGB(
            Math.max(0.0, color.getR() - amount),
            Math.max(0.0, color.getG() - amount),
            Math.max(0.0, color.getB() - amount)
        );
    }
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: KilimRosemalingTexture();\nPress Set button please.";
    }

    @Override
    public String toExampleString() {
        return "KilimRosemalingTexture";
    }

    @Override
    public Texture getInstance(String info) {
        return new KilimRosemalingTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"kilimColor", kilimColor},
            {"rosemalingColor", rosemalingColor},
            {"accentColor", accentColor},
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new KilimRosemalingTexture();
    }
}


// =========================================
// File: /raja/material/PatternTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;

import java.util.HashMap;

public class PatternTexture implements Texture, java.io.Serializable, Writable {

    private RGB primaryColor = new RGB(1.0, 0.84, 0.0);
    private RGB secondaryColor = new RGB(1.0, 1.0, 0.59);
    private RGB borderColor = new RGB(0.0, 0.0, 0.0);
    private RGB kr = new RGB(0.0, 0.0, 0.0);
    private RGB kt = new RGB(0.5, 0.5, 0.5);
    private double cellSize = 0.5;
    private double borderWidth = 0.05;
    private int ns = 100;
    private int nt = 10;

    public PatternTexture(RGB primary, RGB secondary, RGB borderColor, RGB kt,
                         double cellSize, double borderWidth, int ns, int nt) {
        this.primaryColor = primary;
        this.secondaryColor = secondary;
        this.borderColor = borderColor;
        this.kr = borderColor;
        this.kt = kt;
        this.cellSize = Math.max(0.05, cellSize);
        this.borderWidth = Math.max(0, Math.min(0.5, borderWidth));
        this.ns = ns;
        this.nt = nt;
    }

    public PatternTexture(RGB primary, RGB secondary, double cellSize, double borderWidth) {
        this(primary, secondary, new RGB(0.0, 0.0, 0.0), new RGB(0.5, 0.5, 0.5), 
              cellSize, borderWidth, 100, 10);
    }

    public PatternTexture() {}

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double angle = Math.toRadians(30.0);
        double cosA = Math.cos(angle);
        double sinA = Math.sin(angle);

        double px = p.x;
        double py = p.y;
        double pz = p.z;

        double x = (px * cosA - pz * sinA) / cellSize;
        double z = (px * sinA + pz * cosA) / cellSize;
        double y = py / cellSize * 0.5;

        x += Math.sin(y * Math.PI) * 0.25;
        z += Math.cos(y * Math.PI * 0.5) * 0.25;

        double sqrt3 = Math.sqrt(3.0);
        double q = (2.0 / 3.0) * x;
        double r = (-1.0 / 3.0) * x + (sqrt3 / 3.0) * z;

        double cubeX = q;
        double cubeZ = r;
        double cubeY = -cubeX - cubeZ;

        int rx = (int) Math.round(cubeX);
        int ry = (int) Math.round(cubeY);
        int rz = (int) Math.round(cubeZ);

        double xDiff = Math.abs(rx - cubeX);
        double yDiff = Math.abs(ry - cubeY);
        double zDiff = Math.abs(rz - cubeZ);

        if (xDiff > yDiff && xDiff > zDiff) {
            rx = -ry - rz;
        } else if (yDiff > zDiff) {
            ry = -rx - rz;
        } else {
            rz = -rx - ry;
        }

        double hexCenterX = (3.0 / 2.0) * rx;
        double hexCenterZ = (sqrt3 / 2.0) * rx + sqrt3 * rz;

        double dx = x - hexCenterX;
        double dz = z - hexCenterZ;
        double distance = Math.sqrt(dx * dx + dz * dz);

        double hexRadius = 1.0;
        boolean isBorder = distance > (hexRadius - borderWidth * 2);
        boolean isEven = ((rx - rz) % 2 == 0);
        RGB surfaceColor = isBorder ? borderColor : (isEven ? primaryColor : secondaryColor);

        return new LocalTexture(surfaceColor, kr, kt, ns, nt);
    }

    @Override
    public String getUsageInformation() {
        return "Constructor: PatternTexture(RGB primary, RGB secondary, RGB borderColor, RGB kt, " +
               "double cellSize, double borderWidth, int ns, int nt);\n" +
               "-1 returns default constructor.\n" +
               "Example:\n1.0,0.84,0.0,  1.0,1.0,0.59,  0.0,0.0,0.0,  0.5,0.5,0.5,  0.5,  0.05,  100,  10\n" +
               "Mark parameters after ###\n";
    }

    private String exampleString = "null";

    @Override
    public String toExampleString() {
        return this.exampleString;
    }

    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        String str = info.trim();
        int idx = str.lastIndexOf("###");
        if (idx < 0) return new PatternTexture();

        str = str.substring(idx + 3).replaceAll("[\\n\\s]", "");
        if (str.equals("-1")) return new PatternTexture();

        String[] s = str.split(",");
        if (s.length < 16) return new PatternTexture();

        try {
            double pR = Double.parseDouble(s[0]);
            double pG = Double.parseDouble(s[1]);
            double pB = Double.parseDouble(s[2]);
            double sR = Double.parseDouble(s[3]);
            double sG = Double.parseDouble(s[4]);
            double sB = Double.parseDouble(s[5]);
            double bR = Double.parseDouble(s[6]);
            double bG = Double.parseDouble(s[7]);
            double bB = Double.parseDouble(s[8]);
            double ktR = Double.parseDouble(s[9]);
            double ktG = Double.parseDouble(s[10]);
            double ktB = Double.parseDouble(s[11]);
            double cS = Double.parseDouble(s[12]);
            double bW = Double.parseDouble(s[13]);
            int ns = Integer.parseInt(s[14]);
            int nt = Integer.parseInt(s[15]);

            return new PatternTexture(
                new RGB(pR, pG, pB),
                new RGB(sR, sG, sB),
                new RGB(bR, bG, bB),
                new RGB(ktR, ktG, ktB),
                cS, bW, ns, nt
            );
        } catch (Exception e) {
            e.printStackTrace();
            return new PatternTexture();
        }
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        writer.write("// Pattern Texture\n");
        Object[][] fields = {
            {"primaryColor", primaryColor},
            {"secondaryColor", secondaryColor},
            {"borderColor", borderColor},
            {"kr", kr},
            {"kt", kt},
            {"cellSize", Double.valueOf(cellSize)},
            {"borderWidth", Double.valueOf(borderWidth)},
            {"ns", Integer.valueOf(ns)},
            {"nt", Integer.valueOf(nt)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("primaryColor", null);
        map.put("secondaryColor", null);
        map.put("borderColor", null);
        map.put("kr", null);
        map.put("kt", null);
        map.put("cellSize", Double.valueOf(0.5));
        map.put("borderWidth", Double.valueOf(0.05));
        map.put("ns", Integer.valueOf(100));
        map.put("nt", Integer.valueOf(10));

        reader.readFields(map);

        return new PatternTexture(
            (RGB) map.get("primaryColor"),
            (RGB) map.get("secondaryColor"),
            (RGB) map.get("borderColor"),
            (RGB) map.get("kt"),
            ((Number) map.get("cellSize")).doubleValue(),
            ((Number) map.get("borderWidth")).doubleValue(),
            ((Number) map.get("ns")).intValue(),
            ((Number) map.get("nt")).intValue()
        );
    }
    
}


// =========================================
// File: /raja/material/TiledRoofTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

/**
 * TiledRoofTexture simulates traditional curved clay roof tiles arranged in
 * staggered horizontal rows. The pattern uses smooth color transitions between
 * tile and gap regions, with subtle ambient/specular properties to mimic sun-baked clay.
 * 
 * This texture is designed for vertical surfaces (e.g., facades) or roofs aligned
 * with the XZ plane. It assumes the Y-axis points upward.
 */
public class TiledRoofTexture implements Texture, java.io.Serializable, Writable {
    private RGB tileColor;
    private RGB gapColor;
    private double scale;
    private double tileHeightRatio;

    // Phong lighting parameters for matte, non-reflective clay
    private static final double AMBIENT_FACTOR = 0.4;
    private static final double SPECULAR_FACTOR = 0.1;
    private static final RGB SPECULAR_COLOR = new RGB(0.8, 0.75, 0.7);
    private static final int REFLECTIVITY = 5;
    private static final int SHININESS = 10;

    /**
     * Constructs a default TiledRoofTexture with warm terracotta tiles.
     */
    public TiledRoofTexture() {
        this(
            new RGB(0.7, 0.3, 0.25),   // classic red-orange clay
            new RGB(0.5, 0.25, 0.2),   // slightly darker gaps
            12.0,
            0.6
        );
    }

    /**
     * Constructs a TiledRoofTexture with custom parameters.
     *
     * @param tileColor        Main color of the roof tiles.
     * @param gapColor         Color of the gaps between tiles (mortar or shadow).
     * @param scale            Controls tile density (higher = more tiles per unit).
     * @param tileHeightRatio  Ratio of tile height to total row height (0.0–1.0).
     */
    public TiledRoofTexture(RGB tileColor, RGB gapColor, double scale, double tileHeightRatio) {
        this.tileColor = tileColor;
        this.gapColor = gapColor;
        this.scale = Math.max(0.1, scale);
        this.tileHeightRatio = Math.min(1.0, Math.max(0.1, tileHeightRatio));
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Work in XZ plane: tiles run horizontally along X, stacked along Z (Y is up in world)
        double x = p.x * scale;
        double z = p.z * scale;

        // Row index (each row is one tile height + gap)
        double row = Math.floor(z);
        double localZ = z - row;

        // Alternate offset every other row for staggered layout
        double xOffset = (row % 2 == 0) ? 0.0 : 0.5;
        double localX = (x + xOffset) % 1.0;

        // Define tile region: occupies [0, tileHeightRatio) in Z and full width in X
        double blend = 1.0;
        if (localZ < tileHeightRatio) {
            // Inside a tile row
            blend = 1.0;
        } else {
            // In the gap between rows
            blend = 0.0;
        }

        // Smooth transition at tile/gap boundary (optional soft edge)
        double edge = 0.02;
        if (localZ > tileHeightRatio - edge && localZ < tileHeightRatio + edge) {
            double t = (localZ - (tileHeightRatio - edge)) / (2 * edge);
            blend = 1.0 - Math.min(1.0, Math.max(0.0, t));
        }

        RGB color = RGB.interpolate(gapColor, tileColor, blend);

        return new LocalTexture(
            color,
            color.multiply(AMBIENT_FACTOR),
            SPECULAR_COLOR.multiply(SPECULAR_FACTOR),
            SHININESS,
            REFLECTIVITY
        );
    }

    // --- IO Support ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("tileColor", null);
        map.put("gapColor", null);
        map.put("scale", 12.0);
        map.put("tileHeightRatio", 0.6);

        reader.readFields(map);

        return new TiledRoofTexture(
            (RGB) map.get("tileColor"),
            (RGB) map.get("gapColor"),
            ((Number) map.get("scale")).doubleValue(),
            ((Number) map.get("tileHeightRatio")).doubleValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//TiledRoofTexture(RGB tileColor, RGB gapColor, double scale, double tileHeightRatio)
		//0.7,0.3,0.2,  0.4,0.2,0.1,  10.0, 0.6
		String TILEDROOF_STR="Constructor is: TiledRoofTexture(RGB tileColor, RGB gapColor, double scale, double tileHeightRatio);\nExample:\n0.7,0.3,0.2,  0.4,0.2,0.1,  10.0, 0.6\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return TILEDROOF_STR;
	}
	
   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new TiledRoofTexture();
		
		String [] split = str.split (",");
		if (split == null) return texture;

		//TiledRoofTexture(RGB tileColor, RGB gapColor, double scale, double tileHeightRatio)
		//0.7,0.3,0.2,  0.4,0.2,0.1,  10.0, 0.6
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double sc = Double.parseDouble(split[6]);
				double th = Double.parseDouble(split[7]);

				texture = new TiledRoofTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					sc, th);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"tileColor", tileColor},
            {"gapColor", gapColor},
            {"scale", scale},
            {"tileHeightRatio", tileHeightRatio}
        };
        writer.writeFields(fields);
    }

    // --- Getters ---
    public RGB getTileColor() { return tileColor; }
    public RGB getGapColor() { return gapColor; }
    public double getScale() { return scale; }
    public double getTileHeightRatio() { return tileHeightRatio; }
    
}

/**
TiledRoofTexture trt = new TiledRoofTexture();

TiledRoofTexture trt = new TiledRoofTexture(
    new RGB(0.75, 0.35, 0.2),   // tile color (warm terracotta)
    new RGB(0.45, 0.25, 0.15),  // gap color (darker mortar)
    10.0,                       // scale (tiles per unit)
    0.65                        // tile height ratio
);
*/


// =========================================
// File: /raja/material/XDamierTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class XDamierTexture implements Texture, java.io.Serializable, Writable
{
    private RGB kd1, kd2, kr, kt;
    private int ns, nt;
    private double step, x0, y0;
    
    public XDamierTexture(RGB kd1, RGB kd2, RGB kr, RGB kt, int ns, int nt, double step, double x0, double y0)
    {
	this.kd1 = kd1;
	this.kd2 = kd2;
	this.kr = kr;
	this.kt = kt;
	this.ns = ns;
	this.nt = nt;
        this.step = step;
        this.x0 = x0;
        this.y0 = y0;
    }

    /**
     * Builds the object LocalTexture from a StreamLexer.
     */
    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("kdUn",null);
	map.put("kdDeux",null);
	map.put("kr",null);
	map.put("kt",null);
	map.put("ns",null);
	map.put("nt",null);
	map.put("step",null);
	map.put("x",null);
	map.put("y",null);

	/* Parsing */
	reader.readFields(map);

        return new XDamierTexture((RGB) map.get("kdUn"),
                                 (RGB) map.get("kdDeux"),
                                 (RGB) map.get("kr"),
                                 (RGB) map.get("kt"),
                                 ((Number) map.get("ns")).intValue(),
                                 ((Number) map.get("nt")).intValue(),
                                 ((Number) map.get("step")).doubleValue(),
                                 ((Number) map.get("x")).doubleValue(),
                                 ((Number) map.get("y")).doubleValue());
    }
	
	@Override
    public LocalTexture getLocalTexture(Point3D p)
    {
	double i = Math.floor((p.x - x0) / step);
	double j = Math.floor((p.y - y0) / step);

	if ((i - j) % 2 == 0) {
	    return new LocalTexture(kd1, kr, kt, ns, nt);
	}
	else {
	    return new LocalTexture(kd2, kr, kt, ns, nt);
	}
    }
    
    // ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		String DAMIER_STR="Constructor is: XDamierTexture(RGB kd1, RGB kd2, RGB kr, RGB kt, int ns, int nt, double step, double x0, double y0);\nExample:\n1.0,1.0,1.0,  0.0,0.0,0.0,  0.0,1.0,0.0,  0.5,0.5,0.5,  100, 10, 4.5, 0.0, 0.0\nEnter your values after three diyez symbol\n###\n";
		return DAMIER_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return texture;
		
			//1.0,1.0,1.0,  0.0,0.0,0.0,  0.0,1.0,0.0,  0.5,0.5,0.5,  
			//100, 10, 
			//0.5, 0.0, 0.0
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double c3r = Double.parseDouble(split[6]);
				double c3g = Double.parseDouble(split[7]);
				double c3b = Double.parseDouble(split[8]);
				
				double c4r = Double.parseDouble(split[9]);
				double c4g = Double.parseDouble(split[10]);
				double c4b = Double.parseDouble(split[11]);
				
				int ns = Integer.parseInt(split[12]);
				int nt = Integer.parseInt(split[13]);
				
				double step = Double.parseDouble(split[14]);
				double ud = Double.parseDouble(split[15]);
				double vd = Double.parseDouble(split[16]);
				
				texture = new XDamierTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					new RGB(c3r, c3g, c3b),
					new RGB(c4r, c4g, c4b),
					ns, nt, step, ud, vd);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "kdUn", kd1 },
                              { "kdDeux", kd2 },
                              { "kr", kr },
                              { "kt", kt },
                              { "ns", new Integer(ns) },
                              { "nt", new Integer(nt) },
                              { "step", new Double(step) },
                              { "x", new Double(x0) },
                              { "y", new Double(y0) } };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/material/DielectricTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;
import java.util.HashMap;

public class DielectricTexture implements Texture, java.io.Serializable, Writable
{
    private RGB kd, kr, kt;
    private int ns, nt;
    
    public DielectricTexture(RGB baseColor, double reflection, double transparency, int shininess)
    {
        this.kd = baseColor;
        this.kr = new RGB(reflection, reflection, reflection);
        this.kt = new RGB(transparency, transparency, transparency); // XDamier'deki gibi kt
        this.ns = shininess;
        this.nt = 12;
    }
    
public DielectricTexture() {
    this.kd = new RGB(0.25, 0.35, 0.45);    // DAHA KOYU MAVİ - daha belirgin cam rengi
    this.kr = new RGB(0.65, 0.65, 0.65);    // REFLECTION biraz azaltıldı
    this.kt = new RGB(0.35, 0.35, 0.35);    // TRANSPARENCY biraz artırıldı
    this.ns = 220;                          // SHININESS korundu
    this.nt = 12;                           // NT biraz azaltıldı
}
    
    @Override
    public LocalTexture getLocalTexture(Point3D p)
    {
        return new LocalTexture(kd, kr, kt, ns, nt);
    }
    
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap map = new HashMap();
        map.put("kd", null);
        map.put("kr", null); 
        map.put("kt", null);
        map.put("ns", null);
        map.put("nt", null);
        
        reader.readFields(map);
        
        return new DielectricTexture((RGB) map.get("kd"),
                                   ((Number) map.get("kr")).doubleValue(),
                                   ((Number) map.get("kt")).doubleValue(), 
                                   ((Number) map.get("ns")).intValue());
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		String DIELECTRIC_STR="Constructor is: DielectricTexture(RGB baseColor, double reflection, double transparency, int shininess);\nExample:\n0.25,0.35,0.45,  0.65,  0.35,  220\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return DIELECTRIC_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new DielectricTexture();
		 
		String [] split = str.split (",");
		if (split == null) return texture;
		//0.25,0.35,0.45,  0.65,  0.35,  220
			try {
				double r = Double.parseDouble(split[0]);
				double g = Double.parseDouble(split[1]);
				double b = Double.parseDouble(split[2]);
				
				double rf = Double.parseDouble(split[3]);
				double tr = Double.parseDouble(split[4]);
				int sh = Integer.parseInt(split[5]);

				texture = new DielectricTexture(new RGB(r, g, b), rf, tr, sh);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	   
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = { 
            { "kd", kd },
            { "kr", kr },
            { "kt", kt },
            { "ns", new Integer(ns) },
            { "nt", new Integer(nt) }
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/material/AfricanKenteTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

/**
 * AfricanKenteTexture generates a vibrant, high-contrast striped pattern
 * inspired by traditional West African Kente cloth. The design features
 * bold vertical bands of saturated colors with sharp transitions, suitable
 * for cultural, decorative, or stylized rendering contexts.
 * 
 * The texture is mapped along the X-axis (vertical stripes) and repeats
 * uniformly in Y. It assumes the surface normal aligns with the Z-axis
 * for front-facing application (e.g., banners, walls, or clothing planes).
 */
public class AfricanKenteTexture implements Texture, java.io.Serializable, Writable {
    private RGB[] stripeColors;
    private double scale;
    private int phase;

    // Phong parameters for matte fabric (non-shiny, low reflectivity)
    private static final double AMBIENT_FACTOR = 0.5;
    private static final double SPECULAR_FACTOR = 0.05;
    private static final RGB SPECULAR_COLOR = new RGB(0.9, 0.9, 0.9);
    private static final int REFLECTIVITY = 1;
    private static final int SHININESS = 5;

    /**
     * Default constructor with a classic Kente-inspired palette:
     * red, yellow, green, black — symbolizing values like sacrifice, wealth,
     * growth, and spiritual strength.
     */
    public AfricanKenteTexture() {
        this(
            new RGB[]{
                new RGB(0.8, 0.1, 0.1),   // red
                new RGB(0.95, 0.9, 0.2),  // yellow
                new RGB(0.1, 0.6, 0.2),   // green
                new RGB(0.0, 0.0, 0.0)    // black
            },
            8.0,
            0
        );
    }

    /**
     * Constructs an AfricanKenteTexture with a custom stripe sequence.
     *
     * @param stripeColors Array of colors defining the repeating stripe pattern.
     * @param scale        Controls stripe density (higher = more stripes per unit).
     * @param phase        Offset to shift the starting stripe (useful for variation).
     */
    public AfricanKenteTexture(RGB[] stripeColors, double scale, int phase) {
        if (stripeColors == null || stripeColors.length == 0) {
            throw new IllegalArgumentException("Stripe color array must not be empty.");
        }
        this.stripeColors = stripeColors.clone();
        this.scale = Math.max(0.1, scale);
        this.phase = phase;
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Map stripes along X (vertical bands when viewed front-on)
        double x = p.x * scale;
        int stripeIndex = ((int) Math.floor(x) + phase) % stripeColors.length;
        if (stripeIndex < 0) stripeIndex += stripeColors.length;

        RGB color = stripeColors[stripeIndex];

        return new LocalTexture(
            color,
            color.multiply(AMBIENT_FACTOR),
            SPECULAR_COLOR.multiply(SPECULAR_FACTOR),
            SHININESS,
            REFLECTIVITY
        );
    }

    // --- IO Support ---
public static Object build(ObjectReader reader) throws java.io.IOException {
    HashMap<String, Object> map = new HashMap<>();
    map.put("stripeColors", null);
    map.put("scale", 8.0);
    map.put("phase", 0);

    reader.readFields(map);

    // List'ten RGB[]'ye çevir
    java.util.List<RGB> colorsList = (java.util.List<RGB>) map.get("stripeColors");
    RGB[] colorsArray = colorsList.toArray(new RGB[0]);

    return new AfricanKenteTexture(
        colorsArray,
        ((Number) map.get("scale")).doubleValue(),
        ((Number) map.get("phase")).intValue()
    );
}

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		String AFRICANKENTE_STR = "Constructor is: AfricanKenteTexture(RGB[] stripeColors, double scale, int phase);\nExample:\n1,0,0,  0,1,0,  0,0,1,  6.0,  0\n-1 return empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return AFRICANKENTE_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new AfricanKenteTexture();
			
		String [] split = str.split (",");
		if (split == null) return texture;
		
			//1,0,0,  0,1,0,  0,0,1,  6.0,  0
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);
				
				double c3r = Double.parseDouble(split[6]);
				double c3g = Double.parseDouble(split[7]);
				double c3b = Double.parseDouble(split[8]);
				
				RGB[] rgbs = new RGB[3];
				rgbs[0] = new RGB(c1r, c1g, c1b);
				rgbs[1] = new RGB(c2r, c2g, c2b);
				rgbs[2] = new RGB(c3r, c3g, c3b);
				
				double sc = Double.parseDouble(split[9]);
				int ph = Integer.parseInt(split[10]);
				
				texture = new AfricanKenteTexture(rgbs, sc, ph);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
@Override
public void write(ObjectWriter writer) throws java.io.IOException {
    // RGB array'ini manuel olarak yaz
    writer.write("stripeColors = [");
    for(int i = 0; i < stripeColors.length; i++) {
        writer.writeObject(stripeColors[i]);
        if(i < stripeColors.length - 1) writer.write(", ");
    }
    writer.write("]");
    
    // Diğer field'ları normal şekilde yaz
    Object[][] otherFields = {
        {"scale", scale},
        {"phase", phase}
    };
    writer.writeFields(otherFields);
}

    // --- Getters ---
    public RGB[] getStripeColors() { return stripeColors.clone(); }
    public double getScale() { return scale; }
    public int getPhase() { return phase; }
    
}

/**
AfricanKenteTexture kente = new AfricanKenteTexture();

RGB[] myPalette = {
    new RGB(1.0, 0.0, 0.0),   // kırmızı
    new RGB(0.0, 0.0, 1.0),   // mavi
    new RGB(1.0, 1.0, 0.0)    // sarı
};
AfricanKenteTexture kente = new AfricanKenteTexture(myPalette, 6.0, 0);
*/


// =========================================
// File: /raja/material/TransparentPNGTexture.java
// =========================================

// Murat Inan
package raja.material;

import java.io.File;
import java.io.IOException;
import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.util.HashMap;
import javax.imageio.ImageIO;

import raja.*;
import raja.shape.*;
import raja.io.*;

public class TransparentPNGTexture implements Texture, java.io.Serializable, Writable
{
	private Matrix4 inverseTransform = null;
	
	private boolean useZForV = false;
	
	private String imagePath="textures/turkeyFlag.png";
	
    private BufferedImage texture;
    private BufferedImage rotatedTexture; // Döndürülmüş texture cache'i
    private RGB kd, kr, kt;
    private final double KTV; //0.0-1.0 (and 1.0 is full transparen)
    private int ns, nt;
    private double billboardWidth, billboardHeight;
    private double uOffset = 0.0;
    private double vOffset = 0.0;
    private double rotX = 0.0;
    private double rotY = 0.0;
    private double rotZ = 0.0;

    // Ana constructor - tüm parametrelerle
    public TransparentPNGTexture(BufferedImage texture, 
                                RGB kd, RGB kr, RGB kt, 
                                int ns, int nt,
                                double KTV,
                                double uOffset, double vOffset,
                                double rotX, double rotY, double rotZ)
    {
        this.texture = texture;
        this.kd = kd;
        this.kr = kr;
        this.kt = kt;
        this.ns = ns;
        this.nt = nt;
        this.KTV = KTV;
        this.uOffset = uOffset;
        this.vOffset = vOffset;
        this.rotX = rotX;
        this.rotY = rotY;
        this.rotZ = rotZ;
        
        // Texture'ı rotate et
        applyRotation();
    }
    
    // Basit constructor
    public TransparentPNGTexture(BufferedImage texture, 
                                RGB kd, RGB kr, RGB kt, 
                                int ns, int nt)
    {
        this(texture, kd, kr, kt, ns, nt, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    }
    
    public void setImagePath(String npath) {
		this.imagePath = npath;
	}
	
	public String getImagePath() {
		return this.imagePath;
	}
	
    // Texture rotation uygula
    private void applyRotation() {
        if (texture == null || (rotX == 0.0 && rotY == 0.0 && rotZ == 0.0)) {
            rotatedTexture = texture;
            return;
        }
        
        // Toplam rotation açısı (derece)
        double totalRotation = rotZ; // Z-ekseni ana rotation
        
        // Rotation matrisi oluştur
        AffineTransform transform = new AffineTransform();
        
        // Merkez etrafında döndür
        transform.rotate(Math.toRadians(totalRotation), 
                        texture.getWidth() / 2.0, 
                        texture.getHeight() / 2.0);
        
        // Yeni image oluştur - ARGB type
        rotatedTexture = new BufferedImage(texture.getWidth(), texture.getHeight(), 
                                          BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = rotatedTexture.createGraphics();

        // Önce tüm background'u transparent yap
        g2d.setComposite(java.awt.AlphaComposite.Clear);
        g2d.fillRect(0, 0, texture.getWidth(), texture.getHeight());

        // Sonra resmi çiz
        g2d.setComposite(java.awt.AlphaComposite.SrcOver);
        g2d.setTransform(transform);
        g2d.drawImage(texture, 0, 0, null);
        g2d.dispose();
    }

    public void setBillboardDimensions(double width, double height) {
        this.billboardWidth = width;
        this.billboardHeight = height;
    }

    public void setInverseTransform(Matrix4 inverseTransform) {
        this.inverseTransform = inverseTransform;
    }

	public void setUseZForV(boolean useZ) {
		this.useZForV = useZ;
	}

    @Override
    public LocalTexture getLocalTexture(Point3D p)
    {
        BufferedImage currentTexture = (rotatedTexture != null) ? rotatedTexture : texture;
        
        if (currentTexture == null || billboardWidth <= 0 || billboardHeight <= 0) {
            return new LocalTexture(kd, kr, kt, ns, nt);
        }
        
        Point3D localP = p;
        if (inverseTransform != null) {
            localP = inverseTransform.transformPoint(p);
        }
        
        double u = 0.0;
        double v = 0.0;
        
		if (useZForV) {
			u = (localP.y / billboardWidth) + 0.5;     // Y --> sol/sağ
			v = 0.5 - (localP.z / billboardHeight);    // Z --> yukarı --> PNG üstüne uyarla
		} else {
			u = (localP.y / billboardWidth) + 0.5;
			v = 0.5 - (localP.x / billboardHeight);    // billboard için de aynı mantık
		}
        
        // Offset uygula
        u = (u + uOffset) % 1.0;
        v = (v + vOffset) % 1.0;
        
        // Pozitif koordinatları garanti et
        if (u < 0) u += 1.0;
        if (v < 0) v += 1.0;
        
        u = 1.0 - u;
        
        u = Math.max(0.0, Math.min(1.0, u));
        v = Math.max(0.0, Math.min(1.0, v));
        
        int px = (int) (u * (currentTexture.getWidth() - 1));
        int py = (int) (v * (currentTexture.getHeight() - 1));
        
        px = Math.max(0, Math.min(currentTexture.getWidth() - 1, px));
        py = Math.max(0, Math.min(currentTexture.getHeight() - 1, py));
        
        int argb = currentTexture.getRGB(px, py);
        int alpha = (argb >> 24) & 0xFF;
        
        // ÖBÜR PROJEDEKİ GİBİ: alpha < 5 ise TAMAMEN TRANSPARENT
        if (alpha > 5) {
            int red = (argb >> 16) & 0xFF;
            int green = (argb >> 8) & 0xFF;
            int blue = argb & 0xFF;
            
            RGB textureColor = new RGB(red / 255.0, green / 255.0, blue / 255.0);
            
            // OPAQUE - kt = 0 (transparency yok)
            return new LocalTexture(textureColor, 
                                   new RGB(0.0, 0.0, 0.0),
                                   new RGB(0.0, 0.0, 0.0), // kt = 0
                                   5, 1);
        } else {
            // TRANSPARENT - kt = 1.0 (tamamen transparent)
            return new LocalTexture(new RGB(0.0, 0.0, 0.0), // kd = siyah
                                   new RGB(0.0, 0.0, 0.0), // kr = 0
                                   new RGB(KTV, KTV, KTV), // kt = 1.0 - TAM TRANSPARENT
                                   5, 1);
        }
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap map = new HashMap();
        map.put("kd", null);
        map.put("kr", null);
        map.put("kt", null);
        map.put("ns", null);
        map.put("nt", null);
        map.put("KTV", new Double(1.0));
        map.put("uOffset", new Double(0.0));
        map.put("vOffset", new Double(0.0));
        map.put("rotX", new Double(0.0));
        map.put("rotY", new Double(0.0));
        map.put("rotZ", new Double(0.0));
        reader.readFields(map);

        BufferedImage texture = null;
        return new TransparentPNGTexture(texture,
                                       (RGB) map.get("kd"),
                                       (RGB) map.get("kr"),
                                       (RGB) map.get("kt"),
                                       ((Number) map.get("ns")).intValue(),
                                       ((Number) map.get("nt")).intValue(),
                                       ((Number) map.get("KTV")).doubleValue(),
                                       ((Number) map.get("uOffset")).doubleValue(),
                                       ((Number) map.get("vOffset")).doubleValue(),
                                       ((Number) map.get("rotX")).doubleValue(),
                                       ((Number) map.get("rotY")).doubleValue(),
                                       ((Number) map.get("rotZ")).doubleValue());
    }
    
    public void setTexture(BufferedImage texture) {
        this.texture = texture;
        applyRotation(); // Yeni texture için rotation uygula
    }
    
    public BufferedImage getTexture() {
        return texture;
    }
    
    // Rotation değerlerini değiştirmek için method
    public void setRotation(double rotX, double rotY, double rotZ) {
        this.rotX = rotX;
        this.rotY = rotY;
        this.rotZ = rotZ;
        applyRotation(); // Rotation'ı yeniden uygula
    }
    
    // Offset değerlerini değiştirmek için method
    public void setOffset(double uOffset, double vOffset) {
        this.uOffset = uOffset;
        this.vOffset = vOffset;
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//TransparentPNGTexture(BufferedImage texture, RGB kd, RGB kr, RGB kt, int ns, int nt, double KTV, double uOffset, double vOffset, double rotX, double rotY, double rotZ)		     
		//"textures/texture.png",  0.5,0.5,0.5,  0,0,0,  0,0,0,  30,  10,  1.0, 0, 0, 0, 0, 0 
        String TRANSPARENTPNG_STR="Constructor is: TransparentPNGTexture(BufferedImage texture, RGB kd, RGB kr, RGB kt, int ns, int nt, double KTV, double uOffset, double vOffset, double rotX, double rotY, double rotZ);\nExample:\n\"textures/texture.png\",  0,0,0,  0,0,0,  0,0,0,  0,  0,  1.0, 0, 0, 0, 0, 0\nEnter your values after three diyez symbol\n###\n";
		return TRANSPARENTPNG_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		//if (str.equals("-1")) return new ....();
		
		String [] split = str.split (",");
		if (split == null) return texture;

		//TransparentPNGTexture(BufferedImage texture, 
        //                        RGB kd, RGB kr, RGB kt, 
        //                        int ns, int nt,
        //                        double KTV,
        //                        double uOffset, double vOffset,
        //                        double rotX, double rotY, double rotZ)		
        
        //"textures/texture.png",  
        //0.5,0.5,0.5,  0,0,0,  0,0,0,  
        //30,  10,  
        //1.0, 
        //0, 0, 
        //0, 0, 0
			
			try {
				String tstr = split[0];
				tstr = tstr.trim();
				tstr = tstr.replaceAll("\"", "");
				BufferedImage timg = ImageIO.read(new File(tstr));
				
				double c1r = Double.parseDouble(split[1]);
				double c1g = Double.parseDouble(split[2]);
				double c1b = Double.parseDouble(split[3]);
				
				double c2r = Double.parseDouble(split[4]);
				double c2g = Double.parseDouble(split[5]);
				double c2b = Double.parseDouble(split[6]);
				
				double c3r = Double.parseDouble(split[7]);
				double c3g = Double.parseDouble(split[8]);
				double c3b = Double.parseDouble(split[9]);
				
				int ns = Integer.parseInt(split[10]);
				int nt = Integer.parseInt(split[11]);
				
				double kv = Double.parseDouble(split[12]);
				
				double uo = Double.parseDouble(split[13]);
				double vo = Double.parseDouble(split[14]);
				
				double rx = Double.parseDouble(split[15]);
				double ry = Double.parseDouble(split[16]);
				double rz = Double.parseDouble(split[17]);
				
				texture = new TransparentPNGTexture(
					timg,
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					new RGB(c3r, c3g, c3b),
					ns, nt,
					kv,
					uo, vo,
					rx, ry, rz);
				((TransparentPNGTexture)(texture)).setImagePath(tstr);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			} catch (IOException ioe) {
				ioe.printStackTrace();
				return null;
			}
	}
	////////////////
	   
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = { 
            { "kd", kd },
            { "kr", kr },
            { "kt", kt },
            { "ns", new Integer(ns) },
            { "nt", new Integer(nt) },
            { "KTV", new Double(KTV) },
            { "uOffset", new Double(uOffset) },
            { "vOffset", new Double(vOffset) },
            { "rotX", new Double(rotX) },
            { "rotY", new Double(rotY) },
            { "rotZ", new Double(rotZ) }
        };
        writer.writeFields(fields);
    }
    
    // Getter methods
    public double getUOffset() { return uOffset; }
    public double getVOffset() { return vOffset; }
    public double getRotX() { return rotX; }
    public double getRotY() { return rotY; }
    public double getRotZ() { return rotZ; }
    
}


// =========================================
// File: /raja/material/EmissiveTexture.java
// =========================================

// Murat Inan
package raja.material;

import java.util.HashMap;

import raja.*;
import raja.shape.*;
import raja.io.*;

public class EmissiveTexture implements Texture, java.io.Serializable, Writable
{
    private RGB emissiveColor;
    private double emissiveStrength;
    
    public EmissiveTexture(RGB color, double emissiveStrength)
    {
        this.emissiveColor = color;
        this.emissiveStrength = emissiveStrength;
    }
    
    public EmissiveTexture(RGB color)
    {
        this(color, 2.0);
    }

@Override   
public LocalTexture getLocalTexture(Point3D p)
{
    // Base color (normal shading için)
    RGB baseColor = emissiveColor;
    
    // Emissive boost (parlak ama shape'i bozmayacak kadar)
    double r = Math.min(1.0, emissiveColor.getR() * emissiveStrength);
    double g = Math.min(1.0, emissiveColor.getG() * emissiveStrength);
    double b = Math.min(1.0, emissiveColor.getB() * emissiveStrength);
    
    RGB brightColor = new RGB(r, g, b);
    
    // Normal shading ile emissive'i dengele
    return new LocalTexture(brightColor, 
                           new RGB(0.1, 0.1, 0.1),  // biraz reflection (shading için)
                           new RGB(0.0, 0.0, 0.0),
                           50,   // ns: düzgün shading
                           1);
}
    
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap map = new HashMap();
        map.put("emissiveColor", null);
        map.put("emissiveStrength", new Double(2.0));
        reader.readFields(map);
        return new EmissiveTexture(
            (RGB) map.get("emissiveColor"),
            ((Number) map.get("emissiveStrength")).doubleValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//EmissiveTexture(RGB color, double emissiveStrength)
		String EMISSIVE_STR="Constructor is: EmissiveTexture(RGB color, double emissiveStrength);\nExample:\n0,1,0,  2.0\nEnter your values after three diyez symbol\n###\n";
		return EMISSIVE_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		//if (str.equals("-1")) return new EmissiveTexture(RGB.green);
		 
		String [] split = str.split (",");
		if (split == null) return texture;
		//0.85,0.85,0.0,  2.0
			try {
				double r = Double.parseDouble(split[0]);
				double g = Double.parseDouble(split[1]);
				double b = Double.parseDouble(split[2]);
				
				double st = Double.parseDouble(split[3]);
				
				texture = new EmissiveTexture(new RGB(r, g, b), st);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	 
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = { 
            { "emissiveColor", emissiveColor },
            { "emissiveStrength", new Double(emissiveStrength) }
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/material/VoidTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

/**
 * VoidTexture simulates a black hole or cosmic void effect: a dark,
 * non-reflective center that absorbs light, surrounded by a subtle
 * radial gradient fading to near-black. Designed for dramatic,
 * low-emission environments like space scenes or surreal void portals.
 * 
 * The texture is radially symmetric around the origin in the XY plane
 * and works best on flat or spherical surfaces facing the viewer.
 */
public class VoidTexture implements Texture, java.io.Serializable, Writable {
    private RGB outerColor;
    private double scale;
    private double falloff;

    // Extremely low Phong values to simulate light absorption
    private static final double AMBIENT_FACTOR = 0.05;
    private static final double SPECULAR_FACTOR = 0.01;
    private static final RGB SPECULAR_COLOR = new RGB(0.1, 0.1, 0.15);
    private static final int REFLECTIVITY = 0;
    private static final int SHININESS = 5;

    /**
     * Default constructor: deep cosmic void with near-total blackness.
     */
    public VoidTexture() {
        this(
            new RGB(0.08, 0.06, 0.12),  // very dark blue-black
            4.0,
            3.0
        );
    }

    /**
     * Constructs a VoidTexture with custom parameters.
     *
     * @param outerColor Color at the outer edge of the void (still very dark).
     * @param scale      Controls the apparent size of the void (higher = larger).
     * @param falloff    Sharpness of the darkening toward the center (higher = steeper).
     */
    public VoidTexture(RGB outerColor, double scale, double falloff) {
        this.outerColor = outerColor;
        this.scale = Math.max(0.1, scale);
        this.falloff = Math.max(0.5, falloff);
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Radial distance in XY plane (void centered at origin)
        double r = Math.sqrt(p.x * p.x + p.y * p.y) * scale;

        // Exponential falloff toward center → near-zero at r=0
        double intensity = Math.pow(Math.min(1.0, r), falloff);
        RGB color = new RGB(
            outerColor.getR() * intensity,
            outerColor.getG() * intensity,
            outerColor.getB() * intensity
        );

        // Clamp to prevent negative or NaN values
        color = new RGB(
            Math.max(0.0, color.getR()),
            Math.max(0.0, color.getG()),
            Math.max(0.0, color.getB())
        );

        return new LocalTexture(
            color,
            color.multiply(AMBIENT_FACTOR),
            SPECULAR_COLOR.multiply(SPECULAR_FACTOR),
            SHININESS,
            REFLECTIVITY
        );
    }

    // --- IO Support ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("outerColor", null);
        map.put("scale", 4.0);
        map.put("falloff", 3.0);

        reader.readFields(map);

        return new VoidTexture(
            (RGB) map.get("outerColor"),
            ((Number) map.get("scale")).doubleValue(),
            ((Number) map.get("falloff")).doubleValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//VoidTexture(RGB outerColor, double scale, double falloff)
		String VOID_STR="Constructor is: VoidTexture(RGB outerColor, double scale, double falloff);\nExample:\n0.1,0.01,0.06,  4.0,  3.0\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return VOID_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new VoidTexture();
		
		String [] split = str.split (",");
		if (split == null) return texture;

			//VoidTexture(RGB outerColor, double scale, double falloff)
			//0.1,0.01,0.06,  4.0,  3.0
			try {
				double r = Double.parseDouble(split[0]);
				double g = Double.parseDouble(split[1]);
				double b = Double.parseDouble(split[2]);
				
				double sc = Double.parseDouble(split[3]);
				double fl = Double.parseDouble(split[4]);
				
				texture = new VoidTexture(new RGB(r, g, b), sc, fl);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"outerColor", outerColor},
            {"scale", scale},
            {"falloff", falloff}
        };
        writer.writeFields(fields);
    }

    // --- Getters ---
    public RGB getOuterColor() { return outerColor; }
    public double getScale() { return scale; }
    public double getFalloff() { return falloff; }
    
}

/**
VoidTexture voidMat = new VoidTexture();

VoidTexture voidMat = new VoidTexture(
    new RGB(0.05, 0.03, 0.1),   // colder, deeper void
    6.0,                        // larger apparent size
    5.0                         // sharper drop to black
);
*/


// =========================================
// File: /raja/material/GridTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class GridTexture implements Texture, java.io.Serializable, Writable {
    private RGB backgroundColor;
    private RGB lineColor;
    private double cellSize;
    private double lineThickness;
    
    // Default constructor
    public GridTexture() {
        this(new RGB(1, 1, 1), new RGB(0, 0, 0), 0.5, 0.05);
    }
    
    // Custom constructor
    public GridTexture(RGB backgroundColor, RGB lineColor, double cellSize, double lineThickness) {
        this.backgroundColor = backgroundColor;
        this.lineColor = lineColor;
        this.cellSize = cellSize;
        this.lineThickness = lineThickness;
    }
    
    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        double xPos = Math.abs(p.x % cellSize);
        double yPos = Math.abs(p.y % cellSize);
        
        boolean isLine = xPos < lineThickness || xPos > cellSize - lineThickness ||
                        yPos < lineThickness || yPos > cellSize - lineThickness;
        
        RGB surfaceColor = isLine ? lineColor : backgroundColor;
        
        return new LocalTexture(
            surfaceColor,
            surfaceColor.multiply(0.4),
            new RGB(0.2, 0.2, 0.2),
            10,
            1
        );
    }
    
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("backgroundColor", new RGB(1,1,1));
        map.put("lineColor", new RGB(0,0,0));
        map.put("cellSize", 0.5);
        map.put("lineThickness", 0.05);
        
        reader.readFields(map);
        
        return new GridTexture(
            (RGB) map.get("backgroundColor"),
            (RGB) map.get("lineColor"),
            ((Number) map.get("cellSize")).doubleValue(),
            ((Number) map.get("lineThickness")).doubleValue()
        );
    }
    
    @Override
    public String getUsageInformation() {
        String GRID_STR = "Constructor: GridTexture(RGB backgroundColor, RGB lineColor, double cellSize, double lineThickness)\n" +
                         "Examples:\n" +
                         "-1                             # White background, black lines\n" +
                         "1,1,1,  0,0,0,  0.3,  0.02          # White background, black lines, smaller grid\n" +
                         "0.9,0.9,1,  0.2,0.2,0.8,  0.4,  0.03 # Light blue background, blue lines\n" +
                         "Enter values after ###\n###\n";
        return GRID_STR;
    }
    
    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        Texture texture = null;
        String str = info.trim();
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return texture;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "").replaceAll(" ", "");
        
        if (str.equals("-1")) return new GridTexture();
        
        String[] split = str.split(",");
        if (split == null || split.length != 8) return texture;
        
        try {
            double br = Double.parseDouble(split[0]);
            double bg = Double.parseDouble(split[1]);
            double bb = Double.parseDouble(split[2]);
            double lr = Double.parseDouble(split[3]);
            double lg = Double.parseDouble(split[4]);
            double lb = Double.parseDouble(split[5]);
            double cellSize = Double.parseDouble(split[6]);
            double thickness = Double.parseDouble(split[7]);
            
            texture = new GridTexture(new RGB(br, bg, bb), new RGB(lr, lg, lb), cellSize, thickness);
            return texture;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }
    
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"backgroundColor", backgroundColor},
            {"lineColor", lineColor},
            {"cellSize", cellSize},
            {"lineThickness", lineThickness}
        };
        writer.writeFields(fields);
    }
    
    // Getters
    public RGB getBackgroundColor() { return backgroundColor; }
    public RGB getLineColor() { return lineColor; }
    public double getCellSize() { return cellSize; }
    public double getLineThickness() { return lineThickness; }
}


// =========================================
// File: /raja/material/CrystalCaveTexture.java
// =========================================

// Murat Inan
package raja.material;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.util.HashMap;

/**
 * CrystalCaveTexture simulates glowing amethyst-like crystal formations
 * growing inward from the surface. It uses procedural noise and radial
 * gradients to create deep purple crystalline structures with luminous cores.
 * 
 * Best applied to interior cave walls or geodesic shapes where the surface
 * normal points outward (e.g., a sphere or inverted mesh).
 */
public class CrystalCaveTexture implements Texture, java.io.Serializable, Writable {
    private RGB crystalColor;
    private RGB glowColor;
    private double scale;
    private double density;

    // Phong parameters for semi-glossy, emissive-like crystals
    private static final double AMBIENT_FACTOR = 0.6;
    private static final double SPECULAR_FACTOR = 0.5;
    private static final RGB SPECULAR_COLOR = new RGB(0.95, 0.85, 1.0);
    private static final int REFLECTIVITY = 2;
    private static final int SHININESS = 80;

    /**
     * Default constructor: rich purple crystals with bright violet glow.
     */
    public CrystalCaveTexture() {
        this(
            new RGB(0.4, 0.1, 0.6),   // deep amethyst base
            new RGB(0.9, 0.5, 1.0),   // luminous glow core
            10.0,
            0.7
        );
    }

    /**
     * Constructs a CrystalCaveTexture with custom parameters.
     *
     * @param crystalColor Base color of the crystal facets.
     * @param glowColor    Bright inner glow (appears near crystal centers).
     * @param scale        Controls crystal size and repetition frequency.
     * @param density      How densely crystals cover the surface (0.0–1.0).
     */
    public CrystalCaveTexture(RGB crystalColor, RGB glowColor, double scale, double density) {
        this.crystalColor = crystalColor;
        this.glowColor = glowColor;
        this.scale = Math.max(0.5, scale);
        this.density = Math.min(1.0, Math.max(0.0, density));
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Use all three axes for 3D crystal distribution
        double x = p.x * scale;
        double y = p.y * scale;
        double z = p.z * scale;

        // Simple procedural "crystal centers" using modulo grid
        double gridX = x - Math.floor(x);
        double gridY = y - Math.floor(y);
        double gridZ = z - Math.floor(z);

        // Distance to nearest grid point (simulates crystal origin)
        double dx = Math.min(gridX, 1.0 - gridX);
        double dy = Math.min(gridY, 1.0 - gridY);
        double dz = Math.min(gridZ, 1.0 - gridZ);
        double distToCenter = Math.sqrt(dx * dx + dy * dy + dz * dz);

        // Invert: crystals grow from surface inward → closer to center = brighter
        double crystalIntensity = 1.0 - Math.min(1.0, distToCenter * 2.5);

        // Apply density mask: randomly suppress some crystals
        double noiseSeed = (Math.sin(x * 12.9898 + y * 78.233 + z * 45.164) * 43758.5453) % 1.0;
        if (noiseSeed > density) {
            crystalIntensity = 0.0;
        }

        // Blend between crystal base and glowing core
        RGB color = RGB.interpolate(crystalColor, glowColor, crystalIntensity);

        return new LocalTexture(
            color,
            color.multiply(AMBIENT_FACTOR),
            SPECULAR_COLOR.multiply(SPECULAR_FACTOR),
            SHININESS,
            REFLECTIVITY
        );
    }

    // --- IO Support ---
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("crystalColor", null);
        map.put("glowColor", null);
        map.put("scale", 10.0);
        map.put("density", 0.7);

        reader.readFields(map);

        return new CrystalCaveTexture(
            (RGB) map.get("crystalColor"),
            (RGB) map.get("glowColor"),
            ((Number) map.get("scale")).doubleValue(),
            ((Number) map.get("density")).doubleValue()
        );
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		String CRYSTALCAVE_TEXTURE="Constructor is: CrystalCaveTexture(RGB crystalColor, RGB glowColor, double scale, double density);\nExample:\n0.2,0.0,0.5,  0.8,0.3,1.0,  12.0,  0.5\n-1 returns empty constructor.\nEnter your values after three diyez symbol\n###\n";
		return CRYSTALCAVE_TEXTURE;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		if (str.equals("-1")) return new CrystalCaveTexture();
		 
		String [] split = str.split (",");
		if (split == null) return texture;
		//CrystalCaveTexture(RGB crystalColor, RGB glowColor, 
		//double scale, double density)
			try {
				double c1r = Double.parseDouble(split[0]);
				double c1g = Double.parseDouble(split[1]);
				double c1b = Double.parseDouble(split[2]);
				
				double c2r = Double.parseDouble(split[3]);
				double c2g = Double.parseDouble(split[4]);
				double c2b = Double.parseDouble(split[5]);

				double sc = Double.parseDouble(split[6]);
				double dn = Double.parseDouble(split[7]);
				
				texture = new CrystalCaveTexture(
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					sc, dn);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	////////////////
	
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"crystalColor", crystalColor},
            {"glowColor", glowColor},
            {"scale", scale},
            {"density", density}
        };
        writer.writeFields(fields);
    }

    // --- Getters ---
    public RGB getCrystalColor() { return crystalColor; }
    public RGB getGlowColor() { return glowColor; }
    public double getScale() { return scale; }
    public double getDensity() { return density; }
    
}

/**
CrystalCaveTexture cave = new CrystalCaveTexture();

CrystalCaveTexture cave = new CrystalCaveTexture(
    new RGB(0.2, 0.0, 0.5),   // darker crystal
    new RGB(0.8, 0.3, 1.0),   // intense glow
    12.0,                     // finer crystals
    0.5                       // sparser coverage
);
*/


// =========================================
// File: /raja/material/NorthernLightTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class NorthernLightTexture implements Texture, java.io.Serializable, Writable {
    private RGB primaryAurora = new RGB(0.0, 1.0, 0.5);   // Yeşil aurora
    private RGB secondaryAurora = new RGB(0.0, 0.75, 1.0); // Mavi aurora
    private double time = 0.0;

    public NorthernLightTexture() {}

    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Basit aurora efekti - orijinalin sadeleştirilmiş hali
        double x = p.x * 8.0;
        double y = p.y * 12.0;
        
        // Aurora dalga pattern'i
        double curtain1 = Math.sin(x * 0.7 + Math.sin(y * 1.2) * 3.0);
        double curtain2 = Math.cos(y * 1.5 + Math.sin(x * 0.9) * 2.5);
        
        double auroraPattern = (curtain1 * 0.6 + curtain2 * 0.4);
        double normalizedPattern = (auroraPattern + 1.0) * 0.5;
        
        // Zaman efekti (basit)
        double timeEffect = Math.sin(time + y * 0.3) * 0.2 + 0.8;
        
        RGB auroraColor;
        if (normalizedPattern < 0.6) {
            // Yeşil aurora
            double ratio = normalizedPattern / 0.6;
            auroraColor = new RGB(
                primaryAurora.getR() * ratio * timeEffect,
                primaryAurora.getG() * ratio * timeEffect, 
                primaryAurora.getB() * ratio * timeEffect
            );
        } else {
            // Mavi aurora
            double ratio = (normalizedPattern - 0.6) / 0.4;
            auroraColor = new RGB(
                secondaryAurora.getR() * ratio * timeEffect,
                secondaryAurora.getG() * ratio * timeEffect,
                secondaryAurora.getB() * ratio * timeEffect
            );
        }

        // Işık yayan aurora efekti
        return new LocalTexture(
            new RGB(0.1, 0.1, 0.2),     // Koyu diffuse
            new RGB(0.0, 0.0, 0.0),     // Reflection yok
            auroraColor,                 // Işık yayan aurora
            100, 50
        );
    }
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: NorthernLightTexture();\nPress Set button please.";
    }

    @Override
    public String toExampleString() {
        return "NorthernLightTexture";
    }

    @Override
    public Texture getInstance(String info) {
        return new NorthernLightTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"primaryAurora", primaryAurora},
            {"secondaryAurora", secondaryAurora},
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new NorthernLightTexture();
    }
}


// =========================================
// File: /raja/material/ImageTexture.java
// =========================================

// Murat Inan
package raja.material;

import java.io.File;
import java.io.IOException;
import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.util.HashMap;
import javax.imageio.ImageIO;

import raja.*;
import raja.shape.*;
import raja.io.*;

public class ImageTexture implements Texture, java.io.Serializable, Writable
{
	public String imagePath = "textures/turkeyFlag.png";
	
    private double uOffset = 0.0;
    private double vOffset = 0.0;
    private double tileSizeU = 1.0;
    private double tileSizeV = 1.0;
    private double rotX = 0.0;
    private double rotY = 0.0;
    private double rotZ = 0.0;
    
    private BufferedImage texture;
    private BufferedImage rotatedTexture; // Döndürülmüş texture cache'i
    private RGB kd, kr, kt;
    private int ns, nt;
    private double uScale, vScale;
   
    // Ana constructor - tüm parametrelerle
    public ImageTexture(BufferedImage texture, 
                       RGB kd, RGB kr, RGB kt, 
                       int ns, int nt,
                       double uScale, double vScale,
                       double uOffset, double vOffset,
                       double tileSizeU, double tileSizeV,
                       double rotX, double rotY, double rotZ)
    {
        this.texture = texture;
        this.kd = kd;
        this.kr = kr;
        this.kt = kt;
        this.ns = ns;
        this.nt = nt;
        this.uScale = uScale;
        this.vScale = vScale;
        this.uOffset = uOffset;
        this.vOffset = vOffset;
        this.tileSizeU = tileSizeU;
        this.tileSizeV = tileSizeV;
        this.rotX = rotX;
        this.rotY = rotY;
        this.rotZ = rotZ;
        
        // Texture'ı rotate et
        applyRotation();
    }
    
    // Orta seviye constructor
    public ImageTexture(BufferedImage texture, RGB kd, RGB kr, RGB kt, int ns, int nt,
                       double uScale, double vScale, double uOffset, double vOffset) {
        this(texture, kd, kr, kt, ns, nt, uScale, vScale, uOffset, vOffset, 1.0, 1.0, 0.0, 0.0, 0.0);
    }

    // Basit constructor
    public ImageTexture(BufferedImage texture, RGB kd, RGB kr, RGB kt, int ns, int nt) {
        this(texture, kd, kr, kt, ns, nt, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0);
    }

    // Texture rotation uygula
    private void applyRotation() {
        if (texture == null || (rotX == 0.0 && rotY == 0.0 && rotZ == 0.0)) {
            rotatedTexture = texture;
            return;
        }
        
        // Toplam rotation açısı (derece)
        double totalRotation = rotZ; // Z-ekseni ana rotation
        
        // Rotation matrisi oluştur
        AffineTransform transform = new AffineTransform();
        
        // Merkez etrafında döndür
        transform.rotate(Math.toRadians(totalRotation), 
                        texture.getWidth() / 2.0, 
                        texture.getHeight() / 2.0);
        
        // Yeni image oluştur
        rotatedTexture = new BufferedImage(texture.getWidth(), texture.getHeight(), 
                                  BufferedImage.TYPE_INT_ARGB); // ARGB type
		Graphics2D g2d = rotatedTexture.createGraphics();
	
		// Önce tüm background'u transparent yap
		g2d.setComposite(java.awt.AlphaComposite.Clear);
		g2d.fillRect(0, 0, texture.getWidth(), texture.getHeight());

		// Sonra resmi çiz
		g2d.setComposite(java.awt.AlphaComposite.SrcOver);
		g2d.setTransform(transform);
		g2d.drawImage(texture, 0, 0, null);
		g2d.dispose();
    }

    @Override
    public LocalTexture getLocalTexture(Point3D p)
    {
        if (rotatedTexture == null) {
            return new LocalTexture(kd, kr, kt, ns, nt);
        }
        
        final int imgWidth = rotatedTexture.getWidth();
        final int imgHeight = rotatedTexture.getHeight();
        
        // UV koordinatlarını al
        double u = p.x;
        double v = p.y;
        
        // Tile boyutunu uygula
        u = (u * tileSizeU);
        v = (v * tileSizeV);
        
        // Texture transformations uygula
        u = ((u * uScale) + uOffset);
        v = ((v * vScale) + vOffset);
        
        // Tile repeating - mod işlemi
        u = u % 1.0;
        v = v % 1.0;
        
        // Pozitif koordinatları garanti et
        if (u < 0) u += 1.0;
        if (v < 0) v += 1.0;
        
        // V koordinatını flip et (image coordinate system için)
        v = 1.0 - v;
        
        // BİLİNEAR FILTERING
        double x = u * (imgWidth - 1);
        double y = v * (imgHeight - 1);
        
        int x0 = (int) Math.floor(x);
        int y0 = (int) Math.floor(y);
        int x1 = (int) Math.ceil(x);
        int y1 = (int) Math.ceil(y);
        
        // Wrap coordinates
        x0 = wrapCoordinate(x0, imgWidth);
        y0 = wrapCoordinate(y0, imgHeight);
        x1 = wrapCoordinate(x1, imgWidth);
        y1 = wrapCoordinate(y1, imgHeight);
        
        // Renkleri al ve interpolate et
        int argb00 = rotatedTexture.getRGB(x0, y0);
        int argb10 = rotatedTexture.getRGB(x1, y0);
        int argb01 = rotatedTexture.getRGB(x0, y1);
        int argb11 = rotatedTexture.getRGB(x1, y1);
        
        // Bilinear interpolation
        double tx = x - x0;
        double ty = y - y0;
        
        int red = bilinearInterpolate(
            (argb00 >> 16) & 0xFF, (argb10 >> 16) & 0xFF,
            (argb01 >> 16) & 0xFF, (argb11 >> 16) & 0xFF, tx, ty);
        int green = bilinearInterpolate(
            (argb00 >> 8) & 0xFF, (argb10 >> 8) & 0xFF,
            (argb01 >> 8) & 0xFF, (argb11 >> 8) & 0xFF, tx, ty);
        int blue = bilinearInterpolate(
            argb00 & 0xFF, argb10 & 0xFF,
            argb01 & 0xFF, argb11 & 0xFF, tx, ty);
        int alpha = bilinearInterpolate(
            (argb00 >> 24) & 0xFF, (argb10 >> 24) & 0xFF,
            (argb01 >> 24) & 0xFF, (argb11 >> 24) & 0xFF, tx, ty);
        
        if (alpha < 128) {
            return new LocalTexture(kd, kr, new RGB(0.9, 0.9, 0.9), ns, nt);
        } else {
            RGB textureColor = new RGB(red/255.0, green/255.0, blue/255.0);
            return new LocalTexture(textureColor, kr, kt, ns, nt);
        }
    }

    // Diğer projedeki wrapCoordinate methodu
    private int wrapCoordinate(int coord, int max) {
        if (coord < 0) return max - 1 - ((-coord - 1) % max);
        return coord % max;
    }

    // Diğer projedeki bilinear interpolation
    private int bilinearInterpolate(int c00, int c10, int c01, int c11, double tx, double ty) {
        double a = c00 * (1 - tx) * (1 - ty);
        double b = c10 * tx * (1 - ty);
        double c = c01 * (1 - tx) * ty;
        double d = c11 * tx * ty;
        return (int) (a + b + c + d);
    }
    
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap map = new HashMap();
        map.put("kd", null);
        map.put("kr", null);
        map.put("kt", null);
        map.put("ns", null);
        map.put("nt", null);
        map.put("uScale", new Double(1.0));
        map.put("vScale", new Double(1.0));
        map.put("uOffset", new Double(0.0));
        map.put("vOffset", new Double(0.0));
        map.put("tileSizeU", new Double(1.0));
        map.put("tileSizeV", new Double(1.0));
        map.put("rotX", new Double(0.0));
        map.put("rotY", new Double(0.0));
        map.put("rotZ", new Double(0.0));
        
        reader.readFields(map);
        
        BufferedImage texture = null;
        return new ImageTexture(texture,
                              (RGB) map.get("kd"),
                              (RGB) map.get("kr"),
                              (RGB) map.get("kt"),
                              ((Number) map.get("ns")).intValue(),
                              ((Number) map.get("nt")).intValue(),
                              ((Number) map.get("uScale")).doubleValue(),
                              ((Number) map.get("vScale")).doubleValue(),
                              ((Number) map.get("uOffset")).doubleValue(),
                              ((Number) map.get("vOffset")).doubleValue(),
                              ((Number) map.get("tileSizeU")).doubleValue(),
                              ((Number) map.get("tileSizeV")).doubleValue(),
                              ((Number) map.get("rotX")).doubleValue(),
                              ((Number) map.get("rotY")).doubleValue(),
                              ((Number) map.get("rotZ")).doubleValue());
    }
    
    public void setImagePath(String npath) {
		this.imagePath = npath;
	}
	
	public String getImagePath() {
		return this.imagePath;
	}
	
    public void setTexture(BufferedImage texture) {
        this.texture = texture;
        applyRotation(); // Yeni texture için rotation uygula
    }
    
    // Rotation değerlerini değiştirmek için method
    public void setRotation(double rotX, double rotY, double rotZ) {
        this.rotX = rotX;
        this.rotY = rotY;
        this.rotZ = rotZ;
        applyRotation(); // Rotation'ı yeniden uygula
    }
    
    // Tile boyutunu değiştirmek için method
    public void setTileSize(double tileSizeU, double tileSizeV) {
        this.tileSizeU = tileSizeU;
        this.tileSizeV = tileSizeV;
    }
    
    // Offset değerlerini değiştirmek için method
    public void setOffset(double uOffset, double vOffset) {
        this.uOffset = uOffset;
        this.vOffset = vOffset;
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		//ImageTexture(BufferedImage texture, RGB kd, RGB kr, RGB kt, int ns, int nt, double uScale, double vScale, double uOffset, double vOffset, double tileSizeU, double tileSizeV, double rotX, double rotY, double rotZ)        
        //"textures/texture.png", new RGB(0.5, 0.5, 0.5), new RGB(0.1, 0.1, 0.1), new RGB(0.0, 0.0, 0.0), 50, 10, 1.0, 1.0, 0.0, 0.0, 1.5, 1.5, 0.0, 0.0, -270.0   
        String IMAGE_STR="Constructor is: ImageTexture(BufferedImage texture, RGB kd, RGB kr, RGB kt, int ns, int nt, double uScale, double vScale, double uOffset, double vOffset, double tileSizeU, double tileSizeV, double rotX, double rotY, double rotZ);\nExample:\n\"textures/texture.png\",  0.5,0.5,0.5,  0.1,0.1,0.1,  0.0,0.0,0.0, 50, 10, 1.0, 1.0, 0.0, 0.0, 1.5, 1.5, 0.0, 0.0, 0.0\nEnter your values after three diyez symbol\n###\n";
		return IMAGE_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public Texture getInstance(String info) {
		this.exampleString = info;
		
		Texture texture = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return texture;
		
		str = str.substring(diyezIndex+3);	
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
		
		String [] split = str.split (",");
		if (split == null) return texture;

		//ImageTexture(BufferedImage texture, 
        //               RGB kd, RGB kr, RGB kt, 
        //               int ns, int nt,
        //               double uScale, double vScale,
        //               double uOffset, double vOffset,
        //               double tileSizeU, double tileSizeV,
        //               double rotX, double rotY, double rotZ)
        
        //    texture,
		//    new RGB(0.5, 0.5, 0.5), new RGB(0.1, 0.1, 0.1), new RGB(0.0, 0.0, 0.0), 
		//    50, 10,
		//    1.0, 1.0,
		//    0.0, 0.0,
		//    1.5, 1.5,
		//    0.0, 0.0, -270.0 
			
			try {
				String tstr = split[0];
				tstr = tstr.trim();
				tstr = tstr.replaceAll("\"", "");
				BufferedImage timg = ImageIO.read(new File(tstr));
				
				double c1r = Double.parseDouble(split[1]);
				double c1g = Double.parseDouble(split[2]);
				double c1b = Double.parseDouble(split[3]);
				
				double c2r = Double.parseDouble(split[4]);
				double c2g = Double.parseDouble(split[5]);
				double c2b = Double.parseDouble(split[6]);
				
				double c3r = Double.parseDouble(split[7]);
				double c3g = Double.parseDouble(split[8]);
				double c3b = Double.parseDouble(split[9]);
				
				int ns = Integer.parseInt(split[10]);
				int nt = Integer.parseInt(split[11]);
				
				double us = Double.parseDouble(split[12]);
				double vs = Double.parseDouble(split[13]);
				
				double uo = Double.parseDouble(split[14]);
				double vo = Double.parseDouble(split[15]);
				
				double tu = Double.parseDouble(split[16]);
				double tv = Double.parseDouble(split[17]);
				
				double rx = Double.parseDouble(split[18]);
				double ry = Double.parseDouble(split[19]);
				double rz = Double.parseDouble(split[20]);
				
				texture = new ImageTexture(
					timg,
					new RGB(c1r, c1g, c1b), 
					new RGB(c2r, c2g, c2b),
					new RGB(c3r, c3g, c3b),
					ns, nt,
					us, vs,
					uo, vo,
					tu, tv,
					rx, ry, rz);
				((ImageTexture)(texture)).setImagePath(tstr);
				return texture;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			} catch (IOException ioe) {
				ioe.printStackTrace();
				return null;
			}
	}
	////////////////
	   
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = { 
            { "kd", kd },
            { "kr", kr },
            { "kt", kt },
            { "ns", new Integer(ns) },
            { "nt", new Integer(nt) },
            { "uScale", new Double(uScale) },
            { "vScale", new Double(vScale) },
            { "uOffset", new Double(uOffset) },
            { "vOffset", new Double(vOffset) },
            { "tileSizeU", new Double(tileSizeU) },
            { "tileSizeV", new Double(tileSizeV) },
            { "rotX", new Double(rotX) },
            { "rotY", new Double(rotY) },
            { "rotZ", new Double(rotZ) }
        };
        writer.writeFields(fields);
    }
    
    // Getter methods
    public double getUOffset() { return uOffset; }
    public double getVOffset() { return vOffset; }
    public double getTileSizeU() { return tileSizeU; }
    public double getTileSizeV() { return tileSizeV; }
    public double getRotX() { return rotX; }
    public double getRotY() { return rotY; }
    public double getRotZ() { return rotZ; }
    
}


// =========================================
// File: /raja/material/ObsidianHeartTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class ObsidianHeartTexture implements Texture, java.io.Serializable, Writable {
    private RGB baseColor;
    private RGB glowColor;
    private double shininess;
    private double innerGlow;
    
    // Default constructor
    public ObsidianHeartTexture() {
        this(new RGB(0.02, 0.0, 0.0),    // Deep black with red tint
             new RGB(0.8, 0.0, 0.0),     // Red glow
             100.0,                      // High shininess
             0.5);                       // Inner glow intensity
    }
    
    // Custom constructor
    public ObsidianHeartTexture(RGB baseColor, RGB glowColor, double shininess, double innerGlow) {
        this.baseColor = baseColor;
        this.glowColor = glowColor;
        this.shininess = shininess;
        this.innerGlow = innerGlow;
    }
    
    @Override
    public LocalTexture getLocalTexture(Point3D p) {
        // Inner glow effect based on surface position
        double glowEffect = (Math.sin(p.x * 20) * Math.cos(p.y * 20) * Math.sin(p.z * 20) + 1) * 0.5;
        glowEffect *= innerGlow;
        
        RGB finalColor = baseColor.add(glowColor.multiply(glowEffect));
        
        return new LocalTexture(
            finalColor,
            finalColor.multiply(0.1),    // Very low ambient - deep shadows
            new RGB(0.9, 0.9, 0.9),      // High specular for glass-like appearance
            (int) shininess,              // Very high shininess
            1
        );
    }
    
    // IO methods
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("baseColor", new RGB(0.02, 0.0, 0.0));
        map.put("glowColor", new RGB(0.8, 0.0, 0.0));
        map.put("shininess", 100.0);
        map.put("innerGlow", 0.5);

        reader.readFields(map);

        return new ObsidianHeartTexture(
            (RGB) map.get("baseColor"),
            (RGB) map.get("glowColor"),
            ((Number) map.get("shininess")).doubleValue(),
            ((Number) map.get("innerGlow")).doubleValue()
        );
    }

    @Override
    public String getUsageInformation() {
        String OBSIDIAN_STR = "Constructor: ObsidianHeartTexture(RGB baseColor, RGB glowColor, double shininess, double innerGlow)\n" +
                             "Examples:\n" +
                             "-1                             # Default obsidian heart\n" +
                             "0.02,0.0,0.0,    0.8,0.0,0.0,  100.0,  0.5  # Red glowing obsidian\n" +
                             "0.01,0.01,0.02,  0.0,0.6,0.8,  150.0,  0.3  # Blue glowing obsidian\n" +
                             "Enter values after ###\n###\n";
        return OBSIDIAN_STR;
    }

    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        
        Texture texture = null;
        
        String str = info.trim();
        
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return texture;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "");
        str = str.replaceAll(" ", "");
        
        if (str.equals("-1")) return new ObsidianHeartTexture();
        
        String[] split = str.split(",");
        if (split == null || split.length != 8) return texture;
        
        try {
            double r1 = Double.parseDouble(split[0]);
            double g1 = Double.parseDouble(split[1]);
            double b1 = Double.parseDouble(split[2]);
            double r2 = Double.parseDouble(split[3]);
            double g2 = Double.parseDouble(split[4]);
            double b2 = Double.parseDouble(split[5]);
            double shininess = Double.parseDouble(split[6]);
            double innerGlow = Double.parseDouble(split[7]);
            
            texture = new ObsidianHeartTexture(
                new RGB(r1, g1, b1),
                new RGB(r2, g2, b2),
                shininess,
                innerGlow
            );
            return texture;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"baseColor", baseColor},
            {"glowColor", glowColor},
            {"shininess", shininess},
            {"innerGlow", innerGlow}
        };
        writer.writeFields(fields);
    }

    // Getters
    public RGB getBaseColor() { return baseColor; }
    public RGB getGlowColor() { return glowColor; }
    public double getShininess() { return shininess; }
    public double getInnerGlow() { return innerGlow; }
}


// =========================================
// File: /raja/material/LavaTexture.java
// =========================================

package raja.material;

import raja.*;
import raja.io.*;
import raja.shape.*;
import java.util.HashMap;

public class LavaTexture implements Texture, java.io.Serializable, Writable {
    private double time = 0.0;

    public LavaTexture() {}

@Override
public LocalTexture getLocalTexture(Point3D p) {
    double heat = (Math.sin(time * 3 + p.y * 5) + 1) * 0.5;
    double glow = (Math.cos(time * 2 + p.x * 4) + 1) * 0.3;
    
    RGB lavaColor = new RGB(
        0.8 + heat * 0.2,
        0.2 + glow * 0.3,
        0.1
    );

    return new LocalTexture(
        lavaColor,
        new RGB(0.3, 0.1, 0.0),
        new RGB(heat * 0.4, glow * 0.2, 0.0),
        50, 
        10
    );
}
    
    public void updateTime(double t) { this.time = t; }

    @Override
    public String getUsageInformation() {
        return "Constructor is: LavaTexture();\nPress Set button please.";
    }

    private String exampleString = "null";
    
    @Override
    public String toExampleString() {
        return this.exampleString;
    }

    @Override
    public Texture getInstance(String info) {
        this.exampleString = info;
        return new LavaTexture();
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            {"time", Double.valueOf(time)}
        };
        writer.writeFields(fields);
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        return new LavaTexture();
    }
}


// =========================================
// File: /raja/LightRay.java
// =========================================

/* $Id: LightRay.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja;


/**
 * A class to represent rays that originate from a point and head for a
 * light source. The <code>LightRay</code> class extends the
 * <code>Ray</code> class with two fields:
 * <ul>
 * <li> the light intensity corresponding to the illumination of the point
 *      by the light source.
 * <li> the distance between the point and the light source.
 * </ul>
 *
 * @see Ray
 * @see raja.light.LightSource
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
public class LightRay extends Ray
{
    /**
     * The <i>light intensity</i> of the light ray.
     * @serial
     */
    public RGB light;

    /**
     * The <i>distance</i> between the ray's origin and the light source.
     * @serial
     */
    public double distance;

    /**
     * Creates a <code>LightRay</code> object initialized with the
     * specified origin, direction, light intensity and distance.
     * 
     * @param origin    the origin of the newly constructed
     *                  <code>LightRay</code>.
     * @param direction the direction of the newly constructed
     *                  <code>LightRay</code>.
     * @param light     the light intensity of the newly constructed
     *                  <code>LightRay</code>.
     * @param distance  the distance between the ray's origin and the light
     *                  source it heads for.
     */
    public LightRay(Point3D origin, Vector3D direction,
                    RGB light, double distance)
    {
        super(origin, direction);
        this.light = light;
        this.distance = distance;
    }

    /**
     * Creates a <code>LightRay</code> object initialized with the
     * specified origin, destination and light intensity.  The destination
     * should be the location of the light source.  The direction and
     * distance of the newly constructed <code>LightRay</code> are computed
     * from this location.
     * 
     * @param origin      the origin of the newly constructed
     *                    <code>LightRay</code>.
     * @param destination the location of the light source.
     * @param light     the light intensity of the newly constructed
     *                  <code>LightRay</code>.
     */
    public LightRay(Point3D origin, Point3D destination, RGB light)
    {
        super(origin, destination);
        this.light = light;
        distance = Point3D.distance(origin, destination);
    }
}


// =========================================
// File: /raja/Matrix4.java
// =========================================

// Murat Inan
package raja;

/**
 * Represents a 4x4 matrix for 3D transformations (translation, rotation, scaling).
 */
public class Matrix4 implements java.io.Serializable, raja.io.Writable {
  public final double[][] m; // Matrix elements
  
  private double trnsX, trnsY, trnsZ, rotaX, rotaY, rotaZ, scleX, scleY, scleZ;
  
  /**
   * Constructs an identity Matrix4.
   */
  public Matrix4() {
    m = new double[4][4];
    m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = 0.0;
    m[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0; m[1][3] = 0.0;
    m[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = 0.0;
    m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;
  }
  
  /**
   * Constructs a Matrix4 with the specified elements.
   */
  public Matrix4(double m00, double m01, double m02, double m03,
    double m10, double m11, double m12, double m13,
    double m20, double m21, double m22, double m23,
    double m30, double m31, double m32, double m33) {
    m = new double[4][4];
    this.m[0][0] = m00; this.m[0][1] = m01; this.m[0][2] = m02; this.m[0][3] = m03;
    this.m[1][0] = m10; this.m[1][1] = m11; this.m[1][2] = m12; this.m[1][3] = m13;
    this.m[2][0] = m20; this.m[2][1] = m21; this.m[2][2] = m22; this.m[2][3] = m23;
    this.m[3][0] = m30; this.m[3][1] = m31; this.m[3][2] = m32; this.m[3][3] = m33;
  }
  
  /**
   * Constructs a new Matrix4 by copying an existing matrix.
   * @param other The Matrix4 object to copy.
   */
  public Matrix4(Matrix4 other) {
    this(other.m[0][0], other.m[0][1], other.m[0][2], other.m[0][3],
      other.m[1][0], other.m[1][1], other.m[1][2], other.m[1][3],
      other.m[2][0], other.m[2][1], other.m[2][2], other.m[2][3],
    other.m[3][0], other.m[3][1], other.m[3][2], other.m[3][3]);
  }
  
  /**
   * Returns an identity (unit) 4x4 matrix.
   * An identity matrix has 1s on the main diagonal and 0s elsewhere.
   * It represents no translation, rotation, or scaling.
   *
   * @return A new 4x4 identity matrix.
   */
  public static Matrix4 identity() {
    return new Matrix4(); // The default constructor creates an identity matrix
  }
  
  /**
	* Returns the rotation component of this transformation matrix by removing translation and scaling.
	* This extracts only the rotational part, normalizing the basis vectors to remove scale effects.
	* Useful for transforming normal vectors without distorting their length.
	* 
	* @return A new Matrix4 containing only the rotation component
	*/
	public Matrix4 getRotationMatrix() {
		// Extract the 3x3 upper-left submatrix (rotation/scale part)
		Vector3D col0 = new Vector3D(m[0][0], m[1][0], m[2][0]); // First column
		Vector3D col1 = new Vector3D(m[0][1], m[1][1], m[2][1]); // Second column  
		Vector3D col2 = new Vector3D(m[0][2], m[1][2], m[2][2]); // Third column
    
		// Normalize each column vector to remove scaling
		col0 = col0.normalization();
		col1 = col1.normalization();
		col2 = col2.normalization();
    
		// Create new matrix with normalized rotation and zero translation
		return new Matrix4(
			col0.x, col1.x, col2.x, 0.0,  // First row: normalized X basis, no translation
			col0.y, col1.y, col2.y, 0.0,  // Second row: normalized Y basis, no translation
			col0.z, col1.z, col2.z, 0.0,  // Third row: normalized Z basis, no translation
			0.0,    0.0,    0.0,    1.0   // Fourth row: homogeneous coordinates
		);
	}

  /**
   * Sets the value at the specified row and column.
   * @param row The row index (0-3)
   * @param col The column index (0-3)
   * @param value The value to set
   * @throws IndexOutOfBoundsException if row or col is not in [0, 3]
   */
  public void set(int row, int col, double value) {
    if (row < 0 || row >= 4 || col < 0 || col >= 4) {
        throw new IndexOutOfBoundsException("Matrix4 indices out of bounds: [" + row + "][" + col + "]");
    }
	
    this.m[row][col] = value;
  }
  
  /**
   * Gets the X-axis scale factor from this transformation matrix.
   * This is calculated as the magnitude of the X basis vector.
   * @return The X scale factor
   */
  public double getScaleX() {
    return Math.sqrt(m[0][0] * m[0][0] + m[1][0] * m[1][0] + m[2][0] * m[2][0]);
  }
  
  /**
   * Gets the Y-axis scale factor from this transformation matrix.
   * This is calculated as the magnitude of the Y basis vector.
   * @return The Y scale factor
   */
  public double getScaleY() {
    return Math.sqrt(m[0][1] * m[0][1] + m[1][1] * m[1][1] + m[2][1] * m[2][1]);
  }
  
  /**
   * Gets the Z-axis scale factor from this transformation matrix.
   * This is calculated as the magnitude of the Z basis vector.
   * @return The Z scale factor
   */
  public double getScaleZ() {
    return Math.sqrt(m[0][2] * m[0][2] + m[1][2] * m[1][2] + m[2][2] * m[2][2]);
  }
  
  public Ray transformRay(Ray ray) {
    Point3D newOrigin = this.transformPoint(ray.getOrigin());
    Vector3D newDirection = this.transformVector(ray.getDirection()).normalization();
    return new Ray(newOrigin, newDirection);
  }

  /**
   * Transforms a direction vector by this matrix.
   * Unlike points, vectors are not affected by translation.
   * Only the rotational and scaling components are applied.
   *
   * This is used for transforming normal vectors, ray directions, etc.
   *
   * @param v The direction vector to transform
   * @return A new transformed Vector3
   */
  public Vector3D transformDirection(Vector3D v) {
    double x = m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z;
    double y = m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z;
    double z = m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z;
    return new Vector3D(x, y, z);
  }

  /**
   * Provides access to a specific element of the matrix.
   * @param row The row index (0-3).
   * @param col The column index (0-3).
   * @return The matrix element at the specified position.
   * @throws IndexOutOfBoundsException If the row or column index is invalid.
   */
  public double get(int row, int col) {
    if (row < 0 || row >= 4 || col < 0 || col >= 4) {
      throw new IndexOutOfBoundsException("Matrix4 indices out of bounds: [" + row + "][" + col + "]");
    }
    return m[row][col];
  }
  
  /**
   * Normal vektörü dönüştürür (normal transformasyonu için).
   * Normal vektörlerin doğru dönüşümü için matrisin ters transpozu kullanılır.
   * @param normal Dönüştürülecek normal vektör
   * @return Dönüştürülmüş normal vektör (normalize edilmiş)
   */
  public Vector3D transformNormal(Vector3D normal) {
    // Matrisin ters transpozu alınır
    Matrix4 normalMatrix = this.inverseTransposeForNormal();
    
    if (normalMatrix == null) {
      return new Vector3D(0, 0, 0); // Geçersiz dönüşüm durumu
    }
    
    // Vektörü dönüştür (w=0 varsayarak, sadece 3x3 kısım kullanılır)
    double x = normal.x;
    double y = normal.y;
    double z = normal.z;
    
    double newX = normalMatrix.m[0][0] * x + normalMatrix.m[0][1] * y + normalMatrix.m[0][2] * z;
    double newY = normalMatrix.m[1][0] * x + normalMatrix.m[1][1] * y + normalMatrix.m[1][2] * z;
    double newZ = normalMatrix.m[2][0] * x + normalMatrix.m[2][1] * y + normalMatrix.m[2][2] * z;
    
    return new Vector3D(newX, newY, newZ).normalization();
  }
  
  /**
   * Multiplies this matrix by another matrix.
   * @param other The other Matrix4 to multiply with.
   * @return The resulting Matrix4.
   */
  /**
  public Matrix4 multiply(Matrix4 other) {
    Matrix4 result = new Matrix4(); // Start with an identity matrix
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        result.m[i][j] = 0; // Reset element before summing
        for (int k = 0; k < 4; k++) {
          result.m[i][j] += this.m[i][k] * other.m[k][j];
        }
      }
    }
    return result;
  }
  */
public Matrix4 multiply(Matrix4 other) {
    Matrix4 result = new Matrix4();
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            result.m[i][j] = 0;
            for (int k = 0; k < 4; k++) {
                result.m[i][j] += this.m[i][k] * other.m[k][j];
            }
        }
    }
    
    // Translation değerlerini koru
    result.trnsX = this.trnsX + other.trnsX;
    result.trnsY = this.trnsY + other.trnsY;
    result.trnsZ = this.trnsZ + other.trnsZ;
    
    // Rotation değerlerini koru
    result.rotaX = this.rotaX + other.rotaX;
    result.rotaY = this.rotaY + other.rotaY;
    result.rotaZ = this.rotaZ + other.rotaZ;
    
    // SCALE değerlerini MATRIX'TEN HESAPLA
    result.scleX = Math.sqrt(result.m[0][0] * result.m[0][0] + result.m[1][0] * result.m[1][0] + result.m[2][0] * result.m[2][0]);
    result.scleY = Math.sqrt(result.m[0][1] * result.m[0][1] + result.m[1][1] * result.m[1][1] + result.m[2][1] * result.m[2][1]);
    result.scleZ = Math.sqrt(result.m[0][2] * result.m[0][2] + result.m[1][2] * result.m[1][2] + result.m[2][2] * result.m[2][2]);
    
    return result;
}
  
  /**
   * Transforms a Point3 by this matrix (includes translation).
   * For affine transformations, the W component of the transformed point should be 1.0.
   * @param point The Point3 to transform.
   * @return The transformed Point3.
   */
  public Point3D transformPoint(Point3D point) {
    double x = m[0][0] * point.x + m[0][1] * point.y + m[0][2] * point.z + m[0][3];
    double y = m[1][0] * point.x + m[1][1] * point.y + m[1][2] * point.z + m[1][3];
    double z = m[2][0] * point.x + m[2][1] * point.y + m[2][2] * point.z + m[2][3];
    return new Point3D(x, y, z);
  }
  
  /**
   * Transforms a Vector3 by this matrix (only rotation and scaling, no translation).
   * @param vector The Vector3 to transform.
   * @return The transformed Vector3.
   */
  public Vector3D transformVector(Vector3D vector) {
    double x = m[0][0] * vector.x + m[0][1] * vector.y + m[0][2] * vector.z;
    double y = m[1][0] * vector.x + m[1][1] * vector.y + m[1][2] * vector.z;
    double z = m[2][0] * vector.x + m[2][1] * vector.y + m[2][2] * vector.z;
    return new Vector3D(x, y, z);
  }
  
  /**
   * Returns the inverse of this matrix. Returns null if the matrix is non-invertible.
   * This method is designed for affine transformations (rotation, translation, uniform scaling).
   * Formula: [ R | t ]^-1 = [ R^-1 | -R^-1 * t ]
   * Where R is the upper-left 3x3 submatrix and t is the translation vector.
   * @return The inverse Matrix4 or null.
   */
  public Matrix4 inverse() {
    // Extract the upper 3x3 rotation/scale part
    Matrix3 upperLeft = new Matrix3(
      m[0][0], m[0][1], m[0][2],
      m[1][0], m[1][1], m[1][2],
      m[2][0], m[2][1], m[2][2]
    );
    Matrix3 invUpperLeft = upperLeft.inverse(); // This performs its own determinant check
    
    if (invUpperLeft == null) {
      System.err.println("Warning: Upper 3x3 part of Matrix4 is non-invertible, cannot compute inverse.");
      return null;
    }
    
    Matrix4 inv = new Matrix4(); // Resulting inverse matrix, initialized to identity
    
    // Set the upper-left 3x3 of the inverse matrix (R^-1)
    inv.m[0][0] = invUpperLeft.get(0,0); inv.m[0][1] = invUpperLeft.get(0,1); inv.m[0][2] = invUpperLeft.get(0,2);
    inv.m[1][0] = invUpperLeft.get(1,0); inv.m[1][1] = invUpperLeft.get(1,1); inv.m[1][2] = invUpperLeft.get(1,2);
    inv.m[2][0] = invUpperLeft.get(2,0); inv.m[2][1] = invUpperLeft.get(2,1); inv.m[2][2] = invUpperLeft.get(2,2);
    
    // Calculate the inverse translation part: -R^-1 * t
    Vector3D translation = new Vector3D(m[0][3], m[1][3], m[2][3]);
    Vector3D invTranslation = invUpperLeft.transform(translation).negation();
    
    inv.m[0][3] = invTranslation.x;
    inv.m[1][3] = invTranslation.y;
    inv.m[2][3] = invTranslation.z;
    
    // Bottom row remains [0, 0, 0, 1] for affine transformations
    inv.m[3][0] = 0.0; inv.m[3][1] = 0.0; inv.m[3][2] = 0.0; inv.m[3][3] = 1.0;
    
    return inv;
  }
  
  /**
	* Returns a new matrix that is the negation of this matrix.
	* Each element in the resulting matrix is the negative of the corresponding element in this matrix.
	* 
	* @return A new Matrix4 representing the negation of this matrix
	*/
	public Matrix4 negation() {
		return new Matrix4(
			-m[0][0], -m[0][1], -m[0][2], -m[0][3],
			-m[1][0], -m[1][1], -m[1][2], -m[1][3],
			-m[2][0], -m[2][1], -m[2][2], -m[2][3],
			-m[3][0], -m[3][1], -m[3][2], -m[3][3]
		);
	}

  /**
   * Computes the inverse transpose of the upper 3x3 part of this matrix.
   * This is typically used to transform normal vectors correctly when the
   * model matrix contains non-uniform scaling.
   * For pure rotations, the inverse is equal to the transpose.
   *
   * @return A new Matrix4 representing the inverse transpose of the 3x3 part,
   * with the translation components set to zero. Returns null if the
   * upper 3x3 part is non-invertible.
   */
  public Matrix4 inverseTransposeForNormal() {
    // Extract the upper 3x3 part
    Matrix3 upperLeft = new Matrix3(
      m[0][0], m[0][1], m[0][2],
      m[1][0], m[1][1], m[1][2],
      m[2][0], m[2][1], m[2][2]
    );
    
    // Compute its inverse
    Matrix3 invUpperLeft = upperLeft.inverse();
    
    if (invUpperLeft == null) {
      System.err.println("Warning: Upper 3x3 part of Matrix4 is non-invertible, cannot compute inverse transpose for normal.");
      return null;
    }
    
    // Transpose the inverse (this is the correct operation for normals)
    Matrix3 normalMatrix3 = invUpperLeft.transpose();
    
    // Construct a new Matrix4 from this 3x3, with translation part zeroed out
    return new Matrix4(
      normalMatrix3.get(0,0), normalMatrix3.get(0,1), normalMatrix3.get(0,2), 0,
      normalMatrix3.get(1,0), normalMatrix3.get(1,1), normalMatrix3.get(1,2), 0,
      normalMatrix3.get(2,0), normalMatrix3.get(2,1), normalMatrix3.get(2,2), 0,
      0, 0, 0, 1
    );
  }
  
  /**
   * Creates a translation matrix.
   * @param translation The translation vector.
   * @return The translation Matrix4.
   */
  public static Matrix4 translate(Vector3D translation) {  
    Matrix4 result = new Matrix4(
      1, 0, 0, translation.x,
      0, 1, 0, translation.y,
      0, 0, 1, translation.z,
      0, 0, 0, 1
    );
    result.trnsX = translation.x;
	result.trnsY = translation.y;
	result.trnsZ = translation.z;
	
    return result;
  }
  
  public static Matrix4 translate(double x, double y, double z) {
    Matrix4 result = new Matrix4(
      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1
    );
    result.trnsX = x;
	result.trnsY = y;
	result.trnsZ = z;
	
    return result;
  }
  
  /**
   * Creates a rotation matrix around the X-axis.
   * @param angleDegrees The rotation angle in degrees.
   * @return The rotation Matrix4.
   */
  public static Matrix4 rotateX(double angleDegrees) {
    double angleRad = Math.toRadians(angleDegrees);
    double cosA = Math.cos(angleRad);
    double sinA = Math.sin(angleRad);
    Matrix4 result = new Matrix4(
      1,    0,     0, 0,
      0,  cosA, -sinA, 0,
      0,  sinA,  cosA, 0,
      0,    0,     0, 1
    );
    result.rotaX = angleDegrees;

    return result;
  }
  
  /**
   * Creates a rotation matrix around the Y-axis.
   * @param angleDegrees The rotation angle in degrees.
   * @return The rotation Matrix4.
   */
  public static Matrix4 rotateY(double angleDegrees) {
    double angleRad = Math.toRadians(angleDegrees);
    double cosA = Math.cos(angleRad);
    double sinA = Math.sin(angleRad);
    Matrix4 result = new Matrix4(
      cosA,  0, sinA, 0,
      0,     1,    0, 0,
      -sinA, 0, cosA, 0,
      0,     0,    0, 1
    );
	result.rotaY = angleDegrees;
	
	return result;
  }
  
  /**
   * Creates a rotation matrix around the Z-axis.
   * @param angleDegrees The rotation angle in degrees.
   * @return The rotation Matrix4.
   */
  public static Matrix4 rotateZ(double angleDegrees) {
    double angleRad = Math.toRadians(angleDegrees);
    double cosA = Math.cos(angleRad);
    double sinA = Math.sin(angleRad);
    Matrix4 result = new Matrix4(
      cosA, -sinA, 0, 0,
      sinA,  cosA, 0, 0,
      0,     0,    1, 0,
      0,     0,    0, 1
    );
    result.rotaZ = angleDegrees;
    
    return result;
  }
  
  /**
   * Creates a scaling matrix with the specified scale factors.
   * @param sx The X-axis scale factor.
   * @param sy The Y-axis scale factor.
   * @param sz The Z-axis scale factor.
   * @return The scaling Matrix4.
   */
  public static Matrix4 scale(double sx, double sy, double sz) {	
    Matrix4 result = new Matrix4(
      sx, 0,  0, 0,
      0, sy,  0, 0,
      0,  0, sz, 0,
      0,  0,  0, 1
    );
    result.scleX = sx;
	result.scleY = sy;
	result.scleZ = sz;
	
    return result;
  }
  
  // Matrix4 sınıfına bu metodu ekleyin
  public Matrix4 transpose() {
    return new Matrix4(
      m[0][0], m[1][0], m[2][0], m[3][0],
      m[0][1], m[1][1], m[2][1], m[3][1],
      m[0][2], m[1][2], m[2][2], m[3][2],
      m[0][3], m[1][3], m[2][3], m[3][3]
    );
  }
  
  /**
 * Creates a rotation matrix around an arbitrary axis by the specified angle.
 * Uses Rodrigues' rotation formula.
 * 
 * @param axis the rotation axis (will be normalized)
 * @param angle the rotation angle in radians
 * @return the rotation matrix
 */
public static Matrix4 rotate(Vector3D axis, double angle) {
    Vector3D u = axis.normalization();
    double cos = Math.cos(angle);
    double sin = Math.sin(angle);
    double oneMinusCos = 1.0 - cos;
    
    double ux = u.x, uy = u.y, uz = u.z;
    
    return new Matrix4(
        cos + ux*ux*oneMinusCos,     ux*uy*oneMinusCos - uz*sin, ux*uz*oneMinusCos + uy*sin, 0,
        uy*ux*oneMinusCos + uz*sin,  cos + uy*uy*oneMinusCos,     uy*uz*oneMinusCos - ux*sin, 0,
        uz*ux*oneMinusCos - uy*sin,  uz*uy*oneMinusCos + ux*sin, cos + uz*uz*oneMinusCos,     0,
        0,                           0,                           0,                           1
    );
}

  /**
   * Creates a Matrix4 from a Matrix3 (typically to extend rotation matrices to 4x4).
   * @param m3 The Matrix3 to extend.
   * @return The created Matrix4.
   */
  public static Matrix4 fromMatrix3(Matrix3 m3) {
    return new Matrix4(
      m3.get(0,0), m3.get(0,1), m3.get(0,2), 0,
      m3.get(1,0), m3.get(1,1), m3.get(1,2), 0,
      m3.get(2,0), m3.get(2,1), m3.get(2,2), 0,
      0, 0, 0, 1
    );
  }
  
/**
 * Creates a scaling matrix that scales uniformly along all axes.
 * @param s The uniform scale factor.
 * @return The scaling Matrix4.
 */
public static Matrix4 scale(double s) {	
    return scale(s, s, s);
}

/**
 * Creates a scaling matrix that scales only along the X-axis.
 * @param sx The X-axis scale factor.
 * @return The scaling Matrix4.
 */
public static Matrix4 scaleX(double sx) {
	Matrix4 result = new Matrix4(
        sx, 0,  0, 0,
        0,  1,  0, 0,
        0,  0,  1, 0,
        0,  0,  0, 1
    );
    result.scleX = sx;
    
    return result;
}

/**
 * Creates a scaling matrix that scales only along the Y-axis.
 * @param sy The Y-axis scale factor.
 * @return The scaling Matrix4.
 */
public static Matrix4 scaleY(double sy) {	
    Matrix4 result = new Matrix4(
        1,  0,  0, 0,
        0, sy,  0, 0,
        0,  0,  1, 0,
        0,  0,  0, 1
    );
    result.scleY = sy;
    
    return result;
}

/**
 * Creates a scaling matrix that scales only along the Z-axis.
 * @param sz The Z-axis scale factor.
 * @return The scaling Matrix4.
 */
public static Matrix4 scaleZ(double sz) {
    Matrix4 result = new Matrix4(
        1, 0,  0, 0,
        0, 1,  0, 0,
        0, 0, sz, 0,
        0, 0,  0, 1
    );
	result.scleZ = sz;
	
	return result;
}

/**
 * Creates a translation matrix that translates only along the X-axis.
 * @param x The translation amount along the X-axis.
 * @return The translation Matrix4.
 */
public static Matrix4 translateX(double x) {
    Matrix4 result = new Matrix4(
        1, 0, 0, x,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    );
    result.trnsX = x;
    
    return result;
}

/**
 * Creates a translation matrix that translates only along the Y-axis.
 * @param y The translation amount along the Y-axis.
 * @return The translation Matrix4.
 */
public static Matrix4 translateY(double y) {
    Matrix4 result = new Matrix4(
        1, 0, 0, 0,
        0, 1, 0, y,
        0, 0, 1, 0,
        0, 0, 0, 1
    );
    result.trnsY = y;
    
    return result;
}

/**
 * Creates a translation matrix that translates only along the Z-axis.
 * @param z The translation amount along the Z-axis.
 * @return The translation Matrix4.
 */
public static Matrix4 translateZ(double z) {
	Matrix4 result = new Matrix4(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, z,
        0, 0, 0, 1
    );
    result.trnsZ = z;
    
    return result;
}

/**
 * Creates a rotation matrix that rotates around an arbitrary axis defined by a unit vector.
 * The input angle is in degrees; conversion to radians is handled internally.
 *
 * @param angleDegrees The rotation angle in degrees.
 * @param axis The unit vector representing the axis of rotation.
 * @return The rotation Matrix4.
 * @throws IllegalArgumentException if the axis vector is zero-length.
 */
public static Matrix4 rotate(double angleDegrees, Vector3D axis) {
    if (axis.lengthSquared() == 0) {
        throw new IllegalArgumentException("Rotation axis must be a non-zero vector.");
    }
    
    // Normalize the axis to ensure it's a unit vector
    Vector3D u = axis.normalization();
    
    double angleRad = Math.toRadians(angleDegrees);
    double cosA = Math.cos(angleRad);
    double sinA = Math.sin(angleRad);
    double oneMinusCosA = 1.0 - cosA;

    double x = u.x;
    double y = u.y;
    double z = u.z;

    double m00 = cosA + x * x * oneMinusCosA;
    double m01 = x * y * oneMinusCosA - z * sinA;
    double m02 = x * z * oneMinusCosA + y * sinA;

    double m10 = y * x * oneMinusCosA + z * sinA;
    double m11 = cosA + y * y * oneMinusCosA;
    double m12 = y * z * oneMinusCosA - x * sinA;

    double m20 = z * x * oneMinusCosA - y * sinA;
    double m21 = z * y * oneMinusCosA + x * sinA;
    double m22 = cosA + z * z * oneMinusCosA;

    return new Matrix4(
        m00, m01, m02, 0,
        m10, m11, m12, 0,
        m20, m21, m22, 0,
        0,   0,   0,   1
    );
}

/**
 * Creates a rotation matrix by applying rotations around the X, Y, and Z axes in XYZ order.
 * Input angles are in degrees; conversion to radians is handled internally via rotateX/Y/Z.
 * This is equivalent to: R = Rz(z) * Ry(y) * Rx(x)
 * Note: Rotation order matters—this uses intrinsic Tait-Bryan angles (XYZ convention).
 *
 * @param xAngleDegrees Rotation angle around the X-axis in degrees.
 * @param yAngleDegrees Rotation angle around the Y-axis in degrees.
 * @param zAngleDegrees Rotation angle around the Z-axis in degrees.
 * @return The combined rotation Matrix4.
 */
public static Matrix4 rotateXYZ(double xAngleDegrees, double yAngleDegrees, double zAngleDegrees) {
    // Each of rotateX/Y/Z already converts degrees to radians internally
    Matrix4 rx = rotateX(xAngleDegrees);
    Matrix4 ry = rotateY(yAngleDegrees);
    Matrix4 rz = rotateZ(zAngleDegrees);
    // Apply in order: X → Y → Z, so matrix multiplication is Rz * (Ry * Rx)
    Matrix4 result = rz.multiply(ry.multiply(rx));
    result.rotaX = xAngleDegrees;
    result.rotaY = yAngleDegrees;
    result.rotaZ = zAngleDegrees;
    
    return result;
}

public static Object build(raja.io.ObjectReader reader) throws java.io.IOException {
    /* Initialisation */
    java.util.HashMap map = new java.util.HashMap();
    
    // Matrix4 için 16 elemanlık bir dizi bekliyoruz
    map.put("m00", null); map.put("m01", null); map.put("m02", null); map.put("m03", null);
    map.put("m10", null); map.put("m11", null); map.put("m12", null); map.put("m13", null);
    map.put("m20", null); map.put("m21", null); map.put("m22", null); map.put("m23", null);
    map.put("m30", null); map.put("m31", null); map.put("m32", null); map.put("m33", null);
    
    /* Parsing */
    reader.readFields(map);
    
    return new Matrix4(
        ((Number)map.get("m00")).doubleValue(), ((Number)map.get("m01")).doubleValue(), 
        ((Number)map.get("m02")).doubleValue(), ((Number)map.get("m03")).doubleValue(),
        ((Number)map.get("m10")).doubleValue(), ((Number)map.get("m11")).doubleValue(), 
        ((Number)map.get("m12")).doubleValue(), ((Number)map.get("m13")).doubleValue(),
        ((Number)map.get("m20")).doubleValue(), ((Number)map.get("m21")).doubleValue(), 
        ((Number)map.get("m22")).doubleValue(), ((Number)map.get("m23")).doubleValue(),
        ((Number)map.get("m30")).doubleValue(), ((Number)map.get("m31")).doubleValue(), 
        ((Number)map.get("m32")).doubleValue(), ((Number)map.get("m33")).doubleValue()
    );
}

@Override
public void write(raja.io.ObjectWriter writer) throws java.io.IOException {
    Number[] fields = {
        m[0][0], m[0][1], m[0][2], m[0][3],
        m[1][0], m[1][1], m[1][2], m[1][3],
        m[2][0], m[2][1], m[2][2], m[2][3],
        m[3][0], m[3][1], m[3][2], m[3][3]
    };
    writer.writeFields(fields);
}

  public String toParametersString() {
	StringBuilder sb = new StringBuilder();
	sb.append("// translate(");
	sb.append(Double.toString(trnsX));
	sb.append(", ");
	sb.append(Double.toString(trnsY));
	sb.append(", ");
	sb.append(Double.toString(trnsZ));
	sb.append(") * rotate(");
	sb.append(Double.toString(rotaX));
	sb.append(", ");
	sb.append(Double.toString(rotaY));
	sb.append(", ");
	sb.append(Double.toString(rotaZ));
	sb.append(") * scale(");
	sb.append(Double.toString(scleX));
	sb.append(", ");
	sb.append(Double.toString(scleY));
	sb.append(", ");
	sb.append(Double.toString(scleZ));
	sb.append(");\n");
	
	return sb.toString();
  }
  
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 4; i++) {
      sb.append("| ");
      for (int j = 0; j < 4; j++) {
        sb.append(String.format("%8.4f", m[i][j])).append(" ");
      }
      sb.append("|\n");
    }
    return sb.toString();
  }
  
}


// =========================================
// File: /raja/shape/MSphere.java
// =========================================

/* $Id: MSphere.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

/**
 * Represents a sphere defined by a center point and radius.
 * Supports arbitrary position, orientation, and scaling via a 4x4 transformation matrix.
 * Non-uniform scaling can create ellipsoidal shapes.
 */
public class MSphere extends BasicForm implements java.io.Serializable, Writable
{
    protected Point3D center;
    protected double radius;
    
    private Matrix4 transform = Matrix4.identity();
    private Matrix4 inverseTransform = Matrix4.identity();

    /**
     * Constructs a sphere with the specified center and radius.
     * 
     * @param center the center point of the sphere
     * @param radius the radius of the sphere
     */
    public MSphere(double radius)
    {
        this.center = new Point3D(0, 0, 0);
        this.radius = radius;
    }

    /**
     * Builds an MSphere instance from ObjectReader data.
     */
    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        /* Initialisation */
        HashMap map = new HashMap();
        map.put("radius",null);

        /* Parsing */
        reader.readFields(map);

        return new MSphere(((Number) map.get("radius")).doubleValue());
    }
    
    /**
     * Sets the transformation matrix and updates derived data.
     * 
     * @param transform the transformation matrix to apply
     */
    @Override
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        Matrix4 inv = transform.inverse();
        this.inverseTransform = (inv != null) ? inv : Matrix4.identity();
    }
    
    /**
     * Gets the current transformation matrix.
     * 
     * @return the current transformation matrix
     */
    @Override
    public Matrix4 getTransform() {
        return this.transform;
    }

    /**
     * Gets the inverse transformation matrix.
     * 
     * @return the inverse transformation matrix
     */
    public Matrix4 getInverseTransform() {
        return this.inverseTransform;
    }

    /**
     * Computes the intersection point between a ray and the sphere/ellipsoid.
     * Transforms the ray to local space for accurate intersection calculations.
     * 
     * @param r the ray to test for intersection
     * @return the intersection point in world coordinates, or null if no intersection
     */
@Override
public Point3D computeIntersection(Ray r)
{
    // Transform ray to local space
    Point3D localOrigin = inverseTransform.transformPoint(r.origin);
    Vector3D localDirection = inverseTransform.transformVector(r.direction).normalization();
    Ray localRay = new Ray(localOrigin, localDirection);

    // Sphere intersection in local space
    // Vektör: ray origin'den sphere center'a
    Vector3D oc = new Vector3D(localRay.origin, center);
    
    double a = Vector3D.dotProduct(localRay.direction, localRay.direction);
    double b = -2.0 * Vector3D.dotProduct(localRay.direction, oc);
    double c = Vector3D.dotProduct(oc, oc) - radius * radius;

    double discriminant = b*b - 4*a*c;
    
    if (discriminant < 0) {
        return null; // No intersection
    }
    
    double sqrtDiscriminant = Math.sqrt(discriminant);
    double t1 = (-b - sqrtDiscriminant) / (2*a);
    double t2 = (-b + sqrtDiscriminant) / (2*a);
    
    // Find the closest positive intersection
    double t = -1;
    if (t1 > 1e-9) {
        t = t1;
    } else if (t2 > 1e-9) {
        t = t2;
    }
    
    if (t < 0) {
        return null; // No valid intersection
    }
    
    // Local intersection point
    Point3D localIntersection = new Point3D(
        localRay.origin, 
        Vector3D.product(localRay.direction, t)
    );
    
    // Transform back to world space
    Point3D worldIntersection = transform.transformPoint(localIntersection);
    
    // Check light group after transformation
    if (hasLG(worldIntersection)) {
        return null;
    }
    
    return worldIntersection;
}

    /**
     * Checks if a point is inside or on the surface of the sphere/ellipsoid.
     * 
     * @param p the point to test in world coordinates
     * @return true if the point is inside or on the surface, false otherwise
     */
    @Override
    public boolean exactlyContains(Point3D p)
    {
        // Transform point to local space for accurate check
        Point3D localPoint = inverseTransform.transformPoint(p);
        return (Point3D.distance(localPoint, center) <= radius);
    }

    /**
     * Checks if a point is strictly inside the sphere/ellipsoid (not on surface).
     * 
     * @param p the point to test in world coordinates
     * @return true if the point is strictly inside, false otherwise
     */
    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        // Transform point to local space for accurate check
        Point3D localPoint = inverseTransform.transformPoint(p);
        return (Point3D.distance(localPoint, center) < radius);
    }

    /**
     * Computes the surface normal at the given point on the sphere/ellipsoid.
     * 
     * @param p the point on the surface in world coordinates
     * @return the normalized surface normal vector
     */
@Override
public Vector3D computeNormal(Point3D p)
{
    Point3D localPoint = inverseTransform.transformPoint(p);
    Vector3D localNormal = new Vector3D(center, localPoint);
    
    // Normal transformation: (M^-1)^T
    Matrix4 normalMatrix = inverseTransform.transpose();
    Vector3D worldNormal = normalMatrix.transformVector(localNormal);
    
    return worldNormal.normalization();
}
    
    /**
     * Gets the local center point (before transformation).
     * 
     * @return the local center point
     */
    public Point3D getLocalCenter() { 
        return center; 
    }
    
    /**
     * Gets the local radius (before transformation).
     * 
     * @return the local radius
     */
    public double getLocalRadius() { 
        return radius; 
    }

    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		String SPHERE_STR = "Constructor is: MSphere(double radius);\nExample -last value is volume-:\n0.7,  1\nEnter your values after three diyez symbol\n###\n";
		return SPHERE_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		this.exampleString = info;
		
		BasicForm bform = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return bform;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return bform;
		
			try {
				double rd = Double.parseDouble(split[0]);

				bform = new MSphere(rd);
				double vl = Double.parseDouble(split[1]);
				bform.setVolumeValue(vl);
				return bform;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}

	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////
	
    /**
     * Returns a string representation of the sphere.
     * 
     * @return string representation
     */
    @Override
    public String toString()
    {
        return ObjectWriter.toString(this);
    }

    /**
     * Writes the sphere data to an ObjectWriter.
     * 
     * @param writer the ObjectWriter to write to
     * @throws java.io.IOException if writing fails
     */
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { 
            { "radius", new Double(radius) } 
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/shape/Solid.java
// =========================================

/* $Id: Solid.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;


public interface Solid extends Shape3D, Volume
{
    public SolidLocalGeometry intersection(Ray r);
}


// =========================================
// File: /raja/shape/LocalGeometry.java
// =========================================

/* $Id: LocalGeometry.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;


public abstract class LocalGeometry extends Point3D
{
    protected LocalGeometry(Point3D p)
    {
        super(p);
    }

    abstract AcneCorrection getAcneCorrection();

    /**
     * Returns the outer normal of the <code>Form</code> at this point.
     * @return an instance of <code>Vector3D</code> that is the outer normal of the <code>Form</code>
     *         at this point.
     */
    public abstract Vector3D getNormal();
}


// =========================================
// File: /raja/shape/Plane.java
// =========================================

/* $Id: Plane.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class Plane extends BasicForm implements java.io.Serializable, Writable
{
    protected Point3D origin;
    protected Vector3D normal;

    public Plane(Point3D origin, Vector3D normal)
    {
        this.origin = origin;
        this.normal = Vector3D.normalization(normal);
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("origin",null);
	map.put("normal",null);

	/* Parsing */
	reader.readFields(map);

	return new Plane((Point3D) map.get("origin"),
                         (Vector3D) map.get("normal"));
    }
	
	@Override
    public Point3D computeIntersection(Ray r)
    {
        double den = Vector3D.dotProduct(normal, r.direction);

        if (den == 0)
        {
            return null;
        }
        else
        {
            double num = Vector3D.dotProduct(normal, new Vector3D(r.origin, origin));
            double t = num / den;
            if (t <= 0)
            {
                return null;
            }
            if (hasLG(r.origin)) {
                return null;
            }
            return new Point3D(r.origin, Vector3D.product(r.direction, t));
        }
    }
    @Override
    public boolean exactlyContains(Point3D p)
    {
        return (Vector3D.dotProduct(normal, new Vector3D(origin, p)) <= 0);
    }
    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        return (Vector3D.dotProduct(normal, new Vector3D(origin, p)) < 0);
    }
    @Override
    public Vector3D computeNormal(Point3D p)
    {
        return normal;   // Attention a la normale qui doit etre ext�rieure !
    }
	
	// ADDED by Murat Inan
	@Override
	public void setTransform(Matrix4 mtrx) {
		return;
	}
	
	@Override
	public Matrix4 getTransform() {
		return new Matrix4();
	}
    ////////////////////
    
    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		return "";
	}
	
   @Override
   public String toExampleString() {
     return "null";
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		return new Plane(new Point3D(0, 0, 0), new Vector3D(0, 0, 1));
	}
	
	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////
	
    @Override
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "origin", origin },
                              { "normal", normal } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/TexturedLocalGeometry.java
// =========================================

/* $Id: TexturedLocalGeometry.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.Vector3D;


public abstract class TexturedLocalGeometry extends LocalGeometry
{
    private LocalGeometry lg;

    protected TexturedLocalGeometry(LocalGeometry lg)
    {
        super(lg);
        this.lg = lg;
    }

    AcneCorrection getAcneCorrection()
    {
        return lg.getAcneCorrection();
    }
    public Vector3D getNormal()
    {
        return lg.getNormal();
    }
    public abstract LocalTexture getInLocalTexture();
    public abstract LocalTexture getOutLocalTexture();
}


// =========================================
// File: /raja/shape/Form.java
// =========================================

/* $Id: Form.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;


public interface Form extends Shape3D
{
    public LocalGeometry intersection(Ray r);
}


// =========================================
// File: /raja/shape/AcneCorrection.java
// =========================================

/* $Id: AcneCorrection.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

abstract class AcneCorrection
{
    abstract BasicForm getBasicForm();
}


// =========================================
// File: /raja/shape/Texture.java
// =========================================

/* $Id: Texture.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;


public interface Texture
{
    public LocalTexture getLocalTexture(Point3D p);
    
    // ADDED by Murat Inan
    abstract public String getUsageInformation();
    abstract public Texture getInstance(String info);
    abstract public String toExampleString();
    /////////
}


// =========================================
// File: /raja/shape/MCylinder.java
// =========================================

// Murat Inan
package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

public class MCylinder extends BasicForm implements java.io.Serializable, Writable
{
    private double radius;
    private double height;
    private Matrix4 transform;
    private Matrix4 inverseTransform;

    public MCylinder(double radius, double height) {
        this.radius = radius;
        this.height = height;
        this.transform = Matrix4.identity();
        this.inverseTransform = Matrix4.identity();
    }

    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap map = new HashMap();
        map.put("radius", null);
        map.put("height", null);
        reader.readFields(map);
        return new MCylinder(((Number) map.get("radius")).doubleValue(),
                           ((Number) map.get("height")).doubleValue());
    }

    @Override
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        this.inverseTransform = transform.inverse();
    }
    
    @Override
    public Matrix4 getTransform() {
        return this.transform;
    }

    @Override
    public Point3D computeIntersection(Ray worldRay) {
        Ray localRay = new Ray(
            inverseTransform.transformPoint(worldRay.origin),
            inverseTransform.transformVector(worldRay.direction).normalization()
        );

        double ox = localRay.origin.x, oy = localRay.origin.y, oz = localRay.origin.z;
        double dx = localRay.direction.x, dy = localRay.direction.y, dz = localRay.direction.z;

        double t = Double.POSITIVE_INFINITY;

        double a = dx*dx + dz*dz;
        if (a > 1e-12) {
            double b = 2*(ox*dx + oz*dz);
            double c = ox*ox + oz*oz - radius*radius;
            double disc = b*b - 4*a*c;
            
            if (disc >= 0) {
                double sqrtDisc = Math.sqrt(disc);
                double t1 = (-b - sqrtDisc) / (2*a);
                double t2 = (-b + sqrtDisc) / (2*a);
                
                if (t1 > 1e-6 && isWithinHeight(oy + t1*dy)) t = Math.min(t, t1);
                if (t2 > 1e-6 && isWithinHeight(oy + t2*dy)) t = Math.min(t, t2);
            }
        }

        if (Math.abs(dy) > 1e-12) {
            double tBottom = -oy / dy;
            if (tBottom > 1e-6 && tBottom < t && isWithinDisk(ox + tBottom*dx, oz + tBottom*dz)) {
                t = tBottom;
            }
            
            double tTop = (height - oy) / dy;
            if (tTop > 1e-6 && tTop < t && isWithinDisk(ox + tTop*dx, oz + tTop*dz)) {
                t = tTop;
            }
        }

        if (t == Double.POSITIVE_INFINITY || hasLG(worldRay.origin)) return null;

        Point3D localHit = localRay.pointAt(t);
        return transform.transformPoint(localHit);
    }

    private boolean isWithinHeight(double y) {
        return y >= 0 && y <= height;
    }

    private boolean isWithinDisk(double x, double z) {
        return x*x + z*z <= radius*radius;
    }

    @Override
    public Vector3D computeNormal(Point3D worldPoint) {
        Point3D localPoint = inverseTransform.transformPoint(worldPoint);
        Vector3D localNormal;

        if (Math.abs(localPoint.y) < 1e-6) {
            localNormal = new Vector3D(0, -1, 0);
        } else if (Math.abs(localPoint.y - height) < 1e-6) {
            localNormal = new Vector3D(0, 1, 0);
        } else {
            localNormal = new Vector3D(localPoint.x, 0, localPoint.z).normalization();
        }

        return transform.transformVector(localNormal).normalization();
    }

    @Override
    public boolean exactlyContains(Point3D p) {
        Point3D local = inverseTransform.transformPoint(p);
        return isWithinDisk(local.x, local.z) && isWithinHeight(local.y);
    }

    @Override
    public boolean exactlyStrictlyContains(Point3D p) {
        Point3D local = inverseTransform.transformPoint(p);
        return (local.x*local.x + local.z*local.z < radius*radius) && 
               (local.y > 0 && local.y < height);
    }

    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		String CYLINDER_STR = "Constructor is:  MCylinder(double radius, double height);\nExample -last value is volume-:\n1.25,  1.5,  1\nEnter your values after three diyez symbol\n###\n";
		return CYLINDER_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		this.exampleString = info;
		
		BasicForm bform = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return bform;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return bform;
		
			try {
				double rd = Double.parseDouble(split[0]);
				double hg = Double.parseDouble(split[1]);
				
				bform = new MCylinder(rd, hg);
				double vl = Double.parseDouble(split[2]);
				bform.setVolumeValue(vl);
				return bform;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}

	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////
	
    @Override
    public String toString() {
        return ObjectWriter.toString(this);
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = { 
            { "radius", new Double(radius) },
            { "height", new Double(height) }
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/shape/LocalTexture.java
// =========================================

/* $Id: LocalTexture.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.RGB;
import raja.io.*;

import java.awt.*;
import java.awt.image.BufferedImage;

import java.util.HashMap;


/**
 * A class to encapsulate the local physical properties of a form's
 * boundary.  This class provides methods to get the following local
 * physical properties of a form's boundary: the diffuse (kd),
 * reflection (krl, krg) and transmission (ktl, ktg) coefficients, the
 * reflection power index (ns) and the transmission power index (nt).
 * </ul>
 *
 * @see Texture
 * @see TexturedForm
 * @see TexturedLocalGeometry
 * @see RGB
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
public class LocalTexture implements java.io.Serializable, Writable
{
    private RGB kd, krl, krg, ktl, ktg;
    private int ns, nt;
    
    /**
    public LocalTexture (Color c1, Color c2, int ns, int nt)
    {
	BufferedImage bi=new BufferedImage (3, 3, 1);
	Graphics2D g2d=bi.createGraphics ();
	g2d.setBackground (Color.white);
	g2d.clearRect (0, 0, 3, 3);
	GradientPaint gp=new GradientPaint (0, 0, c1, 3, 3, c2, true);
	g2d.setPaint (gp);
	g2d.fillRect (0, 0, 3, 3);
	
	int rgb=bi.getRGB (1, 1);
	Color ncol=new Color (rgb);
	
	this.kd=new RGB ( (1.0)/((double)ncol.getRed ()),
			  (1.0)/((double)ncol.getGreen ()),
			  (1.0)/((double)ncol.getBlue ()) );
	
	rgb=bi.getRGB (0, 0);
	ncol=new Color (rgb);
	
	RGB ofi=new RGB ( (1.0)/((double)ncol.getRed ()),
			  (1.0)/((double)ncol.getGreen ()),
			  (1.0)/((double)ncol.getBlue ()) );
	
	this.krl=ofi;
	this.krg=ofi;
	
	rgb=bi.getRGB (0, 0);
	ncol=new Color (rgb);
	
	ofi=new RGB ( (1.0)/((double)ncol.getRed ()),
			  (1.0)/((double)ncol.getGreen ()),
			  (1.0)/((double)ncol.getBlue ()) );
	
	this.ktl=ofi;
	this.ktg=ofi;
	
	this.ns=ns;
	this.nt=nt;
	
	g2d.dispose ();
	bi=null;
    }
    */
    
    public LocalTexture(RGB kd, RGB kr, RGB kt, int ns, int nt)
    {
        this.kd = kd;
        this.krl = kr;
        this.krg = kr;
        this.ktl = kt;
        this.ktg = kt;
        this.ns = ns;
        this.nt = nt;
    }

    public LocalTexture(RGB kd, RGB krl, RGB krg, RGB ktl, RGB ktg, int ns, int nt)
    {
        this.kd = kd;
        this.krl = krl;
        this.krg = krg;
        this.ktl = ktl;
        this.ktg = ktg;
        this.ns = ns;
        this.nt = nt;
    }

    public LocalTexture(RGB kd, RGB krg, double krl, RGB ktg, double ktl, int ns, int nt)
    {
        this.kd = kd;
        this.krl = new RGB(krl);
        this.krg = krg;
        this.ktl = new RGB(ktl);
        this.ktg = ktg;
        this.ns = ns;
        this.nt = nt;
    }

    public LocalTexture(double kd, double krl, double krg, double ktl, double ktg, int ns, int nt, RGB color)
    {
        this.kd = RGB.product(color, kd);
        this.krl = new RGB(krl);
        this.krg = new RGB(krg);
        this.ktl = new RGB(ktl);
        this.ktg = new RGB(ktg);
        this.ns = ns;
        this.nt = nt;
    }

    public LocalTexture(double kd, double kr, double kt, int ns, int nt, RGB color)
    {
        this.kd = RGB.product(color, kd);
        this.krl = new RGB(kr);
        this.krg = krl;
        this.ktl = new RGB(kt);
        this.ktg = ktl;
        this.ns = ns;
        this.nt = nt;
    }

    private static RGB RGBFilter(Object obj)
    {
        if (obj instanceof Number)
        {
            return new RGB(((Number) obj).doubleValue());
        }
        else
        {
            return (RGB) obj;
        }
    }

    /**
     * Builds the object LocalTexture from a StreamLexer.
     */
    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("color",null);
	map.put("kd",null);
	map.put("krg",null);
	map.put("krl",null);
	map.put("ktg",null);
	map.put("ktl",null);
	map.put("ns",null);
	map.put("nt",null);

	/* Parsing */
	reader.readFields(map);

        if (map.get("color") == null)
        {
            return new LocalTexture(RGBFilter(map.get("kd")),
                                    RGBFilter(map.get("krl")),
                                    RGBFilter(map.get("krg")),
                                    RGBFilter(map.get("ktl")),
                                    RGBFilter(map.get("ktg")),
                                    ((Number) map.get("ns")).intValue(),
                                    ((Number) map.get("nt")).intValue());
        }
        else
        {
            return new LocalTexture(((Number) map.get("kd")).doubleValue(),
                                    ((Number) map.get("krl")).doubleValue(),
                                    ((Number) map.get("krg")).doubleValue(),
                                    ((Number) map.get("ktl")).doubleValue(),
                                    ((Number) map.get("ktg")).doubleValue(),
                                    ((Number) map.get("ns")).intValue(),
                                    ((Number) map.get("nt")).intValue(),
                                    (RGB) map.get("color"));
        }
    }

    /**
     * Returns the diffuse coefficient.
     * @return an instance of <code>RGB</code> that is the diffuse coefficient.
     */
    public RGB getKd()
    {
        return kd;
    }

    /**
     * Returns the local reflection coefficient.
     * @return an instance of <code>RGB</code> that is the local reflection coefficient.
     */
    public RGB getKrl()
    {
        return krl;
    }

    /**
     * Returns the global reflection coefficient.
     * @return an instance of <code>RGB</code> that is the global reflection coefficient.
     */
    public RGB getKrg()
    {
        return krg;
    }

    /**
     * Returns the local transmission coefficient.
     * @return an instance of <code>RGB</code> that is the local transmission coefficient.
     */
    public RGB getKtl()
    {
        return ktl;
    }

    /**
     * Returns the global transmission coefficient.
     * @return an instance of <code>RGB</code> that is the global transmission coefficient.
     */
    public RGB getKtg()
    {
        return ktg;
    }

    /**
     * Returns the reflection power index.
     */
    public int getNs()
    {
        return ns;
    }

    /**
     * Returns the transmission power index.
     */
    public int getNt()
    {
        return nt;
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "kd", kd },
                              { "krl", krl },
                              { "krg", krg },
                              { "ktl", ktl },
                              { "ktg", ktg },
                              { "ns", new Integer(ns) },
                              { "nt", new Integer(nt) } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/PlainTexture.java
// =========================================

/* $Id: PlainTexture.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.Point3D;
import raja.io.*;
import java.util.HashMap;


public class PlainTexture implements Texture, java.io.Serializable, Writable
{
    LocalTexture localTexture;

    public PlainTexture(LocalTexture t)
    {
        localTexture = t;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();
        
	map.put("localTexture",null);
	
	/* Parsing */
	reader.readFields(map);
        
        return new PlainTexture((LocalTexture) map.get("localTexture"));
    }

    public LocalTexture getLocalTexture(Point3D p)
    {
        return localTexture;
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		return "";
	}

    @Override
    public String toExampleString() {
      return "null";
    }
   
	@Override
    public Texture getInstance(String info) {
		LocalTexture l = new LocalTexture (0.1, 0.3, 0.1, 10, 1, raja.RGB.red);
		return new PlainTexture(l);
	}
	////////////////
	
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "localTexture", localTexture } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/Shape3D.java
// =========================================

/* $Id: Shape3D.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;


public interface Shape3D
{
    public boolean intersects(LightRay r);

    public boolean contains(Point3D p);

    public boolean strictlyContains(Point3D p);
}


// =========================================
// File: /raja/shape/MPlane.java
// =========================================

/* $Id: MPlane.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

public class MPlane extends BasicForm implements java.io.Serializable, Writable
{    
    protected Point3D center;
    protected Vector3D normal;

    private Matrix4 transform = Matrix4.identity();
    private Matrix4 inverseTransform = Matrix4.identity();
    private Matrix4 normalTransform = Matrix4.identity();

    // MEVCUT Constructor - sadece normal
    public MPlane(Vector3D normal)
    {
        this.center = new Point3D(0, 0, 0);
        this.normal = Vector3D.normalization(normal);
        updateTransforms();
    }

    // YENİ Constructor - center + normal
    public MPlane(Point3D center, Vector3D normal)
    {
        this.center = center;
        this.normal = Vector3D.normalization(normal);
        updateTransforms();
    }

    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        HashMap map = new HashMap();
        map.put("normal", null);

        reader.readFields(map);

        return new MPlane((Vector3D) map.get("normal"));
    }

    @Override
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        updateTransforms();
    }
    
    @Override
    public Matrix4 getTransform() {
        return this.transform;
    }
    
    private void updateTransforms() {
        Matrix4 inv = this.transform.inverse();
        this.inverseTransform = (inv != null) ? inv : Matrix4.identity();
        
        // Normal transform = (inverse)^T for proper normal transformation
        Matrix4 invTranspose = this.inverseTransform.transpose();
        this.normalTransform = (invTranspose != null) ? invTranspose : Matrix4.identity();
    }

@Override
public Point3D computeIntersection(Ray r)
{
    if (this.inverseTransform == null) return null;

    // Işını yerel uzaya al
    Point3D localOrigin = this.inverseTransform.transformPoint(r.origin);
    Vector3D localDirection = this.inverseTransform.transformVector(r.direction);

    // Yerel düzlem: always passes through (0,0,0) with normal `this.normal`
    double denom = Vector3D.dotProduct(this.normal, localDirection);
    if (Math.abs(denom) < Ray.EPSILON2) return null;

    double tLocal = -Vector3D.dotProduct(this.normal, new Vector3D(new Point3D(0,0,0), localOrigin)) / denom;
    if (tLocal < Ray.EPSILON2) return null;

    // tLocal, yerel ışın parametresidir ama dünya t'siyle aynı (çünkü transform lineer)
    // Dolayısıyla doğrudan dünya ışınıyla t'yi kullanabiliriz
    return new Point3D(r.origin, Vector3D.product(r.direction, tLocal));
}

@Override
public Vector3D computeNormal(Point3D p)
{
    // Use normal transform matrix (inverse transpose) for proper normal transformation
    return normalTransform.transformVector(normal).normalization();
}

@Override
public boolean exactlyContains(Point3D p)
{
    Vector3D worldNormal = computeNormal(null);
    Point3D worldPlaneOrigin = transform.transformPoint(this.center);
    
    double distance = Vector3D.dotProduct(worldNormal, new Vector3D(worldPlaneOrigin, p));
    return Math.abs(distance) <= Ray.EPSILON2;
}

@Override
public boolean exactlyStrictlyContains(Point3D p)
{
    Vector3D worldNormal = computeNormal(null);
    Point3D worldPlaneOrigin = transform.transformPoint(this.center);
    
    double distance = Vector3D.dotProduct(worldNormal, new Vector3D(worldPlaneOrigin, p));
    return distance < -Ray.EPSILON2;
}

    // ADDED by Murat Inan
    @Override
    public String getUsageInformation()
    {
        String PLANE_STR = "Constructor is: MPlane(Vector3D normal)\n" +
                          "Examples - last value is volume:\n" +
                          "0,0,1,  0\n" +
                          "Enter your values after three diyez symbol\n###\n";
        return PLANE_STR;
    }

    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public BasicForm getInstance(String info)
    {
        this.exampleString = info;
        
        BasicForm bform = null;
        
        String str = info.trim();
        
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return bform;
        
        str = str.substring(diyezIndex+3);
        str = str.replaceAll("\n", "");
        str = str.replaceAll(" ", "");
            
        String [] split = str.split (",");
        if (split == null) return bform;
        
        try {
            if (split.length == 4) {
                // Sadece normal: dx,dy,dz,volume
                double dx = Double.parseDouble(split[0]);
                double dy = Double.parseDouble(split[1]);
                double dz = Double.parseDouble(split[2]);
                
                bform = new MPlane(new Vector3D(dx, dy, dz));
                double vl = Double.parseDouble(split[3]);
                bform.setVolumeValue(vl);
            } else if (split.length == 7) {
                // Center + normal: cx,cy,cz, dx,dy,dz,volume
                double cx = Double.parseDouble(split[0]);
                double cy = Double.parseDouble(split[1]);
                double cz = Double.parseDouble(split[2]);
                double dx = Double.parseDouble(split[3]);
                double dy = Double.parseDouble(split[4]);
                double dz = Double.parseDouble(split[5]);
                
                bform = new MPlane(new Point3D(cx, cy, cz), new Vector3D(dx, dy, dz));
                double vl = Double.parseDouble(split[6]);
                bform.setVolumeValue(vl);
            }
            return bform;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }
    
    private double volumeValue = 1.0;
    public double getVolumeValue() {
        return this.volumeValue;
    }
    
    public void setVolumeValue(double vlm) {
        this.volumeValue = vlm;
    }
    
    public String toString()
    {
        return ObjectWriter.toString(this);
    }

    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { 
            { "normal", normal } 
        };
        writer.writeFields(fields);
    }
    
}

/**
// Floor (only normal):
MPlane floor = new MPlane(new Vector3D(0, 0, 1));

// Backwall (center + normal):
MPlane wall = new MPlane(new Point3D(0, 0, 10), new Vector3D(0, 0, -1));
wall.setTransform(Matrix4.translation(0, 0, 10));
*/


// =========================================
// File: /raja/shape/MCone.java
// =========================================

/* 
 * Murat Inan
 * 
 * MCone.java - Corrected Ray Tracing Cone implementation
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

public class MCone extends BasicForm implements java.io.Serializable, Writable
{    
    protected Point3D apex;
    protected Vector3D axis;
    protected double height;
    protected double baseRadius;

    private Matrix4 transform = Matrix4.identity();
    private Matrix4 inverseTransform = Matrix4.identity();

    public MCone(Point3D apex, Vector3D axis, double height, double baseRadius)
    {
        this.apex = apex;
        this.axis = Vector3D.normalization(axis);
        this.height = height;
        this.baseRadius = baseRadius;
        updateTransforms();
    }

    public MCone(Point3D apex, Vector3D axis, double angle)
    {
        this.apex = apex;
        this.axis = Vector3D.normalization(axis);
        this.height = 10.0;
        this.baseRadius = this.height * Math.tan(angle); // Fixed: use this.height
        updateTransforms();
    }

    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        HashMap map = new HashMap();
        map.put("apex", null);
        map.put("axis", null);
        map.put("height", null);
        map.put("baseRadius", null);

        reader.readFields(map);

        return new MCone((Point3D) map.get("apex"),
                        (Vector3D) map.get("axis"),
                        ((Double) map.get("height")).doubleValue(),
                        ((Double) map.get("baseRadius")).doubleValue());
    }

    @Override
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        updateTransforms();
    }
    
    @Override
    public Matrix4 getTransform() {
        return this.transform;
    }
    
    private void updateTransforms() {
        Matrix4 inv = this.transform.inverse();
        this.inverseTransform = (inv != null) ? inv : Matrix4.identity();
    }

    @Override
    public Point3D computeIntersection(Ray r)
    {
        Point3D localOrigin = inverseTransform.transformPoint(r.origin);
        Vector3D localDirection = inverseTransform.transformVector(r.direction).normalization();
        
        Point3D baseCenter = new Point3D(apex, Vector3D.product(axis, height));
        
        Point3D coneIntersection = computeConeSurfaceIntersection(localOrigin, localDirection);
        Point3D baseIntersection = computeBaseIntersection(localOrigin, localDirection, baseCenter);
        
        return findClosestIntersection(coneIntersection, baseIntersection, localOrigin);
    }
    
    private Point3D computeConeSurfaceIntersection(Point3D origin, Vector3D direction) {
        // Ray: P = O + t*D
        // Cone: ((P-A)·V)² = cos²α * |P-A|²
        // where cos²α = h²/(h²+r²), and we use k = r/h for convenience
        
        Vector3D co = new Vector3D(apex, origin);
        double k = baseRadius / height;
        double cosAlphaSq = 1.0 / (1.0 + k * k);
        
        double dDotV = Vector3D.dotProduct(direction, axis);
        double coDotV = Vector3D.dotProduct(co, axis);
        double coDotCo = Vector3D.dotProduct(co, co);
        double dDotCo = Vector3D.dotProduct(direction, co);
        
        // Quadratic: a*t² + b*t + c = 0
        double a = dDotV * dDotV - cosAlphaSq;
        double b = 2.0 * (dDotV * coDotV - dDotCo * cosAlphaSq);
        double c = coDotV * coDotV - coDotCo * cosAlphaSq;
        
        double discriminant = b * b - 4.0 * a * c;
        
        if (discriminant < Ray.EPSILON2) {
            return null;
        }
        
        double sqrtDisc = Math.sqrt(discriminant);
        double t1 = (-b - sqrtDisc) / (2.0 * a);
        double t2 = (-b + sqrtDisc) / (2.0 * a);
        
        // Check both intersections for validity
        Point3D result1 = checkConeIntersection(origin, direction, t1);
        Point3D result2 = checkConeIntersection(origin, direction, t2);
        
        if (result1 != null && result2 != null) {
            return (t1 < t2) ? result1 : result2;
        }
        return (result1 != null) ? result1 : result2;
    }
    
    private Point3D checkConeIntersection(Point3D origin, Vector3D direction, double t) {
        if (t < Ray.EPSILON2) {
            return null;
        }
        
        Point3D p = new Point3D(origin, Vector3D.product(direction, t));
        
        // Verify point is within cone height bounds
        Vector3D toApex = new Vector3D(apex, p);
        double h = Vector3D.dotProduct(toApex, axis);
        
        if (h >= -Ray.EPSILON2 && h <= height + Ray.EPSILON2) {
            return p;
        }
        
        return null;
    }
    
    private Point3D computeBaseIntersection(Point3D origin, Vector3D direction, Point3D baseCenter) {
        // Plane equation: (P - C)·N = 0, where N = axis
        double denom = Vector3D.dotProduct(axis, direction);
        
        if (Math.abs(denom) < Ray.EPSILON2) {
            return null;
        }
        
        Vector3D oc = new Vector3D(origin, baseCenter);
        double t = Vector3D.dotProduct(oc, axis) / denom;
        
        if (t < Ray.EPSILON2) {
            return null;
        }
        
        Point3D intersection = new Point3D(origin, Vector3D.product(direction, t));
        
        // Check if point is within base circle
        Vector3D toCenter = new Vector3D(baseCenter, intersection);
        if (toCenter.norm() <= baseRadius + Ray.EPSILON2) {
            return intersection;
        }
        
        return null;
    }
    
    private Point3D findClosestIntersection(Point3D coneIntersection, Point3D baseIntersection, Point3D origin) {
        Point3D closest = null;
        double minDistSq = Double.POSITIVE_INFINITY;
        
        if (coneIntersection != null) {
            Vector3D v = new Vector3D(origin, coneIntersection);
            double distSq = Vector3D.dotProduct(v, v);
            if (distSq < minDistSq) {
                minDistSq = distSq;
                closest = coneIntersection;
            }
        }
        
        if (baseIntersection != null) {
            Vector3D v = new Vector3D(origin, baseIntersection);
            double distSq = Vector3D.dotProduct(v, v);
            if (distSq < minDistSq) {
                closest = baseIntersection;
            }
        }
        
        return closest != null ? transform.transformPoint(closest) : null;
    }

    @Override
    public Vector3D computeNormal(Point3D p)
    {
        Point3D localPoint = inverseTransform.transformPoint(p);
        Point3D baseCenter = new Point3D(apex, Vector3D.product(axis, height));
        
        Vector3D toBase = new Vector3D(baseCenter, localPoint);
        double distToBasePlane = Math.abs(Vector3D.dotProduct(toBase, axis));
        
        Vector3D normal;
        
        // Check if point is on base (within epsilon of base plane)
        if (distToBasePlane < Ray.EPSILON2 && toBase.norm() <= baseRadius + Ray.EPSILON2) {
            normal = Vector3D.product(axis, -1.0);
        } else {
            // Point is on cone surface
            Vector3D toApex = new Vector3D(apex, localPoint);
            double h = Vector3D.dotProduct(toApex, axis);
            
            // Project point onto axis to find nearest axis point
            Point3D axisPoint = new Point3D(apex, Vector3D.product(axis, h));
            Vector3D radial = new Vector3D(axisPoint, localPoint);
            double radialLen = radial.norm();
            
            if (radialLen < Ray.EPSILON2) {
                // At or very near the apex
                normal = radial.normalization();
            } else {
                // Cone surface normal: combine radial and axial components
                double k = baseRadius / height;
                Vector3D radialUnit = Vector3D.product(radial, 1.0 / radialLen);
                normal = Vector3D.sum(radialUnit, Vector3D.product(axis, -k)).normalization();
            }
        }
        
        return transform.transformVector(normal).normalization();
    }

    @Override
    public boolean exactlyContains(Point3D p)
    {
        Point3D localPoint = inverseTransform.transformPoint(p);
        
        Vector3D toApex = new Vector3D(apex, localPoint);
        double h = Vector3D.dotProduct(toApex, axis);
        
        if (h < -Ray.EPSILON2 || h > height + Ray.EPSILON2) {
            return false;
        }
        
        // At height h, the radius is: r(h) = (h/height) * baseRadius
        double currentRadius = (h / height) * baseRadius;
        Point3D axisPoint = new Point3D(apex, Vector3D.product(axis, h));
        double distanceToAxis = new Vector3D(axisPoint, localPoint).norm();
        
        return distanceToAxis <= currentRadius + Ray.EPSILON2;
    }

    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        Point3D localPoint = inverseTransform.transformPoint(p);
        
        Vector3D toApex = new Vector3D(apex, localPoint);
        double h = Vector3D.dotProduct(toApex, axis);
        
        if (h <= 0 || h >= height) {
            return false;
        }
        
        double currentRadius = (h / height) * baseRadius;
        Point3D axisPoint = new Point3D(apex, Vector3D.product(axis, h));
        double distanceToAxis = new Vector3D(axisPoint, localPoint).norm();
        
        return distanceToAxis < currentRadius;
    }

    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		String CONE_STR = "Constructor is: MCone(Point3D apex, Vector3D axis, double height, double baseRadius);\nExample -last value is volume-:\n0,0,0,  0,0,-1,  8.0,  3.0,  1\nEnter your values after three diyez symbol\n###\n";
		return CONE_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		this.exampleString = info;
		
		BasicForm bform = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return bform;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return bform;
		
			//0,0,0,  0,0,-1,  8.0, 3.0,  0.5
			try {
				double px = Double.parseDouble(split[0]);
				double py = Double.parseDouble(split[1]);
				double pz = Double.parseDouble(split[2]);
				
				double dx = Double.parseDouble(split[3]);
				double dy = Double.parseDouble(split[4]);
				double dz = Double.parseDouble(split[5]);
				
				double hg = Double.parseDouble(split[6]);
				double rd = Double.parseDouble(split[7]);
				
				bform = new MCone(new Point3D(px, py, pz), new Vector3D(dx, dy, dz), hg, rd);
				double vl = Double.parseDouble(split[8]);
				bform.setVolumeValue(vl);
				return bform;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	
	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////
	
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { 
            { "apex", apex },
            { "axis", axis },
            { "height", new Double(height) },
            { "baseRadius", new Double(baseRadius) }
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/shape/Volume.java
// =========================================

/* $Id: Volume.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.Point3D;


public interface Volume
{
    public double refractiveIndex(Point3D p);
}


// =========================================
// File: /raja/shape/IsotropicVolume.java
// =========================================

/* $Id: IsotropicVolume.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.Point3D;
import raja.io.*;
import java.util.HashMap;


public class IsotropicVolume implements Volume, java.io.Serializable, Writable
{
    double ri;

    public IsotropicVolume(double refractiveIndex)
    {
        ri = refractiveIndex;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Parsing */
	Number[] params = reader.readNumbers(1);
        
	return new IsotropicVolume(params[0].doubleValue());
    }

    public double refractiveIndex(Point3D p)
    {
        return ri;
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Number[] fields = { new Double(ri) };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/Sphere.java
// =========================================

/* $Id: Sphere.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class Sphere extends BasicForm implements java.io.Serializable, Writable
{
    protected Point3D center;
    protected double radius;

    public Sphere(Point3D center, double radius)
    {
        this.center = center;
        this.radius = radius;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();
        map.put("center",null);
	map.put("radius",null);

        /* Parsing */
	reader.readFields(map);

        return new Sphere((Point3D) map.get("center"),
			  ((Number) map.get("radius")).doubleValue());
    }
	
	@Override
    public Point3D computeIntersection(Ray r)
    {
        double a, b, c;

        Vector3D alpha = new Vector3D(center, r.origin);
        Vector3D beta = r.direction;

        a = beta.normSq();
        b = 2 * Vector3D.dotProduct(alpha, beta);
        c = alpha.normSq() - radius*radius;

        return solve2ndOrder(a, b, c, r);
    }
    @Override
    public boolean exactlyContains(Point3D p)
    {
        return (Point3D.distance(p, center) <= radius);
    }
    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        return (Point3D.distance(p, center) < radius);
    }
    @Override
    public Vector3D computeNormal(Point3D p)
    {
        Vector3D result = new Vector3D(center, p);
        return Vector3D.normalization(result);
    }
	
	// ADDED by Murat Inan
	@Override
	public void setTransform(Matrix4 mtrx) {
		return;
	}
	
	@Override
	public Matrix4 getTransform() {
		return new Matrix4();
	}
    ////////////////////
    
    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		return "";
	}
	
   @Override
   public String toExampleString() {
     return "null";
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		return new Sphere(new Point3D(0, 0, 0), 1.0);
	}
	
	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////////
	
    @Override
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "center", center },
                              { "radius", new Double(radius) } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/BasicTexturedForm.java
// =========================================

/* $Id: BasicTexturedForm.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class BasicTexturedForm implements TexturedForm, java.io.Serializable, Writable
{
    private Form form;
    private Texture in, out;

    public BasicTexturedForm(Form f, Texture in, Texture out)
    {
        this.form = f;
        this.in   = in;
        this.out  = out;
    }

    public BasicTexturedForm(Form f, Texture texture)
    {
        this.form = f;
        this.in   = texture;
        this.out  = texture;
    }
	
	// ADDED by Murat Inan
	public Form getForm() {
		return this.form;
	}
	public Texture getTextureIN() {
		return this.in;
	}
	public Texture getTextureOUT() {
		return this.out;
	}
	////////////////
	
    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("form",null);
	map.put("texture",null);
	map.put("textureIn",null);
	map.put("textureOut",null);
	
	/* Parsing */
	reader.readFields(map);

        if (map.get("texture") != null)
	    { 
                return new BasicTexturedForm((Form) map.get("form"),
                                             (Texture) map.get("texture"));
	    }
        else
            {
                return new BasicTexturedForm((Form) map.get("form"),
                                             (Texture) map.get("textureIn"),
                                             (Texture) map.get("textureOut"));
            }
    }

    public TexturedLocalGeometry intersection(Ray r)
    {
        class BasicTexturedLocalGeometry extends TexturedLocalGeometry
        {
            Texture in, out;

            BasicTexturedLocalGeometry(LocalGeometry lgf, Texture in, Texture out)
            {
                super(lgf);
                this.in  = in;
                this.out = out;
            }

            public LocalTexture getInLocalTexture()
            {
                return in.getLocalTexture(this);
            }
            public LocalTexture getOutLocalTexture()
            {
                return out.getLocalTexture(this);
            }
        }

        LocalGeometry intersection = form.intersection(r);

        if (intersection == null) {
            return null;
        }
        else {
            return new BasicTexturedLocalGeometry(intersection, in, out);
        }
    }
    public boolean intersects(LightRay r)
    {
        return form.intersects(r);
    }
    public boolean contains(Point3D p)
    {
        return form.contains(p);
    }
    public boolean strictlyContains(Point3D p)
    {
        return form.strictlyContains(p);
    }
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    
    // ADDED by Murat Inan for transform support
    public void write(ObjectWriter writer) throws java.io.IOException
	{
		Object[][] fields;

		// Form'un transform'unu al (BasicForm olduğunu biliyoruz ve null olamaz)
		Matrix4 transform = ((BasicForm)form).getTransform();

		if (in == out) {
			fields = new Object[3][2];
			fields[0][0] = "form";
			fields[0][1] = form;
			fields[1][0] = "texture";
			fields[1][1] = in;
			fields[2][0] = "transform";
			fields[2][1] = transform;
		}
		else {
			fields = new Object[4][2];
			fields[0][0] = "form";
			fields[0][1] = form;
			fields[1][0] = "textureIn";
			fields[1][1] = in;
			fields[2][0] = "textureOut";
			fields[2][1] = out;
			fields[3][0] = "transform";
			fields[3][1] = transform;
		}

		writer.writeFields(fields);
	}

    // Original write method
    /**
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields;

        if (in == out) {
            fields = new Object[2][2];
            fields[1][0] = "texture";
            fields[1][1] = in;
        }
        else {
            fields = new Object[3][2];
            fields[1][0] = "textureIn";
            fields[1][1] = in;
            fields[2][0] = "textureOut";
            fields[2][1] = out;
        }

        fields[0][0] = "form";
        fields[0][1] = form;

        writer.writeFields(fields);
    }
    */
}


// =========================================
// File: /raja/shape/CompositeForm.java
// =========================================

/* $Id: CompositeForm.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import raja.util.List;

import java.util.HashMap;
import java.util.Iterator;


public abstract class CompositeForm implements TexturedForm, java.io.Serializable, Writable
{
    private List texturedForms;

    public CompositeForm()
    {
        texturedForms = new List();
    }

    public CompositeForm(List texturedForms)
    {
        this.texturedForms = texturedForms;
    }

    public void addForm(TexturedForm f)
    {
        texturedForms.add(f);
    }
    protected Iterator formIterator()
    {
        return texturedForms.iterator();
    }

    public abstract TexturedLocalGeometry intersection(Ray r);
    public abstract boolean contains(Point3D p);
    public abstract boolean strictlyContains(Point3D p);

    public boolean intersects(LightRay r)
    {
        Point3D intersection = intersection(r);
        if (intersection != null) {
            double d = Point3D.distance(r.origin, intersection);
            if (d < r.distance) {
                return true;
            }
        }
        return false;
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "texturedForms", texturedForms } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/MTorus.java
// =========================================

// Murat Inan
package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

/**
 * Represents a torus defined by a major radius (distance from center to tube center)
 * and a minor radius (radius of the tube itself).
 * Supports arbitrary position and orientation via a 4x4 transformation matrix.
 * Uses Ray.EPSILON2 for consistent epsilon values throughout the implementation.
 */
public class MTorus extends BasicForm implements java.io.Serializable, Writable {
    private static final long serialVersionUID = 1L;
    private static final double MAX_DISTANCE = 50.0;
    private static final int MAX_ITERATIONS = 100;
    private static final double SURFACE_THRESHOLD = 0.1;

    private double majorRadius;
    private double minorRadius;

    private Matrix4 transform = Matrix4.identity();
    private Matrix4 inverseTransform = Matrix4.identity();

    // Orientation basis vectors derived from the transform
    private Vector3D ox = new Vector3D(1, 0, 0); // Local X-axis
    private Vector3D oy = new Vector3D(0, 1, 0); // Local Y-axis
    private Vector3D oz = new Vector3D(0, 0, 1); // Local Z-axis

    /**
     * Constructs a torus centered at the origin with given radii.
     * 
     * @param majorRadius the distance from center to tube center, must be positive
     * @param minorRadius the radius of the tube itself, must be positive and smaller than major radius
     * @throws IllegalArgumentException if radii are invalid
     */
    public MTorus(double majorRadius, double minorRadius) {
        if (majorRadius <= Ray.EPSILON2 || minorRadius <= Ray.EPSILON2) {
            throw new IllegalArgumentException("Radii must be positive");
        }
        if (minorRadius >= majorRadius) {
            throw new IllegalArgumentException("Minor radius must be smaller than major radius");
        }
        this.majorRadius = majorRadius;
        this.minorRadius = minorRadius;
        updateTransforms();
    }

    /**
     * Builds an MTorus instance from ObjectReader data.
     */
    public static Object build(ObjectReader reader) throws java.io.IOException {
        HashMap<String, Object> map = new HashMap<>();
        map.put("majorRadius", null);
        map.put("minorRadius", null);
        reader.readFields(map);
        return new MTorus((Double) map.get("majorRadius"), (Double) map.get("minorRadius"));
    }

    /**
     * Sets the transformation matrix and updates derived data (inverse and orientation).
     * 
     * @param transform the transformation matrix to apply
     */
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        updateTransforms();
        updateOrientationVectors();
    }
    
    /**
     * Gets the current transformation matrix.
     * 
     * @return the current transformation matrix
     */
    public Matrix4 getTransform() {
        return this.transform;
    }
    
    /**
     * Updates the inverse transformation matrix.
     * Falls back to identity matrix if inversion fails.
     */
    private void updateTransforms() {
        Matrix4 inv = this.transform.inverse();
        this.inverseTransform = (inv != null) ? inv : Matrix4.identity();
    }

    /**
     * Extracts the local orientation basis vectors from the current transform matrix.
     * These vectors represent the local coordinate system of the torus.
     */
    private void updateOrientationVectors() {
        this.ox = transform.transformVector(new Vector3D(1, 0, 0)).normalization();
        this.oy = transform.transformVector(new Vector3D(0, 1, 0)).normalization();
        this.oz = transform.transformVector(new Vector3D(0, 0, 1)).normalization();
    }

    /**
     * Computes the signed distance function (SDF) in local space.
     * Positive: outside, Negative: inside, Zero: on surface.
     * 
     * @param P the point in local space to evaluate
     * @return the signed distance from the point to the torus surface
     */
private double calculateSDFLocal(Point3D P) {
    // Optimize edilmiş SDF hesaplama
    double dx = -P.x;
    double dy = -P.y; 
    double dz = -P.z;

    // Daha hızlı projection
    double projX = dx * ox.x + dy * ox.y + dz * ox.z;
    double projY = dx * oy.x + dy * oy.y + dz * oy.z;
    
    double radialDist = Math.sqrt(projX * projX + projY * projY);
    double axialDist = Math.sqrt(dx*dx + dy*dy + dz*dz - projX*projX - projY*projY);
    
    // Daha kararlı hesaplama
    return Math.sqrt((radialDist - majorRadius) * (radialDist - majorRadius) + axialDist * axialDist) - minorRadius;
}

    /**
     * Computes the intersection point between the ray and the torus using sphere tracing.
     * 
     * @param ray the ray to test for intersection
     * @return the intersection point in world coordinates, or null if no intersection
     */
// This makes inner shadow too.
@Override
public Point3D computeIntersection(Ray ray) {
    Point3D localOrigin = inverseTransform.transformPoint(ray.getOrigin());
    Vector3D localDirection = inverseTransform.transformVector(ray.getDirection()).normalization();

    // Shadow ray'ler için daha agresif parametreler
    final double SHADOW_THRESHOLD = 0.01; // Daha yüksek threshold
    final int SHADOW_ITERATIONS = 50;     // Daha az iteration
    
    double t = 0.0;
    Point3D p = localOrigin;

    for (int i = 0; i < SHADOW_ITERATIONS; i++) {
        double dist = calculateSDFLocal(p);
        
        // Shadow ray'ler için daha liberal intersection test
        if (Math.abs(dist) < SHADOW_THRESHOLD) {
            if (hasLG(ray.getOrigin())) {
                return null;
            }
            Point3D localHit = new Point3D(
                p.x + localDirection.x * dist,
                p.y + localDirection.y * dist, 
                p.z + localDirection.z * dist
            );
            return transform.transformPoint(localHit);
        }
        
        // Negatif distance durumunda (içerideysek) hemen return
        if (dist < 0) {
            Point3D localHit = new Point3D(
                p.x + localDirection.x * Math.abs(dist),
                p.y + localDirection.y * Math.abs(dist),
                p.z + localDirection.z * Math.abs(dist)
            );
            return transform.transformPoint(localHit);
        }
        
        t += Math.abs(dist);
        if (t > MAX_DISTANCE) break;
        
        p = new Point3D(
            p.x + localDirection.x * dist,
            p.y + localDirection.y * dist,
            p.z + localDirection.z * dist
        );
    }
    return null;
}

// This make semi-torus
/**
@Override
public Point3D computeIntersection(Ray ray) {
    Point3D localOrigin = inverseTransform.transformPoint(ray.getOrigin());
    Vector3D localDirection = inverseTransform.transformVector(ray.getDirection()).normalization();

    double t = 0.0;
    Point3D p = localOrigin;

    for (int i = 0; i < MAX_ITERATIONS; i++) {
        double dist = calculateSDFLocal(p);
        if (Math.abs(dist) < SURFACE_THRESHOLD) {
            // Işın geldiği yüzeyin normali ile ışın yönünü karşılaştır
            Vector3D normal = computeNormal(transform.transformPoint(p));
            double dot = Vector3D.dotProduct(normal, ray.getDirection());
            
            // Sadece ön yüzeylerden gölge düşsün (back-face culling)
            if (dot > 0) { // Back face - gölge düşürme
                return null;
            }
            
            if (hasLG(ray.getOrigin())) {
                return null;
            }
            return transform.transformPoint(p);
        }
        t += dist;
        if (t > MAX_DISTANCE) return null;
        p = new Point3D(p.x + localDirection.x * dist, p.y + localDirection.y * dist, p.z + localDirection.z * dist);
    }
    return null;
}
*/

    /**
     * Computes the surface normal at the given point on the torus.
     * 
     * @param worldPoint the point on the surface in world coordinates
     * @return the normalized surface normal vector
     */
@Override
public Vector3D computeNormal(Point3D worldPoint) {
    // Basit ve garantili normal hesapla
    Point3D localPoint = inverseTransform.transformPoint(worldPoint);
    
    // Merkeze göre vektör
    Vector3D toCenter = new Vector3D(localPoint, new Point3D(0, 0, 0));
    
    // Düzlem projeksiyonu
    double projX = Vector3D.dotProduct(toCenter, ox);
    double projY = Vector3D.dotProduct(toCenter, oy);
    
    Vector3D radial = new Vector3D(
        ox.x * projX + oy.x * projY,
        ox.y * projX + oy.y * projY, 
        ox.z * projX + oy.z * projY
    );
    
    Vector3D localNormal = new Vector3D(localPoint.x - radial.x, 
                                      localPoint.y - radial.y, 
                                      localPoint.z - radial.z).normalization();
    
    return transform.transformVector(localNormal).normalization();
}

    /**
     * Computes normal using finite differences for numerical stability in degenerate cases.
     * 
     * @param localPoint the point in local coordinates
     * @return the normalized normal vector
     */
    private Vector3D computeNormalFiniteDifference(Point3D localPoint) {
        final double DELTA = 1e-6;
        
        double sdfCenter = calculateSDFLocal(localPoint);
        
        double sdfX = calculateSDFLocal(new Point3D(localPoint.x + DELTA, localPoint.y, localPoint.z));
        double sdfY = calculateSDFLocal(new Point3D(localPoint.x, localPoint.y + DELTA, localPoint.z));
        double sdfZ = calculateSDFLocal(new Point3D(localPoint.x, localPoint.y, localPoint.z + DELTA));
        
        Vector3D gradient = new Vector3D(
            (sdfX - sdfCenter) / DELTA,
            (sdfY - sdfCenter) / DELTA,
            (sdfZ - sdfCenter) / DELTA
        );
        
        Vector3D localNormal = gradient.normalization();
        return transform.transformVector(localNormal).normalization();
    }

    /**
     * Checks if the point is inside or on the surface of the torus.
     * 
     * @param p the point to test in world coordinates
     * @return true if the point is inside or on the surface, false otherwise
     */
    @Override
    public boolean exactlyContains(Point3D p) {
        Point3D localPoint = inverseTransform.transformPoint(p);
        return calculateSDFLocal(localPoint) <= Ray.EPSILON2;
    }

    /**
     * Checks if the point is strictly inside the torus (not on surface).
     * 
     * @param p the point to test in world coordinates
     * @return true if the point is strictly inside, false otherwise
     */
    @Override
    public boolean exactlyStrictlyContains(Point3D p) {
        Point3D localPoint = inverseTransform.transformPoint(p);
        return calculateSDFLocal(localPoint) < -Ray.EPSILON2;
    }

    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		String TORUS_STR = "Constructor is: MTorus(double majorRadius, double minorRadius);\nExample -last value is volume-:\n0.9,  0.4,  1\nEnter your values after three diyez symbol\n###\n";
		return TORUS_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		this.exampleString = info;
		
		BasicForm bform = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return bform;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return bform;

			//0.9,  0.4,  0.5
			try {
				double mjr = Double.parseDouble(split[0]);			
				double mnr = Double.parseDouble(split[1]);

				bform = new MTorus(mjr, mnr);
				double vl = Double.parseDouble(split[2]);
				bform.setVolumeValue(vl);
				return bform;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	
	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////
	
    /**
     * Returns a string representation of the torus.
     * 
     * @return string representation
     */
    @Override
    public String toString() {
        return ObjectWriter.toString(this);
    }

    /**
     * Writes the torus data to an ObjectWriter.
     * 
     * @param writer the ObjectWriter to write to
     * @throws java.io.IOException if writing fails
     */
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = {
            { "majorRadius", majorRadius },
            { "minorRadius", minorRadius }
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/shape/Complement.java
// =========================================

/* $Id: Complement.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class Complement implements TexturedForm, java.io.Serializable, Writable
{
    private TexturedForm texturedForm;

    public Complement(TexturedForm f)
    {
        texturedForm = f;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();
        
	map.put("texturedForm",null);
	
	/* Parsing */
	reader.readFields(map);
        
        return new Complement((TexturedForm) map.get("texturedForm"));
    }

    public TexturedLocalGeometry intersection(Ray r)
    {
        class ComplementTexturedLocalGeometry extends TexturedLocalGeometry
        {
            TexturedLocalGeometry lgf;

            ComplementTexturedLocalGeometry(TexturedLocalGeometry lgf)
            {
                super(lgf);
                this.lgf = lgf;
            }

            AcneCorrection getAcneCorrection()
            {
                return lgf.getAcneCorrection();
            }
            public Vector3D getNormal()
            {
                return Vector3D.opposite(lgf.getNormal());
            }
            public LocalTexture getInLocalTexture()
            {
                return lgf.getOutLocalTexture();
            }
            public LocalTexture getOutLocalTexture()
            {
                return lgf.getInLocalTexture();
            }
        }

        TexturedLocalGeometry intersection = texturedForm.intersection(r);

        if (intersection == null) {
            return null;
        }
        else {
            return new ComplementTexturedLocalGeometry(intersection);
        }
    }
    public boolean intersects(LightRay r)
    {
        return texturedForm.intersects(r);
    }
    public boolean contains(Point3D p)
    {
        return (! texturedForm.strictlyContains(p));
    }
    public boolean strictlyContains(Point3D p)
    {
        return (! texturedForm.contains(p));
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "texturedForm", texturedForm } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/SolidLocalGeometry.java
// =========================================

/* $Id: SolidLocalGeometry.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;


public class SolidLocalGeometry extends TexturedLocalGeometry
{
    private TexturedLocalGeometry tlg;
    private Volume in, out;

    protected SolidLocalGeometry(TexturedLocalGeometry tlg)
    {
        super(tlg);
        this.tlg = tlg;
        in = null;
        out = null;
    }

    public LocalTexture getInLocalTexture()
    {
        return tlg.getInLocalTexture();
    }
    public LocalTexture getOutLocalTexture()
    {
        return tlg.getOutLocalTexture();
    }
    public double getInRefractiveIndex()
    {
        return in.refractiveIndex(this);
    }
    public double getOutRefractiveIndex()
    {
        return out.refractiveIndex(this);
    }
    public boolean inVolumeUndefined()
    {
        return (in == null);
    }
    public boolean outVolumeUndefined()
    {
        return (out == null);
    }
    void setInVolume(Volume v)
    {
        in = v;
    }
    void setOutVolume(Volume v)
    {
        out = v;
    }
}


// =========================================
// File: /raja/shape/Aggregate.java
// =========================================

/* $Id: Aggregate.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import raja.util.List;
import raja.util.DirectedGraph;

import java.util.Map;
import java.util.HashMap;
import java.util.TreeMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Comparator;


public class Aggregate implements Solid, java.io.Serializable, Writable
{
    private List solids;
    private DirectedGraph priorities;

    public Aggregate()
    {
        solids = new List();
        priorities = new DirectedGraph();
    }
	
	// ADDED by Murat Inan
	public raja.util.List getList() {
		return solids;
	}
	
    public Aggregate(List solids, DirectedGraph priorities)
    {
        for(Iterator iterEdges = priorities.edges() ; iterEdges.hasNext() ;)
        {
            DirectedGraph.Edge currentEdge = (DirectedGraph.Edge) iterEdges.next();

            if ((currentEdge.getSource() == currentEdge.getDest()) ||
                priorities.hasEdge(currentEdge.getDest(), currentEdge.getSource()))
            {
                //throw new IllegalArgumentException(priorities.toString());
            }
        }

        this.solids = solids;
        this.priorities = priorities;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("solids", null);
	map.put("priorities", null);

	/* Parsing */
	reader.readFields(map);

        return new Aggregate((List) map.get("solids"),
                             (DirectedGraph) map.get("priorities"));
    }

    public void addSolid(Solid solid)
    {
        solids.add(solid);
    }
    public void addPriority(Solid major, Solid minor)
    {
        if ((major == minor) ||
            priorities.hasEdge(minor, major))
        {
            //throw new IllegalArgumentException();
        }
        priorities.addEdge(major, minor);
    }

    private boolean hasPriority(Solid major, Solid minor)
    {
        return priorities.hasEdge(major, minor);
    }
    private boolean hasPriority(Solid major, Set minors)
    {
        return priorities.hasEdges(major, minors);
    }
    private Solid mainSolid(Set set)
    {
        if (set.isEmpty()) {
            return null;
        }

        Iterator iterSolid = set.iterator();
        Solid main = (Solid) iterSolid.next();

        while (iterSolid.hasNext())
        {
            Solid currentSolid = (Solid) iterSolid.next();
            if (hasPriority(currentSolid, main)) {
                main = currentSolid;
            }
        }

        set.remove(main);

        if (hasPriority(main, set)) {
            set.add(main);
            return main;
        }
        else
        {
            return main;
            //throw new IllegalArgumentException("Could not determine main solid of: " + set  + " with priorities: " + priorities);
        }
    }

    public SolidLocalGeometry intersection(Ray r)
    {
        class Point3DComparator implements Comparator
        {
            private Point3D p;

            Point3DComparator(Point3D p)
            {
                this.p = p;
            }

            public int compare(Object o1, Object o2)
            {
                SolidLocalGeometry slg1 = (SolidLocalGeometry) o1;
                SolidLocalGeometry slg2 = (SolidLocalGeometry) o2;

                double d1 = Point3D.distanceSq(p, slg1);
                double d2 = Point3D.distanceSq(p, slg2);

                if (d1 < d2) {
                    return -1;
                }
                else if (d1 > d2) {
                    return 1;
                }
                return (slg1.hashCode() - slg2.hashCode());
            }
        }

        TreeMap Intersections = new TreeMap(new Point3DComparator(r.origin));

        for(Iterator iterSolid = solids.iterator() ; iterSolid.hasNext() ;)
        {
            Solid currentSolid = (Solid) iterSolid.next();
            SolidLocalGeometry currentIntersection = currentSolid.intersection(r);
            if (currentIntersection != null) {
                Intersections.put(currentIntersection, currentSolid);
            }
        }

        if (Intersections.isEmpty()) {
            return null;
        }

        SolidLocalGeometry first = (SolidLocalGeometry) Intersections.firstKey();

        Set formsIn = new HashSet();

        for(Iterator iterSolid = solids.iterator() ; iterSolid.hasNext() ;)
        {
            Solid currentSolid = (Solid) iterSolid.next();
            if (currentSolid.strictlyContains(first)) {
                formsIn.add(currentSolid);
            }
        }

        Solid firstSolid = (Solid) Intersections.get(first);

        if (! firstSolid.strictlyContains(first)) {
            if (Vector3D.dotProduct(r.direction, first.getNormal()) > 0) {
                formsIn.add(firstSolid);
            }
        }

        if (formsIn.isEmpty()) {
            return first;
        }

        Solid mainSolid = mainSolid(formsIn);

        SolidLocalGeometry validIntersection = null;

        for(Iterator iterIntersections = Intersections.entrySet().iterator() ; iterIntersections.hasNext() ;)
        {
            Map.Entry currentEntry = (Map.Entry) iterIntersections.next();
            SolidLocalGeometry currentIntersection = (SolidLocalGeometry) currentEntry.getKey();
            Solid currentSolid = (Solid) currentEntry.getValue();

            if (currentSolid == mainSolid) {

                validIntersection = currentIntersection;

                if (validIntersection.inVolumeUndefined()) {
                    throw new Error("Error in Aggregate: inVolume is undefined");
                }

                if (validIntersection.outVolumeUndefined()) {
                    // The ray leaves mainSolid at this intersection
                    formsIn.remove(mainSolid);

                    Set newFormsIn = new HashSet();

                    for(Iterator iterSolid = formsIn.iterator() ; iterSolid.hasNext() ;)
                    {
                        Solid newCurrentSolid = (Solid) iterSolid.next();
                        if (newCurrentSolid.strictlyContains(validIntersection)) {
                            newFormsIn.add(newCurrentSolid);
                        }
                    }

                    if (! newFormsIn.isEmpty()) {
                        Solid newMainSolid = mainSolid(newFormsIn);
                        validIntersection.setOutVolume(newMainSolid);
                    }
                }
                break;
            }
            else if (hasPriority(currentSolid, mainSolid)) {
                // The ray enters currentSolid at this intersection

                validIntersection = currentIntersection;

                if (validIntersection.inVolumeUndefined()) {
                    throw new Error("Error in Aggregate: inVolume is undefined");
                }

                if (! validIntersection.outVolumeUndefined()) {
                    throw new Error("Error in Aggregate: outVolume should be undefined");
                }

                validIntersection.setOutVolume(mainSolid);
                break;
            }
            else if (! hasPriority(mainSolid, currentSolid)) {
            //    throw new IllegalArgumentException("Unknown priority between " + mainSolid + " and " + currentSolid);
            }
            else
            {
                formsIn.add(currentSolid);
            }
        }

        return validIntersection;
    }

    public boolean intersects(LightRay r)
    {
        Point3D intersection = intersection(r);
        if (intersection != null) {
            double d = Point3D.distance(r.origin, intersection);
            if (d < r.distance) {
                return true;
            }
        }
        return false;
    }

    public boolean contains(Point3D p)
    {
        for(Iterator iterSolid = solids.iterator() ; iterSolid.hasNext() ;)
        {
            Solid currentSolid = (Solid) iterSolid.next();
            if (currentSolid.contains(p)) {
                return true;
            }
        }
        return false;
    }
    public boolean strictlyContains(Point3D p)
    {
        for(Iterator iterSolid = solids.iterator() ; iterSolid.hasNext() ;)
        {
            Solid currentSolid = (Solid) iterSolid.next();
            if (currentSolid.strictlyContains(p)) {
                return true;
            }
        }
        return false;
    }

    public double refractiveIndex(Point3D p)
    {
        Set formsIn = new HashSet();

        for(Iterator iterSolid = solids.iterator() ; iterSolid.hasNext() ;)
        {
            Solid currentSolid = (Solid) iterSolid.next();
            if (currentSolid.contains(p)) {
                formsIn.add(currentSolid);
            }
        }

        Solid mainSolid = mainSolid(formsIn);
        return mainSolid.refractiveIndex(p);
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "solids", solids },
                              { "priorities", priorities } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/Union.java
// =========================================

/* $Id: Union.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import raja.util.List;

import java.util.HashMap;
import java.util.Iterator;


public class Union extends CompositeForm implements java.io.Serializable
{
    public Union()
    {
        super();
    }

    public Union(List texturedForms)
    {
        super(texturedForms);
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();
        
	map.put("texturedForms",null);
	
	/* Parsing */
	reader.readFields(map);
        
        return new Union((List) map.get("texturedForms"));
    }

    public TexturedLocalGeometry intersection(Ray r)
    {
        List formsToIntersect = new List();

        for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            if (currentForm.strictlyContains(r.origin)) {
                formsToIntersect.add(currentForm);
            }
        }

        if (formsToIntersect.isEmpty()) {
            TexturedLocalGeometry intersection = null;
            double dist = Double.POSITIVE_INFINITY;

            for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
            {
                TexturedForm currentForm = (TexturedForm) iterForm.next();
                TexturedLocalGeometry currentIntersection = currentForm.intersection(r);

                if (currentIntersection != null) {
                    double currentDist = Point3D.distanceSq(r.origin, currentIntersection);
                    if (currentDist < dist) {
                        intersection = currentIntersection;
                        dist = currentDist;
                    }
                }
            }

            if (intersection == null) {
                return null;
            }
            if (! strictlyContains(intersection)) {
                return intersection;
            }

            List newFormsToIntersect = new List();

            for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
            {
                TexturedForm currentForm = (TexturedForm) iterForm.next();
                if (currentForm.strictlyContains(intersection)) {
                    newFormsToIntersect.add(currentForm);
                }
            }
            Ray newR = new Ray(intersection, r.direction);
            return recursiveIntersection(newR, newFormsToIntersect);
        }
        return recursiveIntersection(r, formsToIntersect);
    }
    private TexturedLocalGeometry recursiveIntersection(Ray r, List formsToIntersect)
    {
        TexturedLocalGeometry intersection = null;
        double dist = 0;

        for(Iterator iterForm = formsToIntersect.iterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            TexturedLocalGeometry currentIntersection = currentForm.intersection(r);

            if (currentIntersection == null)
            {
                return null;
            }
            else
            {
                double currentDist = Point3D.distanceSq(r.origin, currentIntersection);
                if (currentDist > dist)
                {
                    intersection = currentIntersection;
                    dist = currentDist;
                }
            }
        }

        List newFormsToIntersect = new List();

        for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            if (currentForm.strictlyContains(intersection)) {
                newFormsToIntersect.add(currentForm);
            }
        }

        if (newFormsToIntersect.isEmpty()) {
            return intersection;
        }
        else {
            Ray newR = new Ray(intersection, r.direction);
            return recursiveIntersection(newR, newFormsToIntersect);
        }
    }

    public boolean intersects(LightRay r)
    {
        if (contains(r.origin)) {
            return super.intersects(r);
        }
        else {
            for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
            {
                TexturedForm currentForm = (TexturedForm) iterForm.next();
                if (currentForm.intersects(r)) {
                    return true;
                }
            }
            return false;
        }
    }

    public boolean contains(Point3D p)
    {
        for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            if (currentForm.contains(p)) {
                return true;
            }
        }
        return false;
    }
    public boolean strictlyContains(Point3D p)
    {
        for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            if (currentForm.strictlyContains(p)) {
                return true;
            }
        }
        return false;
    }
}


// =========================================
// File: /raja/shape/Billboard.java
// =========================================

// Murat Inan
package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

/**
 * A 2D quad in 3D space for displaying images or transparent textures.
 * Always faces the camera (billboard effect). Supports both rectangular and oval shapes.
 */
public class Billboard extends BasicForm implements java.io.Serializable, Writable
{
    private double width;
    private double height;
    private boolean isRectangle;
    
    private Matrix4 transform = Matrix4.identity();
    private Matrix4 inverseTransform = Matrix4.identity();

    /**
     * Constructs a rectangular billboard with specified width and height.
     * 
     * @param width the width of the billboard (X ekseni)
     * @param height the height of the billboard (Y ekseni)
     */
    public Billboard(double width, double height) {
        this.width = width;
        this.height = height;
        this.isRectangle = true;
    }
	
	public Billboard() {
		this(20.0, 10.0, false);
	}
	
    /**
     * Constructs a square billboard with specified size.
     * 
     * @param size the size of the billboard (both width and height)
     */
    public Billboard(double size) {
        this(size, size);
    }

    /**
     * Constructs an oval/elliptical billboard with specified width and height.
     * 
     * @param width the width of the oval (X ekseni)
     * @param height the height of the oval (Y ekseni)
     * @param isRectangle false for oval shape
     */
    public Billboard(double width, double height, boolean isRectangle) {
        this.width = width;
        this.height = height;
        this.isRectangle = isRectangle;
    }

public static Object build(ObjectReader reader) throws java.io.IOException {
    HashMap map = new HashMap();
    map.put("width", null);
    map.put("height", null);
    map.put("isRectangle", Double.valueOf(1.0)); // 1.0 = rectangle, 0.0 = oval

    reader.readFields(map);

    double width = ((Number) map.get("width")).doubleValue();
    double height = ((Number) map.get("height")).doubleValue();
    double rectFlag = ((Number) map.get("isRectangle")).doubleValue();
    boolean isRect = (rectFlag != 0.0);

    return new Billboard(width, height, isRect);
}
    
    @Override
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        Matrix4 inv = transform.inverse();
        this.inverseTransform = (inv != null) ? inv : Matrix4.identity();
    }
    
    @Override
    public Matrix4 getTransform() {
        return this.transform;
    }

@Override
public Point3D computeIntersection(Ray r) {
    Point3D localOrigin = inverseTransform.transformPoint(r.origin);
    Vector3D localDirection = inverseTransform.transformVector(r.direction).normalization();

    if (Math.abs(localDirection.z) < 1e-12) {
        return null;
    }
    
    double t = -localOrigin.z / localDirection.z;
    if (t < 1e-6) {
        return null;
    }
    
    // SWAP: X ve Y'yi değiştir
    Point3D localHit = new Point3D(
        localOrigin.y + localDirection.y * t,  // Y -> X (width)
        localOrigin.x + localDirection.x * t,  // X -> Y (height) 
        0
    );
    
    boolean withinBounds;
    if (isRectangle) {
        double halfWidth = width / 2.0;
        double halfHeight = height / 2.0;
        // SWAP: Artık localHit.x = width, localHit.y = height
        withinBounds = Math.abs(localHit.x) <= halfWidth && Math.abs(localHit.y) <= halfHeight;
    } else {
        double rx = width / 2.0;
        double ry = height / 2.0;
        double nx = localHit.x / rx;
        double ny = localHit.y / ry;
        withinBounds = (nx * nx + ny * ny) <= 1.0;
    }
    
    if (!withinBounds) {
        return null;
    }
    
    if (hasLG(r.origin)) {
        return null;
    }
    
    // SWAP: Geri transform etmeden önce tekrar swap
    Point3D correctedHit = new Point3D(localHit.y, localHit.x, 0);
    return transform.transformPoint(correctedHit);
}

@Override
public boolean exactlyContains(Point3D p) {
    Point3D localPoint = inverseTransform.transformPoint(p);
    
    // SWAP: X ve Y
    Point3D swappedPoint = new Point3D(localPoint.y, localPoint.x, localPoint.z);
    
    if (Math.abs(swappedPoint.z) > 1e-6) {
        return false;
    }
    
    if (isRectangle) {
        double halfWidth = width / 2.0;
        double halfHeight = height / 2.0;
        return Math.abs(swappedPoint.x) <= halfWidth && Math.abs(swappedPoint.y) <= halfHeight;
    } else {
        double rx = width / 2.0;
        double ry = height / 2.0;
        double nx = swappedPoint.x / rx;
        double ny = swappedPoint.y / ry;
        return (nx * nx + ny * ny) <= 1.0;
    }
}

@Override
public boolean exactlyStrictlyContains(Point3D p) {
    Point3D localPoint = inverseTransform.transformPoint(p);
    
    // SWAP: X ve Y
    Point3D swappedPoint = new Point3D(localPoint.y, localPoint.x, localPoint.z);
    
    if (Math.abs(swappedPoint.z) > 1e-6) {
        return false;
    }
    
    if (isRectangle) {
        double halfWidth = width / 2.0;
        double halfHeight = height / 2.0;
        return Math.abs(swappedPoint.x) < halfWidth && Math.abs(swappedPoint.y) < halfHeight;
    } else {
        double rx = width / 2.0;
        double ry = height / 2.0;
        double nx = swappedPoint.x / rx;
        double ny = swappedPoint.y / ry;
        return (nx * nx + ny * ny) < 1.0;
    }
}

    @Override
    public Vector3D computeNormal(Point3D p) {
        Vector3D localNormal = new Vector3D(0, 0, 1);
        return transform.transformVector(localNormal).normalization();
    }
    
    public double getWidth() {
        return width;
    }
    
    public double getHeight() {
        return height;
    }
    
    public boolean isRectangle() {
        return isRectangle;
    }

    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		String BILLBOARD_STR = "Constructor is: Billboard(double width, double height, boolean isRectangle);\nExample -last value is volume-:\n3.0,  1.5,  true,  1\nNote that this shape is convenient for TransparentPNGTexture.\nEnter your values after three diyez symbol\n###\n";
		return BILLBOARD_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		this.exampleString = info;
		
		BasicForm bform = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return bform;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return bform;
		
			try {
				double wd = Double.parseDouble(split[0]);			
				double hd = Double.parseDouble(split[1]);
				
				boolean ir = Boolean.parseBoolean(split[2]);
				
				bform = new Billboard(wd, hd, ir);
				double vl = Double.parseDouble(split[3]);
				bform.setVolumeValue(vl);
				return bform;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}

	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////

    @Override
    public String toString() {
        return ObjectWriter.toString(this);
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException {
        Object[][] fields = { 
            { "width", new Double(width) },
            { "height", new Double(height) },
			{ "isRectangle", isRectangle ? Double.valueOf(1.0) : Double.valueOf(0.0) }
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/shape/MTriangle.java
// =========================================

// Murat Inan
package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

public class MTriangle extends BasicForm implements java.io.Serializable, Writable
{
    protected Point3D v0, v1, v2;  // Üç köşe noktası
    protected Vector3D normal;     // Önceden hesaplanmış normal
    
    private Matrix4 transform = Matrix4.identity();
    private Matrix4 inverseTransform = Matrix4.identity();
    private Point3D worldV0, worldV1, worldV2; // Transform edilmiş köşeler
    private Vector3D worldNormal; // Transform edilmiş normal

    public MTriangle(Point3D v0, Point3D v1, Point3D v2)
    {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        
        // Normal hesapla (saat yönünün tersine - counter clockwise)
        Vector3D edge1 = new Vector3D(v0, v1);
        Vector3D edge2 = new Vector3D(v0, v2);
        this.normal = Vector3D.normalization(Vector3D.crossProduct(edge1, edge2));
        
        updateTransformedVertices();
    }

    public MTriangle(double x0, double y0, double z0,
                   double x1, double y1, double z1, 
                   double x2, double y2, double z2)
    {
        this(new Point3D(x0, y0, z0),
             new Point3D(x1, y1, z1),
             new Point3D(x2, y2, z2));
    }

    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        HashMap map = new HashMap();
        map.put("v0", null);
        map.put("v1", null);
        map.put("v2", null);

        reader.readFields(map);

        return new MTriangle((Point3D) map.get("v0"),
                           (Point3D) map.get("v1"),
                           (Point3D) map.get("v2"));
    }

    /**
     * Transform matrix'ini set et ve köşeleri güncelle
     */
    @Override
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        Matrix4 inv = transform.inverse();
        this.inverseTransform = (inv != null) ? inv : Matrix4.identity();
        updateTransformedVertices();
    }
    
    @Override
    public Matrix4 getTransform() {
        return this.transform;
    }
    
    /**
     * Transform edilmiş köşeleri ve normali güncelle
     */
    private void updateTransformedVertices() {
        this.worldV0 = transform.transformPoint(v0);
        this.worldV1 = transform.transformPoint(v1);
        this.worldV2 = transform.transformPoint(v2);
        
        // World space'de normal hesapla
        Vector3D edge1 = new Vector3D(worldV0, worldV1);
        Vector3D edge2 = new Vector3D(worldV0, worldV2);
        this.worldNormal = Vector3D.normalization(Vector3D.crossProduct(edge1, edge2));
    }

    /**
     * Möller-Trumbore intersection algorithm (world coordinates)
     */
    @Override
    public Point3D computeIntersection(Ray r)
    {
        // World coordinates kullan
        Vector3D edge1 = new Vector3D(worldV0, worldV1);
        Vector3D edge2 = new Vector3D(worldV0, worldV2);
        
        Vector3D h = Vector3D.crossProduct(r.direction, edge2);
        double a = Vector3D.dotProduct(edge1, h);
        
        // Ray parallel to triangle?
        if (Math.abs(a) < 1e-12) {
            return null;
        }
        
        double f = 1.0 / a;
        Vector3D s = new Vector3D(worldV0, r.origin);
        double u = f * Vector3D.dotProduct(s, h);
        
        // u outside [0,1]?
        if (u < 0.0 || u > 1.0) {
            return null;
        }
        
        Vector3D q = Vector3D.crossProduct(s, edge1);
        double v = f * Vector3D.dotProduct(r.direction, q);
        
        // v outside [0,1] or u+v > 1?
        if (v < 0.0 || u + v > 1.0) {
            return null;
        }
        
        // At this stage we can compute t to find out where the intersection point is on the line
        double t = f * Vector3D.dotProduct(edge2, q);
        
        if (t > 1e-6) { // Ray intersection
            if (hasLG(r.origin)) {
                return null;
            }
            return new Point3D(r.origin, Vector3D.product(r.direction, t));
        }
        
        // There is a line intersection but not a ray intersection
        return null;
    }

    @Override
    public boolean exactlyContains(Point3D p)
    {
        // World coordinates kullan
        Vector3D v0p = new Vector3D(worldV0, p);
        Vector3D v0v1 = new Vector3D(worldV0, worldV1);
        Vector3D v0v2 = new Vector3D(worldV0, worldV2);
        
        double dot00 = Vector3D.dotProduct(v0v2, v0v2);
        double dot01 = Vector3D.dotProduct(v0v2, v0v1);
        double dot02 = Vector3D.dotProduct(v0v2, v0p);
        double dot11 = Vector3D.dotProduct(v0v1, v0v1);
        double dot12 = Vector3D.dotProduct(v0v1, v0p);
        
        double invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
        double u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        double v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        
        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v <= 1);
    }

    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        // World coordinates kullan
        Vector3D v0p = new Vector3D(worldV0, p);
        Vector3D v0v1 = new Vector3D(worldV0, worldV1);
        Vector3D v0v2 = new Vector3D(worldV0, worldV2);
        
        double dot00 = Vector3D.dotProduct(v0v2, v0v2);
        double dot01 = Vector3D.dotProduct(v0v2, v0v1);
        double dot02 = Vector3D.dotProduct(v0v2, v0p);
        double dot11 = Vector3D.dotProduct(v0v1, v0v1);
        double dot12 = Vector3D.dotProduct(v0v1, v0p);
        
        double invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
        double u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        double v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        
        // Check if point is strictly inside triangle (not on edges)
        return (u > 0) && (v > 0) && (u + v < 1);
    }

    @Override
    public Vector3D computeNormal(Point3D p)
    {
        // World normal dön
        return worldNormal;
    }
    
    /**
     * Local köşelere erişim için getter'lar
     */
    public Point3D getLocalV0() { return v0; }
    public Point3D getLocalV1() { return v1; }
    public Point3D getLocalV2() { return v2; }
    
    /**
     * World köşelere erişim için getter'lar
     */
    public Point3D getWorldV0() { return worldV0; }
    public Point3D getWorldV1() { return worldV1; }
    public Point3D getWorldV2() { return worldV2; }

    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		String TRIANGLE_STR = "Constructor is: MTriangle(double x0, double y0, double z0,double x1, double y1, double z1, double x2, double y2, double z2);\nExample -last value is volume-:\n-2,-2,0,  2,-2,0,  0,0,3,  1\nEnter your values after three diyez symbol\n###\n";
		return TRIANGLE_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		this.exampleString = info;
		
		BasicForm bform = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return bform;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return bform;
		
			//-2,-2,0,  2,-2,0,  0,0,3,  0.5
			try {
				double p1x = Double.parseDouble(split[0]);
				double p1y = Double.parseDouble(split[1]);
				double p1z = Double.parseDouble(split[2]);
				
				double p2x = Double.parseDouble(split[3]);
				double p2y = Double.parseDouble(split[4]);
				double p2z = Double.parseDouble(split[5]);
				
				double p3x = Double.parseDouble(split[6]);
				double p3y = Double.parseDouble(split[7]);
				double p3z = Double.parseDouble(split[8]);
			
				bform = new MTriangle(
						new Point3D(p1x, p1y, p1z), 
				        new Point3D(p2x, p2y, p2z),
				        new Point3D(p3x, p3y, p3z));
				double vl = Double.parseDouble(split[9]);
				bform.setVolumeValue(vl);
				return bform;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	
	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////
	
    @Override
    public String toString()
    {
        return ObjectWriter.toString(this);
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { 
            { "v0", v0 },
            { "v1", v1 },
            { "v2", v2 }
        };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/shape/XRectangle.java
// =========================================

/* $Id: XRectangle.java,v 1.0 2025/10/27 12:00:00 murat Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 * Modifications (C) 2025 Murat Inan
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

public class XRectangle extends BasicForm implements java.io.Serializable, Writable
{    
    protected Point3D center;
    protected Vector3D normal;
    protected double width;   // extent in Y direction (left-right)
    protected double height;  // extent in Z direction (down-up)

    private Matrix4 transform = Matrix4.identity();
    private Matrix4 inverseTransform = Matrix4.identity();
    private Matrix4 normalTransform = Matrix4.identity();

    // ONLY constructor: normal, width, height
    // Center is fixed at (0,0,0) in local space
    public XRectangle(Vector3D normal, double width, double height)
    {
        this.center = new Point3D(0, 0, 0);
        this.normal = Vector3D.normalization(normal);
        this.width = width;
        this.height = height;
        updateTransforms();
    }

    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        HashMap map = new HashMap();
        map.put("normal", null);
        map.put("width", Double.valueOf(1.0));
        map.put("height", Double.valueOf(1.0));

        reader.readFields(map);

        Vector3D normal = (Vector3D) map.get("normal");
        Double w = (Double) map.get("width");
        Double h = (Double) map.get("height");

        return new XRectangle(normal, w.doubleValue(), h.doubleValue());
    }

    @Override
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        updateTransforms();
    }
    
    @Override
    public Matrix4 getTransform() {
        return this.transform;
    }
    
    private void updateTransforms() {
        Matrix4 inv = this.transform.inverse();
        this.inverseTransform = (inv != null) ? inv : Matrix4.identity();
        
        // Normal transform = (inverse)^T for proper normal transformation
        Matrix4 invTranspose = this.inverseTransform.transpose();
        this.normalTransform = (invTranspose != null) ? invTranspose : Matrix4.identity();
    }

    @Override
    public Point3D computeIntersection(Ray r)
    {
        if (this.inverseTransform == null) return null;

        // Transform ray to local object space
        Point3D localOrigin = this.inverseTransform.transformPoint(r.origin);
        Vector3D localDirection = this.inverseTransform.transformVector(r.direction);

        // Local plane passes through (0,0,0) with given normal
        double denom = Vector3D.dotProduct(this.normal, localDirection);
        
        if (Math.abs(denom) < Ray.EPSILON2) {
            return null;
        }

        double tLocal = -Vector3D.dotProduct(this.normal, new Vector3D(new Point3D(0,0,0), localOrigin)) / denom;
        if (tLocal < Ray.EPSILON2) {
            return null;
        }

        // Compute hit point in local space
        Point3D hitLocal = new Point3D(localOrigin, Vector3D.product(localDirection, tLocal));

        // Check bounds in Y and Z (since rectangle lies in YZ plane when normal is along X)
        double y = hitLocal.y;
        double z = hitLocal.z;

        if (Math.abs(y) <= this.width / 2.0 && Math.abs(z) <= this.height / 2.0) {
            // Return world-space intersection point
            return new Point3D(r.origin, Vector3D.product(r.direction, tLocal));
        }

        return null;
    }

    @Override
    public Vector3D computeNormal(Point3D p)
    {
        return normalTransform.transformVector(normal).normalization();
    }

    @Override
    public boolean exactlyContains(Point3D p)
    {
        if (this.inverseTransform == null) return false;
        Point3D localP = this.inverseTransform.transformPoint(p);

        double distToPlane = Vector3D.dotProduct(this.normal, new Vector3D(new Point3D(0,0,0), localP));
        if (Math.abs(distToPlane) > Ray.EPSILON2) return false;

        double y = localP.y;
        double z = localP.z;
        return (Math.abs(y) <= this.width / 2.0 + Ray.EPSILON2) &&
               (Math.abs(z) <= this.height / 2.0 + Ray.EPSILON2);
    }

    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        if (this.inverseTransform == null) return false;
        Point3D localP = this.inverseTransform.transformPoint(p);

        double distToPlane = Vector3D.dotProduct(this.normal, new Vector3D(new Point3D(0,0,0), localP));
        if (Math.abs(distToPlane) > Ray.EPSILON2) return false;

        double y = localP.y;
        double z = localP.z;
        return (Math.abs(y) < this.width / 2.0 - Ray.EPSILON2) &&
               (Math.abs(z) < this.height / 2.0 - Ray.EPSILON2);
    }

    // ADDED by Murat Inan
    @Override
    public String getUsageInformation()
    {
        String RECT_STR = "Constructor is: XRectangle(Vector3D normal, double width, double height)\n" +
                          "Example - last value is volume:\n" +
                          "-1,0,0,  52.0,  17.0,  0   # Backwall transform is 45,0,10.25\n" +
                          "Enter your values after three diyez symbol\n###\n";
        return RECT_STR;
    }

    private String exampleString = "null";
    @Override
    public String toExampleString() {
        return this.exampleString;
    }
    
    @Override
    public BasicForm getInstance(String info)
    {
        this.exampleString = info;
        BasicForm bform = null;
        
        String str = info.trim();
        int diyezIndex = str.lastIndexOf("###");
        if (diyezIndex < 0) return bform;
        
        str = str.substring(diyezIndex + 3);
        str = str.replaceAll("\n", "");
        str = str.replaceAll(" ", "");
            
        String[] split = str.split(",");
        if (split == null) return bform;
        
        try {
            if (split.length == 6) {
                double dx = Double.parseDouble(split[0]);
                double dy = Double.parseDouble(split[1]);
                double dz = Double.parseDouble(split[2]);
                double w  = Double.parseDouble(split[3]);
                double h  = Double.parseDouble(split[4]);
                double vl = Double.parseDouble(split[5]);
                
                bform = new XRectangle(new Vector3D(dx, dy, dz), w, h);
                bform.setVolumeValue(vl);
            }
            return bform;
        } catch (NumberFormatException nfe) {
            nfe.printStackTrace();
            return null;
        }
    }
    
    public double getXRectangleWidth() {
		return this.width;
	}
	
	public double getXRectangleHeight() {
		return this.height;
	}
	
    private double volumeValue = 1.0;
    public double getVolumeValue() {
        return this.volumeValue;
    }
    
    public void setVolumeValue(double vlm) {
        this.volumeValue = vlm;
    }
    
    public String toString()
    {
        return ObjectWriter.toString(this);
    }

    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { 
            { "normal", normal },
            { "width", Double.valueOf(width) },
            { "height", Double.valueOf(height) }
        };
        writer.writeFields(fields);
    }
    
}

/**
// Backwall: camera to X , wall X=5
XRectangle wall = new XRectangle(new Vector3D(-1, 0, 0), 52.0, 17.0);
wall.setTransform(Matrix4.translation(45, 0, 10.25));
*/


// =========================================
// File: /raja/shape/Cone.java
// =========================================

/* $Id: Cone.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class Cone extends BasicForm implements java.io.Serializable, Writable
{
    protected Point3D origin;
    protected Vector3D direction;   // normed vector
    protected double angle;   // Faut qu'on trouve un truc pour virer cette daube qui ne sert a rien
    protected double k;   // cos(angle)

    public Cone(Point3D origin, Vector3D direction, double angle)
    {
        this.origin = origin;
		this.direction = Vector3D.normalization(direction);
        this.angle = angle;
        this.k = Math.cos(angle);
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("origin",null);
	map.put("direction",null);
	map.put("angle",null);

	/* Parsing */
	reader.readFields(map);

	return new Cone((Point3D) map.get("origin"),
                        (Vector3D) map.get("direction"),
                        ((Number) map.get("angle")).doubleValue());
    }
	
	@Override
    public Point3D computeIntersection(Ray r)
    {
        double a, b, c;

        Vector3D alpha = new Vector3D(origin, r.origin);
        Vector3D beta = r.direction;

        double scAlpha = Vector3D.dotProduct(alpha, direction);
        double scBeta = Vector3D.dotProduct(beta, direction);
        double scAlphaBeta = Vector3D.dotProduct(alpha, beta);
        double kSquare = k*k;
        
        a = scBeta*scBeta - kSquare;
        b = 2 * (scAlpha*scBeta - (kSquare * scAlphaBeta));
        c = scAlpha*scAlpha - (kSquare * alpha.normSq());

        return solve2ndOrder(a, b, c, r);
    }
    @Override
    public boolean exactlyContains(Point3D p)
    {
        Vector3D originP = new Vector3D(origin, p);
        return (Math.abs(Vector3D.dotProduct(originP, direction)) >= (k * originP.norm()));
    }
    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        Vector3D originP = new Vector3D(origin, p);
        return (Math.abs(Vector3D.dotProduct(originP, direction)) > (k * originP.norm()));
    }
    @Override
    public Vector3D computeNormal(Point3D p)
    {
        double b = - Math.sqrt(1 / (1 - k*k));
        Vector3D u = Vector3D.normalization(new Vector3D(origin, p));
        double a = - (b * k);

        if (Vector3D.dotProduct(u, direction) < 0) {
            b = -b;
        }

        return Vector3D.sum(Vector3D.product(u, a),
                            Vector3D.product(direction, b));
    }

	// ADDED by Murat Inan
	@Override
	public void setTransform(Matrix4 mtrx) {
		return;
	}
	
	@Override
	public Matrix4 getTransform() {
		return new Matrix4();
	}
    ////////////////////
    
    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		return "";
	}
	
   @Override
   public String toExampleString() {
     return "null";
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		return new Cone(new Point3D(0, 0, 0), new Vector3D(0, 0, 1), 1.0);
	}
	
	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////
	
    @Override
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "origin", origin },
                              { "direction", direction },
                              { "angle", new Double(angle) } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/TexturedForm.java
// =========================================

/* $Id: TexturedForm.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;


public interface TexturedForm extends Shape3D
{
    public TexturedLocalGeometry intersection(Ray r);
}


// =========================================
// File: /raja/shape/Intersection.java
// =========================================

/* $Id: Intersection.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import raja.util.List;

import java.util.HashMap;
import java.util.Iterator;


public class Intersection extends CompositeForm implements java.io.Serializable
{
    public Intersection()
    {
        super();
    }

    public Intersection(List texturedForms)
    {
        super(texturedForms);
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();
        
	map.put("texturedForms",null);
	
	/* Parsing */
	reader.readFields(map);
        
        return new Intersection((List) map.get("texturedForms"));
    }

    public TexturedLocalGeometry intersection(Ray r)
    {
        List formsToIntersect = new List();

        for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            if (! currentForm.contains(r.origin)) {
                formsToIntersect.add(currentForm);
            }
        }

        if (formsToIntersect.isEmpty()) {
            TexturedLocalGeometry intersection = null;
            double dist = Double.POSITIVE_INFINITY;

            for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
            {
                TexturedForm currentForm = (TexturedForm) iterForm.next();
                TexturedLocalGeometry currentIntersection = currentForm.intersection(r);

                if (currentIntersection != null) {
                    double currentDist = Point3D.distanceSq(r.origin, currentIntersection);
                    if (currentDist < dist) {
                        intersection = currentIntersection;
                        dist = currentDist;
                    }
                }
            }

            if (intersection == null) {
                return null;
            }
            if (contains(intersection)) {
                return intersection;
            }

            List newFormsToIntersect = new List();

            for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
            {
                TexturedForm currentForm = (TexturedForm) iterForm.next();
                if (! currentForm.contains(intersection)) {
                    newFormsToIntersect.add(currentForm);
                }
            }
            Ray newR = new Ray(intersection, r.direction);
            return recursiveIntersection(newR, newFormsToIntersect);
        }
        return recursiveIntersection(r, formsToIntersect);
    }
    private TexturedLocalGeometry recursiveIntersection(Ray r, List formsToIntersect)
    {
        TexturedLocalGeometry intersection = null;
        double dist = 0;

        for(Iterator iterForm = formsToIntersect.iterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            TexturedLocalGeometry currentIntersection = currentForm.intersection(r);

            if (currentIntersection == null)
            {
                return null;
            }
            else
            {
                double currentDist = Point3D.distanceSq(r.origin, currentIntersection);
                if (currentDist > dist)
                {
                    intersection = currentIntersection;
                    dist = currentDist;
                }
            }
        }

        List newFormsToIntersect = new List();

        for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            if (! currentForm.contains(intersection)) {
                newFormsToIntersect.add(currentForm);
            }
        }

        if (newFormsToIntersect.isEmpty()) {
            return intersection;
        }
        else {
            Ray newR = new Ray(intersection, r.direction);
            return recursiveIntersection(newR, newFormsToIntersect);
        }
    }

    public boolean intersects(LightRay r)
    {
        if (strictlyContains(r.origin)) {
            for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
            {
                TexturedForm currentForm = (TexturedForm) iterForm.next();
                if (currentForm.intersects(r)) {
                    return true;
                }
            }
            return false;
        }
        else {
            return super.intersects(r);
        }
    }

    public boolean contains(Point3D p)
    {
        for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            if (! currentForm.contains(p)) {
                return false;
            }
        }
        return true;
    }
    public boolean strictlyContains(Point3D p)
    {
        for(Iterator iterForm = formIterator() ; iterForm.hasNext() ;)
        {
            TexturedForm currentForm = (TexturedForm) iterForm.next();
            if (! currentForm.strictlyContains(p)) {
                return false;
            }
        }
        return true;
    }
}


// =========================================
// File: /raja/shape/Cylinder.java
// =========================================

/* $Id: Cylinder.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class Cylinder extends BasicForm implements java.io.Serializable, Writable
{
    protected Point3D origin;
    protected Vector3D direction;   // normed vector
    protected double radius;

    public Cylinder(Vector3D direction, Point3D origin, double radius)
    {
	this.direction = Vector3D.normalization(direction);
        this.origin = origin;
        this.radius = radius;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("origin",null);
	map.put("direction",null);
	map.put("radius",null);

	/* Parsing */
	reader.readFields(map);

	return new Cylinder((Vector3D) map.get("direction"),
                        (Point3D) map.get("origin"),
                        ((Number) map.get("radius")).doubleValue());
    }
	
	@Override
    public Point3D computeIntersection(Ray r)
    {
        double a, b, c;

        Vector3D alpha = Vector3D.projection(new Vector3D(origin, r.origin), direction);
        Vector3D beta = Vector3D.projection(r.direction, direction);

        a = beta.normSq();
        b = 2 * Vector3D.dotProduct(alpha, beta);
        c = alpha.normSq() - radius*radius;

        return solve2ndOrder(a, b, c, r);
    }
    @Override
    public boolean exactlyContains(Point3D p)
    {
        Vector3D v = Vector3D.projection(new Vector3D(origin, p), direction);
        return (v.norm() <= radius);
    }
    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        Vector3D v = Vector3D.projection(new Vector3D(origin, p), direction);
        return (v.norm() < radius);
    }
    @Override
    public Vector3D computeNormal(Point3D p)
    {
        Vector3D v = Vector3D.projection(new Vector3D(origin, p), direction);
        return Vector3D.normalization(v);
    }

	// ADDED by Murat Inan
	@Override
	public void setTransform(Matrix4 mtrx) {
		return;
	}
	
	@Override
	public Matrix4 getTransform() {
		return new Matrix4();
	}
    ////////////////////
    
    //ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		return "";
	}
	
   @Override
   public String toExampleString() {
     return "null";
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		return new Cylinder(new Vector3D(0, 0, 1), new Point3D(0, 0, 0), 1.0);
	}
	
	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////
	
    @Override
    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    @Override
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "origin", origin },
                              { "direction", direction },
                              { "radius", new Double(radius) } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/shape/MBox.java
// =========================================

// Murat Inan
package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;

public class MBox extends BasicForm implements java.io.Serializable, Writable
{
    protected Point3D min;
    protected Point3D max;
    
    private Matrix4 transform = Matrix4.identity();
    private Matrix4 inverseTransform = Matrix4.identity();
    private Point3D worldMin, worldMax; // Transform edilmiş köşeler
	
	public MBox() {
		this(new Point3D(-0.5, -0.5, -0.5), new Point3D(0.5, 0.5, 0.5));
	}
	
    public MBox(Point3D min, Point3D max)
    {
        this.min = new Point3D(Math.min(min.x, max.x),
                               Math.min(min.y, max.y),
                               Math.min(min.z, max.z));
        this.max = new Point3D(Math.max(min.x, max.x),
                               Math.max(min.y, max.y),
                               Math.max(min.z, max.z));
        updateTransformedVertices();
    }

    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        HashMap map = new HashMap();
        map.put("min", null);
        map.put("max", null);
        reader.readFields(map);
        return new MBox((Point3D) map.get("min"),
                       (Point3D) map.get("max"));
    }

    /**
     * Transform matrix'ini set et ve köşeleri güncelle
     */
    @Override
    public void setTransform(Matrix4 transform) {
        this.transform = transform;
        Matrix4 inv = transform.inverse();
        this.inverseTransform = (inv != null) ? inv : Matrix4.identity();
        updateTransformedVertices();
    }
    
    @Override
    public Matrix4 getTransform() {
        return this.transform;
    }
    
    /**
     * Transform edilmiş köşeleri güncelle
     */
    private void updateTransformedVertices() {
        this.worldMin = transform.transformPoint(min);
        this.worldMax = transform.transformPoint(max);
        
        // Transform sonrası min/max'ı yeniden hesapla (rotation için)
        double minX = Math.min(worldMin.x, worldMax.x);
        double minY = Math.min(worldMin.y, worldMax.y);
        double minZ = Math.min(worldMin.z, worldMax.z);
        double maxX = Math.max(worldMin.x, worldMax.x);
        double maxY = Math.max(worldMin.y, worldMax.y);
        double maxZ = Math.max(worldMin.z, worldMax.z);
        
        this.worldMin = new Point3D(minX, minY, minZ);
        this.worldMax = new Point3D(maxX, maxY, maxZ);
    }

    @Override
    public Point3D computeIntersection(Ray r)
    {
        // World coordinates kullan
        double tmin = Double.NEGATIVE_INFINITY;
        double tmax = Double.POSITIVE_INFINITY;

        // X slab
        if (Math.abs(r.direction.x) < 1e-12) {
            if (r.origin.x < worldMin.x || r.origin.x > worldMax.x) return null;
        } else {
            double tx1 = (worldMin.x - r.origin.x) / r.direction.x;
            double tx2 = (worldMax.x - r.origin.x) / r.direction.x;
            if (tx1 > tx2) { double tmp = tx1; tx1 = tx2; tx2 = tmp; }
            tmin = Math.max(tmin, tx1);
            tmax = Math.min(tmax, tx2);
            if (tmin > tmax) return null;
        }

        // Y slab
        if (Math.abs(r.direction.y) < 1e-12) {
            if (r.origin.y < worldMin.y || r.origin.y > worldMax.y) return null;
        } else {
            double ty1 = (worldMin.y - r.origin.y) / r.direction.y;
            double ty2 = (worldMax.y - r.origin.y) / r.direction.y;
            if (ty1 > ty2) { double tmp = ty1; ty1 = ty2; ty2 = tmp; }
            tmin = Math.max(tmin, ty1);
            tmax = Math.min(tmax, ty2);
            if (tmin > tmax) return null;
        }

        // Z slab
        if (Math.abs(r.direction.z) < 1e-12) {
            if (r.origin.z < worldMin.z || r.origin.z > worldMax.z) return null;
        } else {
            double tz1 = (worldMin.z - r.origin.z) / r.direction.z;
            double tz2 = (worldMax.z - r.origin.z) / r.direction.z;
            if (tz1 > tz2) { double tmp = tz1; tz1 = tz2; tz2 = tmp; }
            tmin = Math.max(tmin, tz1);
            tmax = Math.min(tmax, tz2);
            if (tmin > tmax) return null;
        }

        if (tmax < 0) return null;

        double t = (tmin >= 0) ? tmin : tmax;
        return new Point3D(r.origin, Vector3D.product(r.direction, t));
    }

    @Override
    public Vector3D computeNormal(Point3D p)
    {
        double epsilon = 1e-6;
        
        // World coordinates kullan
        double dxMin = Math.abs(p.x - worldMin.x);
        double dxMax = Math.abs(p.x - worldMax.x);
        double dyMin = Math.abs(p.y - worldMin.y);
        double dyMax = Math.abs(p.y - worldMax.y);
        double dzMin = Math.abs(p.z - worldMin.z);
        double dzMax = Math.abs(p.z - worldMax.z);
        
        double minDist = Math.min(Math.min(Math.min(dxMin, dxMax), 
                             Math.min(dyMin, dyMax)), 
                             Math.min(dzMin, dzMax));
        
        if (Math.abs(minDist - dxMin) < epsilon) return new Vector3D(-1, 0, 0);
        if (Math.abs(minDist - dxMax) < epsilon) return new Vector3D( 1, 0, 0);
        if (Math.abs(minDist - dyMin) < epsilon) return new Vector3D( 0,-1, 0);
        if (Math.abs(minDist - dyMax) < epsilon) return new Vector3D( 0, 1, 0);
        if (Math.abs(minDist - dzMin) < epsilon) return new Vector3D( 0, 0,-1);
        if (Math.abs(minDist - dzMax) < epsilon) return new Vector3D( 0, 0, 1);

        return new Vector3D(0, 0, 1);
    }

    @Override
    public boolean exactlyContains(Point3D p)
    {
        // World coordinates kullan
        return (p.x >= worldMin.x && p.x <= worldMax.x &&
                p.y >= worldMin.y && p.y <= worldMax.y &&
                p.z >= worldMin.z && p.z <= worldMax.z);
    }

    @Override
    public boolean exactlyStrictlyContains(Point3D p)
    {
        // World coordinates kullan
        return (p.x > worldMin.x && p.x < worldMax.x &&
                p.y > worldMin.y && p.y < worldMax.y &&
                p.z > worldMin.z && p.z < worldMax.z);
    }
    
    /**
     * Local köşelere erişim için getter'lar
     */
    public Point3D getLocalMin() { return min; }
    public Point3D getLocalMax() { return max; }
    
    /**
     * World köşelere erişim için getter'lar
     */
    public Point3D getWorldMin() { return worldMin; }
    public Point3D getWorldMax() { return worldMax; }

    // ADDED by Murat Inan
    @Override
	public String getUsageInformation()
	{
		String BOX_STR = "Constructor is: MBox(Point3D min, Point3D max);\nExample -last value is volume-:\n-0.5,-0.5,-0.5,  0.5,0.5,0.5,  1\nEnter your values after three diyez symbol\n###\n";
		return BOX_STR;
	}

   private String exampleString = "null";
   @Override
   public String toExampleString() {
     return this.exampleString;
   }
   
	@Override
    public BasicForm getInstance(String info)
	{
		this.exampleString = info;
		
		BasicForm bform = null;
		
		String str = info.trim();
		
		int diyezIndex = str.lastIndexOf("###");
		if (diyezIndex < 0) return bform;
		
		str = str.substring(diyezIndex+3);
		str = str.replaceAll("\n", "");
		str = str.replaceAll(" ", "");
			
		String [] split = str.split (",");
		if (split == null) return bform;
		
			//-0.5,-0.5,-0.5,  0.5,0.5,0.5, 1.0
			try {
				double p1x = Double.parseDouble(split[0]);
				double p1y = Double.parseDouble(split[1]);
				double p1z = Double.parseDouble(split[2]);
				
				double p2x = Double.parseDouble(split[3]);
				double p2y = Double.parseDouble(split[4]);
				double p2z = Double.parseDouble(split[5]);
				
				bform = new MBox(new Point3D(p1x, p1y, p1z), new Point3D(p2x, p2y, p2z));
				double vl = Double.parseDouble(split[6]);
				bform.setVolumeValue(vl);
				return bform;
			} catch (NumberFormatException nfe) {
				nfe.printStackTrace();
				return null;
			}
	}
	
	private double volumeValue = 1.0;
	public double getVolumeValue() {
		return this.volumeValue;
	}
	
    public void setVolumeValue(double vlm) {
		this.volumeValue = vlm;
	}
	////////////
	
    @Override
    public String toString()
    {
        return ObjectWriter.toString(this);
    }

    @Override
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "min", min },
                              { "max", max } };
        writer.writeFields(fields);
    }
    
}


// =========================================
// File: /raja/shape/BasicForm.java
// =========================================

/* $Id: BasicForm.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;


public abstract class BasicForm implements Form
{
    protected abstract Point3D computeIntersection(Ray r);
    protected abstract Vector3D computeNormal(Point3D p);
    protected abstract boolean exactlyContains(Point3D p);
    protected abstract boolean exactlyStrictlyContains(Point3D p);
	
	// ADDED by Murat Inan
	public abstract void setTransform(Matrix4 mtrx);
	public abstract Matrix4 getTransform();
	public abstract String getUsageInformation();
    public abstract BasicForm getInstance(String info);
    public abstract String toExampleString();
    public abstract double getVolumeValue();
    public abstract void setVolumeValue(double vlm);
    ////////////////////
    
    public LocalGeometry intersection(Ray r)
    {
        class BasicLocalGeometry extends LocalGeometry
        {
            BasicForm form;

            BasicLocalGeometry(Point3D p, BasicForm f)
            {
                super(p);
                this.form = f;
            }

            AcneCorrection getAcneCorrection()
            {
                return new AcneCorrection() {
                    BasicForm getBasicForm()
                    {
                        return form;
                    }
                };
            }
            public Vector3D getNormal()
            {
                return form.computeNormal(this);
            }
        }

        Point3D intersection = computeIntersection(r);

        if (intersection == null) {
            return null;
        }
        else {
            return new BasicLocalGeometry(intersection, this);
        }
    }

    public boolean intersects(LightRay r)
    {
        Point3D intersection = computeIntersection(r);
        if (intersection != null) {
            double d = Point3D.distance(r.origin, intersection);
            if (d < r.distance) {
                return true;
            }
        }
        return false;
    }

    public boolean contains(Point3D p)
    {
        if (hasLG(p)) {
            return true;
        }
        return exactlyContains(p);
    }
    public boolean strictlyContains(Point3D p)
    {
        if (hasLG(p)) {
            return false;
        }
        return exactlyStrictlyContains(p);
    }

    /**
     * Returns the point on the ray corresponding to the smallest positive solution
     * to the equation a*X^2 + b*X + c = 0.
     * @param a, b, c the coefficients of the equation.
     * @param r the ray.
     * @return the point r.origin + t*r.direction where t is the smallest X > 0 such that a*X^2 + b*X + c = 0 if there is any;
     *	       <code>null</code> otherwise.
     */
    protected Point3D solve2ndOrder(double a, double b, double c, Ray r)
    {
        if (a == 0) {
            if (b != 0) {
                double t = (- c) / b;
                if (t > 0) {
                    Point3D intersection = new Point3D(r.origin, Vector3D.product(r.direction, t));
                    if (isValid(intersection, r)) {
                        return intersection;
                    }
                }
            }
            return null;
        }

        double det = b*b - 4 * a *c;

        if (det < 0) {
            return null;
        }

        double sqrtDet = Math.sqrt(det);
        double tMin, tMax;

        if (a < 0) {
            tMin = (-b + Math.sqrt(det)) / (2 * a);
            tMax = (-b - Math.sqrt(det)) / (2 * a);
        }
        else {
            tMin = (-b - Math.sqrt(det)) / (2 * a);
            tMax = (-b + Math.sqrt(det)) / (2 * a);
        }
        if (tMax <= 0) {
                return null;
        }

        if (tMin > 0) {
            Point3D intersection = new Point3D(r.origin, Vector3D.product(r.direction, tMin));
            if (isValid(intersection, r)) {
                return intersection;
            }
        }

        Point3D intersection = new Point3D(r.origin, Vector3D.product(r.direction, tMax));
        if (isValid(intersection, r)) {
            return intersection;
        }
        return null;
    }

    private boolean isValid(Point3D intersection, Ray r)
    {
        if (r.origin instanceof LocalGeometry) {
            LocalGeometry lg = (LocalGeometry) r.origin;
            if (lg.getAcneCorrection().getBasicForm() == this) {
                double dot1 = Vector3D.dotProduct(computeNormal(lg), r.direction);
                double dot2 = Vector3D.dotProduct(computeNormal(intersection), r.direction);
                if ((dot1 * dot2) > 0) {
                    return false;
                }
            }
        }
        return true;
    }

    protected boolean hasLG(Point3D p)
    {
        if (p instanceof LocalGeometry) {
            if (((LocalGeometry) p).getAcneCorrection().getBasicForm() == this) {
                return true;
            }
        }
        return false;
    }
}


// =========================================
// File: /raja/shape/BasicSolid.java
// =========================================

/* $Id: BasicSolid.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.shape;

import raja.*;
import raja.io.*;
import java.util.HashMap;


public class BasicSolid implements Solid, java.io.Serializable, Writable
{
    private TexturedForm texturedForm;
    private Volume volume;

    public BasicSolid(TexturedForm f, Volume v)
    {
        texturedForm = f;
        volume = v;
    }

    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("texturedForm", null);
	map.put("volume", new IsotropicVolume(1.0));

	/* Parsing */
	reader.readFields(map);

	return new BasicSolid((TexturedForm) map.get("texturedForm"),
			      (Volume) map.get("volume"));
    }

    public SolidLocalGeometry intersection(Ray r)
    {
        TexturedLocalGeometry intersection = texturedForm.intersection(r);

        if (intersection == null) {
            return null;
        }
        else {
            SolidLocalGeometry result = new SolidLocalGeometry(intersection);
            result.setInVolume(volume);
            return result;
        }
    }
    public boolean intersects(LightRay r)
    {
        return texturedForm.intersects(r);
    }
    public boolean contains(Point3D p)
    {
        return texturedForm.contains(p);
    }
    public boolean strictlyContains(Point3D p)
    {
        return texturedForm.strictlyContains(p);
    }
    public double refractiveIndex(Point3D p)
    {
        return volume.refractiveIndex(p);
    }

    public String toString()
    {
        return ObjectWriter.toString(this);
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "texturedForm", texturedForm },
                              { "volume", volume } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/Ray.java
// =========================================

/* $Id: Ray.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja;


/**
 * The <code>Ray</code> class defines a high precision ray in the 3
 * dimensional space.  A ray is basically a semiline, given by its origin,
 * a <code>Point3D</code>, and its direction, a <code>Vector3D</code>.
 *
 * @see Point3D
 * @see Vector3D
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
public class Ray
{
	// ADDED by Murat Inan
	public static final double EPSILON  = 1e-6;
	public static final double EPSILON2 = 1e-10;
	
    /**
     * The <i>origin</i> of the ray.
     * @serial
     */
    public Point3D origin;

    /**
     * The <i>direction</i> of the ray.  This <code>Vector3D</code> is normed
     * upon construction, and it <i>should</i> stay normed.
     * @serial
     */
    public Vector3D direction;   // normed vector

    /**
     * Creates a <code>Ray</code> object initialized with the
     * specified origin and direction.
     * 
     * @param origin    the origin of the newly constructed
     *                  <code>Ray</code>.
     * @param direction the direction of the newly constructed
     *                  <code>Ray</code>.
     */
    public Ray(Point3D origin, Vector3D direction)
    {
        this.origin = origin;
        this.direction = Vector3D.normalization(direction);
    }

    /**
     * Creates a <code>Ray</code> object initialized with the
     * specified origin and whose direction connects the origin with the
     * specified destination.
     * 
     * @param origin      the origin of the newly constructed
     *                    <code>Ray</code>.
     * @param destination the destination that the direction of the newly
     *                    constructed <code>Ray</code> connects the origin
     *                    with.
     */
    public Ray(Point3D origin, Point3D destination)
    {
        this(origin, new Vector3D(origin, destination));
    }
    
    // ADDED by Murat Inan
    public Ray transform(Matrix4 matrix) {
		Point3D transformedOrigin = matrix.transformPoint(origin);
		Vector3D transformedDirection = matrix.transformVector(direction).normalization();
		return new Ray(transformedOrigin, transformedDirection);
	}

    // ADDED by Murat Inan
    public Point3D getOrigin() {
		return this.origin;
	}
	
    // ADDED by Murat Inan
	public Vector3D getDirection() {
		return this.direction;
	}
	
	/**
	 * ADDED by Murat Inan
	 * Returns the point at distance t along the ray.
	 * 
 	 * @param t the distance along the ray
	 * @return the point at distance t from the ray origin
	*/
	public Point3D pointAt(double t) {
		return new Point3D(origin, Vector3D.product(direction, t));
	}
	
}


// =========================================
// File: /raja/io/Lexer.java
// =========================================

/* $Id: Lexer.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;

import java.io.*;


class Lexer
{
    static final Token CLASS = new Token ();
    static final Token LABEL = new Token ();
    static final Token FIELD = new Token ();
    static final Token NUMBER = new Token ();
    static final Token COMMA = new Token ();
    static final Token SEMICOLON = new Token ();
    static final Token EQUAL = new Token ();
    static final Token PRIOR = new Token ();
    static final Token LPAR = new Token ();
    static final Token RPAR = new Token ();
    static final Token LBRA = new Token ();
    static final Token RBRA = new Token ();
    static final Token LSQBRA = new Token ();
    static final Token RSQBRA = new Token ();
    static final Token DBLELSQBRA = new Token ();
    static final Token DBLERSQBRA = new Token ();
    
    //ADDED by Murat Inan - New token types for String, Boolean and Character
    static final Token STRING = new Token ();
    static final Token BOOLEAN = new Token ();
    static final Token CHARACTER = new Token ();

    /**  Special token mark the End Of Stream (EOS) */
    static Token EOS = new Token();

    private Reader stream;
    private StringBuffer svalue;
    private int inputChar, nbLines, nbCol, nbCurrentCol;

    Lexer(Reader r) throws IOException
    {
        stream = r;
        svalue = new StringBuffer();
        inputChar = stream.read();
        nbLines = 1;
        nbCol = 0;
    }

    /** Gives the string value of the current token */
    String getLexedString()
    {
        return svalue.toString();
    }

    /** Gives the current line number */
    int getLine()
    {
        return nbLines;
    }

    /** Gives the current column number */
    int getCol()
    {
        return nbCol;
    }

    private void readNextChar() throws IOException
    {
        if (inputChar == '\n')
        {
            nbLines++;
            nbCurrentCol = 0;
        }
        else
        {
            nbCurrentCol++;
        }

        svalue.append((char) inputChar);
        inputChar = stream.read();
    }

    //ADDED by Murat Inan - Helper method to peek at next characters without consuming them
    private boolean peekNextChars(String chars) throws IOException {
        stream.mark(chars.length());
        boolean matches = true;
        for (int i = 0; i < chars.length(); i++) {
            int nextChar = stream.read();
            if (nextChar != chars.charAt(i)) {
                matches = false;
                break;
            }
        }
        stream.reset();
        return matches;
    }

    /** Read the next token */
    Token nextToken()
        throws IOException
    {
        svalue = new StringBuffer();
        nbCol = nbCurrentCol;

        Token token = null;

        if (inputChar == -1)
        {
            return(EOS);
        }

        if (inputChar == ',')
        {
            token = COMMA;
            readNextChar();
        }
        else if (inputChar == ';')
        {
            token = SEMICOLON;
            readNextChar();
        }
        else if (inputChar == '=')
        {
            token = EQUAL;
            readNextChar();
        }
        else if (inputChar == '>')
        {
            readNextChar();
            if (inputChar == '>')
            {
                token = PRIOR;
                readNextChar();
            }
            else
            {
                throw new NoMatchingTokenException(svalue.toString() + ((char) inputChar));
            }
        }
        else if (inputChar == '(')
        {
            token = LPAR;
            readNextChar();
        }
        else if (inputChar == ')')
        {
            token = RPAR;
            readNextChar();
        }
        else if (inputChar == '{')
        {
            token = LBRA;
            readNextChar();
        }
        else if (inputChar == '}')
        {
            token = RBRA;
            readNextChar();
        }
        else if (inputChar == '[')
        {
            readNextChar();
            if (inputChar == '[')
            {
                token = DBLELSQBRA;
                readNextChar();
            }
            else
            {
                token = LSQBRA;
            }
        }
        else if (inputChar == ']')
        {
            readNextChar();
            if (inputChar == ']')
            {
                token = DBLERSQBRA;
                readNextChar();
            }
            else
            {
                token = RSQBRA;
            }
        }
        //ADDED by Murat Inan - String literal support
        else if (inputChar == '\"')
        {
            readNextChar(); // consume opening quote
            while (inputChar != '\"' && inputChar != -1 && inputChar != '\n') {
                readNextChar();
            }
            if (inputChar == '\"') {
                readNextChar(); // consume closing quote
                token = STRING;
            } else {
                throw new NoMatchingTokenException("Unterminated string literal");
            }
        }
        //ADDED by Murat Inan - Character literal support
        else if (inputChar == '\'')
        {
            readNextChar(); // consume opening quote
            if (inputChar != -1 && inputChar != '\n') {
                readNextChar(); // read the character
                if (inputChar == '\'') {
                    readNextChar(); // consume closing quote
                    token = CHARACTER;
                } else {
                    throw new NoMatchingTokenException("Unterminated character literal");
                }
            } else {
                throw new NoMatchingTokenException("Empty character literal");
            }
        }
        //ADDED by Murat Inan - Boolean literal support
        else if (inputChar == 't' && peekNextChars("rue"))
        {
            // true
            readNextChar(); // t
            readNextChar(); // r
            readNextChar(); // u
            readNextChar(); // e
            token = BOOLEAN;
        }
        else if (inputChar == 'f' && peekNextChars("alse"))
        {
            // false
            readNextChar(); // f
            readNextChar(); // a
            readNextChar(); // l
            readNextChar(); // s
            readNextChar(); // e
            token = BOOLEAN;
        }
        else if (Character.isLetter((char) inputChar) && Character.isUpperCase((char) inputChar))
        {
            readNextChar();
            while ((inputChar == '_') || Character.isLetter((char) inputChar) || Character.isDigit((char) inputChar))
            {
                readNextChar();
            }
            token = CLASS;
        }
        else if (Character.isLetter((char) inputChar) && Character.isLowerCase((char) inputChar))
        {
            readNextChar();

            while ((Character.isLetter((char) inputChar) && Character.isLowerCase((char) inputChar)) || Character.isDigit((char) inputChar))
            {
                readNextChar();
            }

            if (inputChar == '.')
            {
                // Lexing a CLASS
                readNextChar();

                while ((inputChar == '.') || (Character.isLetter((char) inputChar) && Character.isLowerCase((char) inputChar)))
                {
                    readNextChar();
                }

                if (Character.isLetter((char) inputChar) && Character.isUpperCase((char) inputChar))
                {
                    while ((inputChar == '_') || Character.isLetter((char) inputChar) || Character.isDigit((char) inputChar))
                    {
                        readNextChar();
                    }
                    token = CLASS;
                }
                else
                {
                    throw new NoMatchingTokenException(svalue.toString() + ((char) inputChar));
                }
            }
            else
            {
                // Lexing a FIELD
                while ((inputChar == '_') || Character.isLetter((char) inputChar) || Character.isDigit((char) inputChar))
                {
                    readNextChar();
                }
                token = FIELD;
            }
        }
        else if (inputChar == '@')
        {
            readNextChar();
            while ((inputChar == '_') || (inputChar == '.') || Character.isLetter((char) inputChar) || Character.isDigit((char) inputChar))
            {
                readNextChar();
            }
            token = LABEL;
        }
        else if (Character.isDigit((char) inputChar) || (inputChar == '-'))
        {
            readNextChar();
            while ((inputChar != '.') && Character.isDigit((char) inputChar))
            {
                readNextChar();
            }
            if (inputChar == '.')
            {
                readNextChar();
                while (Character.isDigit((char) inputChar))
                {
                    readNextChar();
                }
            }
            token = NUMBER;
        }
        else if (inputChar == '.')
        {
            readNextChar();
            while (Character.isDigit((char) inputChar))
            {
                readNextChar();
            }
            token = NUMBER;
        }
        else if (inputChar == '/')
        {
            readNextChar();
            if (inputChar == '/')
            {
                readNextChar();
                while (inputChar != '\n')
                {
                    readNextChar();
                }
                return nextToken();
            }
            else
            {
                throw new NoMatchingTokenException(svalue.toString() + ((char) inputChar));
            }
        }
        else if (Character.isWhitespace((char) inputChar))
        {
            readNextChar();
            while (Character.isWhitespace((char) inputChar))
            {
                readNextChar();
            }
            return nextToken();
        }
        else
        {
            throw new NoMatchingTokenException(svalue.toString() + ((char) inputChar));
        }
        return token;
    }
    
}


// =========================================
// File: /raja/io/NoMatchingTokenException.java
// =========================================

/* $Id: NoMatchingTokenException.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


/**
 * The NoMatchingTokenException is thrown when no token matches the input.
 *
 * @see Lexer
 * @see ObjectReader
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
class NoMatchingTokenException extends ReadException 
{
    NoMatchingTokenException(String s)
    {
	super(s);
    }
}


// =========================================
// File: /raja/io/NotWritableException.java
// =========================================

/* $Id: NotWritableException.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


public class NotWritableException extends java.io.IOException
{
    public NotWritableException(Object obj)
    {
        super(obj.toString());
    }
}


// =========================================
// File: /raja/io/IncompatibleClassException.java
// =========================================

/* $Id: IncompatibleClassException.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


public class IncompatibleClassException extends ReadException
{
    IncompatibleClassException(String incompatibleClass, int nbLine, int nbCol)
    {
	super("Line:" + nbLine + ", Col:" + nbCol + "   incompatible class \'" + incompatibleClass + "\'");
    }
}


// =========================================
// File: /raja/io/ObjectWriter.java
// =========================================

/* $Id: ObjectWriter.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;

import java.io.*;
import java.util.*;


public class ObjectWriter extends BufferedWriter
{
    private static final String INDENT_BLOCK = "        ";
    private Map labels;
    private int indent;

    public ObjectWriter(Writer out)
    {
        super(out);
        labels = new HashMap();
        indent = 0;
    }

    public void incrementIndent()
    {
        indent++;
    }
    public void decrementIndent()
    {
        indent--;
    }

    public static String toString(Writable obj)
    {
        StringWriter stringWriter = new StringWriter();

        try
        {
            ObjectWriter w = new ObjectWriter(stringWriter);
            w.writeObject(obj);
            w.close();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }

        return stringWriter.toString();
    }

    public void writeObject(Object obj) throws IOException
    {
        if (! (obj instanceof Writable))
        {
            throw new NotWritableException(obj);
        }

        if (labels.containsKey(obj))
        {
            String label = (String) labels.get(obj);

            if (label == null)
            {
                throw new IllegalArgumentException("Raja Internal Error !!!!");
            }

            write(label);
        }
        else
        {
            String className = obj.getClass().getName();

            if ((obj instanceof raja.util.List) || (obj instanceof raja.util.DirectedGraph) || (obj instanceof raja.util.DirectedGraph.Edge))
            {
                ((Writable) obj).write(this);
            }
            else
            {
                String label = "@" + className + "_" + Integer.toHexString(obj.hashCode());
                labels.put(obj, label);
                write(className + " (" + label + ") {");

                incrementIndent();
                ((Writable) obj).write(this);
                decrementIndent();

                write("}");
            }
        }
    }

    private void writeField(String fieldName, Object fieldValue) throws IOException
    {
        write(fieldName + " = ");
        //ADDED by Murat Inan - Support for Boolean, String and Character types
        if (fieldValue instanceof Number)
        {
            write(fieldValue.toString());
        }
        else if (fieldValue instanceof Boolean)
        {
            write(fieldValue.toString());
        }
        else if (fieldValue instanceof String)
        {
            write("\"" + fieldValue.toString() + "\"");
        }
        else if (fieldValue instanceof Character)
        {
            write("'" + fieldValue.toString() + "'");
        }
        else
        {
            writeObject(fieldValue);
        }
    }

    public void writeFields(Object[][] fields) throws IOException
    {
        write("\n");
        for(int i = 0 ; i < fields.length ; i++)
        {
            writeIndent();
            writeField(((String) fields[i][0]), fields[i][1]);
            write("\n");
        }
        writeIndent(-1);
    }

    public void writeFields(Number[] fields) throws IOException
    {
        write(" ");
        for(int i = 0 ; i < (fields.length - 1) ; i++)
        {
            write(fields[i].toString() + " ; ");
        }
        write(fields[fields.length - 1].toString() + " ");
    }

    public void writeIndent() throws IOException
    {
        writeIndent(0);
    }
    private void writeIndent(int n) throws IOException
    {
        for(int i = 0 ; i < (indent + n) ; i++)
        {
            write(INDENT_BLOCK);
        }
    }
    
}


// =========================================
// File: /raja/io/UndefinedClassException.java
// =========================================

/* $Id: UndefinedClassException.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


public class UndefinedClassException extends ReadException
{
    UndefinedClassException(String undefinedClass, int nbLine, int nbCol)
    {
	super("Line:" + nbLine + ", Col:" + nbCol + "   undefined class \'" + undefinedClass + "\'");
    }
}


// =========================================
// File: /raja/io/ObjectReader.java
// =========================================

package raja.io;

import java.lang.reflect.*;
import java.io.*;
import java.util.Map;
import java.util.HashMap;

import raja.*;
import raja.util.List;
import raja.util.DirectedGraph;


public class ObjectReader extends BufferedReader
{
    private Map labels;
    private Lexer lexer;

    public ObjectReader(Reader in) throws IOException
    {
        super(in);
        labels = new HashMap();
        lexer = new Lexer(this);
    }

    public Object readObject() throws IOException
    {
        return parseField();
    }
    public void readFields(Map map) throws IOException
    {
        parseEnclosedFields(map);
    }
    public Number[] readNumbers(int max) throws IOException
    {
        return parseNumbers(max);
    }


    private static Class[] tab_class = new Class[1];

    static
    {
        try {
            tab_class[0] = Class.forName ("raja.io.ObjectReader");
        }
        catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    private Token readNextToken(String expected)
        throws IOException
    {
        try
        {
            return lexer.nextToken();
        }
        catch (NoMatchingTokenException e)
        {
            throw new SyntaxException (expected, e.getMessage(), lexer.getLine(), lexer.getCol());
        }
    }

    /**
     * This method buildan Object from the class <code>name</code>
     * readed from the lexer <code>stream</code>
     */
    private Object buildObject (String name, int classCol)
        throws IOException
    {
        Method meth_class;
        try
        {
            Class object_class = Class.forName (name);
            meth_class = object_class.getMethod ("build", tab_class);
        }
        catch (ClassNotFoundException e)
        {
            throw new UndefinedClassException (name, lexer.getLine(), classCol);
        }
        catch (NoSuchMethodException e)
        {
            throw new IncompatibleClassException (name, lexer.getLine(), classCol);
        }

        Object[] tab_param = { this };

        try
        {
            return meth_class.invoke(null,tab_param);
        }
        catch (InvocationTargetException e)
        {
            Throwable target = e.getTargetException();
            if (target instanceof IOException)
            {
                throw (IOException) target;
            }
            else if (target instanceof IllegalArgumentException)
            {
                throw (IllegalArgumentException) target;
            }
            else
            {
                e.printStackTrace();
                throw new IllegalArgumentException(e.toString());
            }
        }
        catch (IllegalAccessException e)
        {
            throw new IncompatibleClassException (name, lexer.getLine(), classCol);
        }
    }

    /**
     * This method fill the fields of a map with corresponding objects.
     * It take a map with a list of <code>(String fieldName, Object
     * fieldContent)</code> and it create the Object for each fieldName.
     * The lexer containing the fields is supposed to begin just after
     * <code>{</code> and to end by <code>}</code>.
     */
    private void parseEnclosedFields (Map map)
        throws IOException
    {
        Token token;

        /* Looking for fields */
        token = readNextToken("Field");

        while (token != Lexer.RBRA)
        {
            if ((token == Lexer.FIELD) && (map.containsKey (lexer.getLexedString())))
            {
                String field = lexer.getLexedString();

                /* Checking for Lexer.EQUAL */
                token = readNextToken("\'=\'");

                if (token != Lexer.EQUAL)
                {
                    throw new SyntaxException ("\'=\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
                }

                map.put (field, parseField());

                token = readNextToken("Field or \'}\'");
            }
            else
            {
                throw new SyntaxException ("Field or \'}\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }
        }
    }

    private Object parseClass (String className)
        throws IOException
    {
        Token token;
        int classCol = lexer.getCol();

        token = readNextToken("\'{\' or \'(\'");

        /* Switching */
        if (token == Lexer.LBRA)
        {
            /* Class */
            return buildObject(className, classCol);
        }
        else if (token == Lexer.LPAR)
        {
            token = readNextToken("@label");

            if (token == Lexer.LABEL)
            {
                String currentLabel = lexer.getLexedString();

                token = readNextToken("\')\'");

                if (token == Lexer.RPAR)
                {
                    token = readNextToken("\'{\'");

                    if (token == Lexer.LBRA)
                    {
                        Object currentObject = buildObject (className, classCol);
                        Object oldObject = labels.put(currentLabel, currentObject);

                        if (oldObject != null)
                        {
                            System.err.println("Warning: " + currentLabel + " previously contained " + oldObject);
                        }

                        return currentObject;
                    }
                    else
                    {
                        throw new SyntaxException ("\'{\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
                    }
                }
                else
                {
                    throw new SyntaxException ("\')\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
                }
            }
            else
            {
                throw new SyntaxException ("@label", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }
        }
        else
        {
            throw new SyntaxException ("\'{\' or \'(\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
        }
    }

    /**
     * This method fill the fields of a map with corresponding objects.
     * It take a map with a list of <code>(String fieldName, Object
     * fieldContent)</code> and it create the Object for each fieldName.
     * The lexer containing the fields is supposed beginning by
     * <code>{</code> and ending by <code>}</code>.
     */
    private Object parseField ()
        throws IOException
    {
        Token token;

        //ADDED by Murat Inan - Updated expected tokens to include Boolean, String and Character
        token = readNextToken("Number, Boolean, String, Character, @label, class, '[' or '[['");

        /* Switching */
        if (token == Lexer.NUMBER)
        {
            /* Number */
            return Double.valueOf(lexer.getLexedString());
        }
        //ADDED by Murat Inan - Boolean literal support
        else if (token == Lexer.BOOLEAN)
        {
            /* Boolean */
            return Boolean.valueOf(lexer.getLexedString());
        }
        //ADDED by Murat Inan - String literal support
        else if (token == Lexer.STRING)
        {
            /* String */
            String strValue = lexer.getLexedString();
            // Remove surrounding quotes
            return strValue.substring(1, strValue.length() - 1);
        }
        //ADDED by Murat Inan - Character literal support
        else if (token == Lexer.CHARACTER)
        {
            /* Character */
            String charValue = lexer.getLexedString();
            // Remove surrounding quotes and get the character
            return Character.valueOf(charValue.charAt(1));
        }
        else if (token == Lexer.LABEL)
        {
            /* Label */
            if (labels.containsKey(lexer.getLexedString()))
            {
                Object currentObject = labels.get(lexer.getLexedString());

                if (currentObject == null)
                {
                    throw new IllegalArgumentException("Raja Internal Error !!!!");
                }

                return currentObject;
            }
            else
            {
                throw new UndefinedLabelException(lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }
        }
        else if (token == Lexer.CLASS)
        {
            /* Class */
            return parseClass(lexer.getLexedString());
        }
        else if (token == Lexer.LSQBRA)
        {
            /* List */
            return parseList();
        }
        else if (token == Lexer.DBLELSQBRA)
        {
            /* DirectedGraph */
            return parseDirectedGraph();
        }
        else
        {
            throw new SyntaxException ("Number, Boolean, String, Character, @label, class, '[' or '[['", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
        }
    }

    private List parseList()
        throws IOException
    {
        Token token;
        List currentList = new List();

        //ADDED by Murat Inan - Updated expected tokens to include new types
        /* First Token */
        token = readNextToken("Number, Boolean, String, Character, @label, class, ']'");

        if (token == Lexer.RSQBRA)
        {
            return currentList;
        }

        while(true)
        {
            if (token == Lexer.NUMBER)
            {
                currentList.add(Double.valueOf(lexer.getLexedString()));
            }
            //ADDED by Murat Inan - Boolean support in lists
            else if (token == Lexer.BOOLEAN)
            {
                currentList.add(Boolean.valueOf(lexer.getLexedString()));
            }
            //ADDED by Murat Inan - String support in lists
            else if (token == Lexer.STRING)
            {
                String strValue = lexer.getLexedString();
                currentList.add(strValue.substring(1, strValue.length() - 1));
            }
            //ADDED by Murat Inan - Character support in lists
            else if (token == Lexer.CHARACTER)
            {
                String charValue = lexer.getLexedString();
                currentList.add(Character.valueOf(charValue.charAt(1)));
            }
            else if (token == Lexer.LABEL)
            {
                if (labels.containsKey(lexer.getLexedString()))
                {
                    Object currentObject = labels.get(lexer.getLexedString());

                    if (currentObject == null)
                    {
                        throw new IllegalArgumentException("Raja Internal Error !!!!");
                    }

                    currentList.add (currentObject);
                }
                else
                {
                    throw new UndefinedLabelException(lexer.getLexedString(), lexer.getLine(), lexer.getCol());
                }
            }
            else if (token == Lexer.CLASS)
            {
                Object currentObject = parseClass(lexer.getLexedString());
                currentList.add (currentObject);
            }
            else
            {
                throw new SyntaxException ("Number, Boolean, String, Character, @label, class", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            token = readNextToken("\',\' or \']\'");

            if (token == Lexer.RSQBRA)
            {
                return currentList;
            }

            if (token != Lexer.COMMA)
            {
                throw new SyntaxException ("\',\' or \']\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            //ADDED by Murat Inan - Updated expected tokens to include new types
            token = readNextToken("Number, Boolean, String, Character, @label, class");
        }
    }

    private DirectedGraph parseDirectedGraph()
        throws IOException
    {
        Token token;
        DirectedGraph currentDirectedGraph = new DirectedGraph();

        /* First Token */
        token = readNextToken("@label or \']]\'");

        if (token == Lexer.DBLERSQBRA)
        {
            return currentDirectedGraph;
        }

        while(true)
        {
            if (token != Lexer.LABEL)
            {
                throw new SyntaxException ("@label", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            Object source, dest;

            if (labels.containsKey(lexer.getLexedString()))
            {
                source = labels.get(lexer.getLexedString());

                if (source == null)
                {
                    throw new IllegalArgumentException("Raja Internal Error !!!!");
                }
            }
            else
            {
                throw new UndefinedLabelException(lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            token = readNextToken("\'>>\'");

            if (token != Lexer.PRIOR)
            {
                throw new SyntaxException ("\'>>\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            token = readNextToken("@label");

            if (token != Lexer.LABEL)
            {
                throw new SyntaxException ("@label", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            if (labels.containsKey(lexer.getLexedString()))
            {
                dest = labels.get(lexer.getLexedString());

                if (dest == null)
                {
                    throw new IllegalArgumentException("Raja Internal Error !!!!");
                }
            }
            else
            {
                throw new UndefinedLabelException(lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            currentDirectedGraph.addEdge (source, dest);

            token = readNextToken("\',\' or \']]\'");

            if (token == Lexer.DBLERSQBRA)
            {
                return currentDirectedGraph;
            }

            if (token != Lexer.COMMA)
            {
                throw new SyntaxException ("\',\' or \']]\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            token = readNextToken("@label");
        }
    }

    /**
     * This method fill the index of an ArrayList with parsed
     * Number. It take an empty ArrayList and fill it with the parsed
     * Numbers. The lexer containing the fields is supposed beginning
     * by <code>{</code> and ending by <code>}</code>. 
     */
    private Number[] parseNumbers (int max)
        throws IOException
    {
        Token token = new Token ();
        Number[] parameters = new Number[max];

        /* Getting first token */
        token = readNextToken("number");

        for (int i = 0; i < max; i++)
        {
            if (token != Lexer.NUMBER)
            {
                throw new SyntaxException ("number", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }

            parameters[i] = Double.valueOf(lexer.getLexedString());

            token = readNextToken("\';\' or \'}\'");
            /* Testing for the ending parameter */
            if ((i < max - 1) && (token == Lexer.SEMICOLON))
            {
                token = readNextToken("number");
            }
            else if ((i < max - 1) && (token != Lexer.SEMICOLON))
            {
                throw new SyntaxException ("\';\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
            }
        }
        if (token != Lexer.RBRA)
        {
            throw new SyntaxException ("\'}\'", lexer.getLexedString(), lexer.getLine(), lexer.getCol());
        }
        return parameters;
    }
    
}


// =========================================
// File: /raja/io/Writable.java
// =========================================

/* $Id: Writable.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


public interface Writable
{
    public void write(ObjectWriter writer) throws java.io.IOException;
}


// =========================================
// File: /raja/io/Token.java
// =========================================

/* $Id: Token.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


/**
 * A class to encapsulate a token.
 *
 * @see Lexer
 * @see ObjectReader
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
class Token
{
    Token()
    {
	// Nothing to do
    }
}


// =========================================
// File: /raja/io/ImageReader.java
// =========================================

/* $Id: ImageReader.java,v 1.1 2001/02/16 01:52:10 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;

import java.io.IOException;
import java.awt.image.RenderedImage;


/**
 * An interface specifying objects that can read images.  Images are decoded
 * as instances of <code>RenderedImage</code>.
 *
 * @see ImageWriter
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
public interface ImageReader
{
    /**
     * Returns a <code>RenderedImage</code> that contains the decoded image.
     *
     * @return a <code>RenderedImage</code> that contains the decoded image.
     *
     * @exception IOException if an I/O error occurs
     */
    public RenderedImage read() throws IOException;

    /**
     * Returns the current reading parameters.  Concrete implementations of
     * this interface should return an instance of the appropriate subclass
     * or subinterface.
     *
     * @return the current reading parameters.
     */
    public Object getImageReadParam();

    /**
     * Sets the current reading parameters.  Concrete implementations of
     * this interface may throw a <code>RuntimeException</code> if the param
     * argument is not an instance of the appropriate subclass or
     * subinterface.
     *
     * @param param the reading parameters to use.
     */
    public void setImageReadParam(Object param);
}


// =========================================
// File: /raja/io/UndefinedLabelException.java
// =========================================

/* $Id: UndefinedLabelException.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


public class UndefinedLabelException extends ReadException
{
    UndefinedLabelException(String undefinedLabel, int nbLine, int nbCol)
    {
	super("Line:" + nbLine + ", Col:" + nbCol + "   undefined label \'" + undefinedLabel + "\'");
    }
}


// =========================================
// File: /raja/io/SyntaxException.java
// =========================================

/* $Id: SyntaxException.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


public class SyntaxException extends ReadException
{
    SyntaxException(String expected, String obtained, int nbLine, int nbCol)
    {
	super("Line:" + nbLine + ", Col:" + nbCol + "   " + expected + " expected but found " + obtained);
    }
}


// =========================================
// File: /raja/io/ReadException.java
// =========================================

/* $Id: ReadException.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;


public abstract class ReadException extends java.io.IOException 
{
    protected ReadException(String s)
    {
        super(s);
    }
}


// =========================================
// File: /raja/io/ImageWriter.java
// =========================================

/* $Id: ImageWriter.java,v 1.1 2001/02/16 01:52:10 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.io;

import java.io.IOException;
import java.awt.image.RenderedImage;


/**
 * An interface specifying objects that can write images.  Images are
 * encoded as instances of <code>RenderedImage</code>.
 *
 * @see ImageReader
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
public interface ImageWriter
{
    /**
     * Encodes the given <code>RenderedImage</code>.
     *
     * @param image the <code>RenderedImage</code> to be written.
     *
     * @exception IOException if an I/O error occurs
     */
    public void write(RenderedImage image) throws IOException;

    /**
     * Returns the current writing parameters.  Concrete implementations of
     * this interface should return an instance of the appropriate subclass
     * or subinterface.
     *
     * @return the current writing parameters.
     */
    public Object getImageWriteParam();

    /**
     * Sets the current writing parameters.  Concrete implementations of
     * this interface may throw a <code>RuntimeException</code> if the param
     * argument is not an instance of the appropriate subclass or
     * subinterface.
     *
     * @param param the writing parameters to use.
     */
    public void setImageWriteParam(Object param);

    /**
     * Returns the default writing parameters appropriate to encode the
     * given <code>RenderedImage</code>.  Concrete implementations of this
     * interface should return an instance of the appropriate subclass or
     * subinterface.
     *
     * @param image the <code>RenderedImage</code> to be encoded.
     *
     * @return the default writing parameters to encoded the given image.
     */
    public Object createDefaultImageWriteParam(RenderedImage image);
}


// =========================================
// File: /raja/Point3D.java
// =========================================

/* $Id: Point3D.java,v 1.1.1.1 2001/01/08 23:10:14 gregoire Exp $
 * Copyright (C) 1999-2000 E. Fleury & G. Sutre
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja;

import raja.io.*;


/**
 * The <code>Point3D</code> class defines a high precision point in the 3
 * dimensional space, given by its 3D coordinates.  This class provides
 * most of the classical operations on points (translation, distance...).
 *
 * @see java.awt.geom.Point2D
 * @see Vector3D
 *
 * @author Emmanuel Fleury
 * @author Gr�goire Sutre
 */
public class Point3D implements java.io.Serializable, Writable
{
    /**
     * The <i>x</i> coordinate.
     * @serial
     */
    public double x;

    /**
     * The <i>y</i> coordinate.
     * @serial
     */
    public double y;

    /**
     * The <i>z</i> coordinate.
     * @serial
     */
    public double z;

    /**
     * Creates a <code>Point3D</code> object initialized with the specified
     * 3D coordinates.
     *
     * @param x,&nbsp;y,&nbsp;z the coordinates to which to set the newly
     *                          constructed <code>Point3D</code>.
     */
    public Point3D(double x, double y, double z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * Initializes a newly created <code>Point3D</code> object so that it
     * represents the same 3 dimensional point as the argument.  In other
     * words, the newly created <code>Point3D</code> is a copy of the
     * specified <code>Point3D</code>.
     *
     * @param p a <code>Point3D</code> object.
     */
    public Point3D(Point3D p)
    {
        this(p.x, p.y, p.z);
    }

    /**
     * Initializes a newly created <code>Point3D</code> object so that it
     * represents the <i>translation</i> of the specified
     * <code>Point3D</code> by the specified <code>Vector3D</code>.
     *
     * @param p a <code>Point3D</code> object.
     * @param v a <code>Vector3D</code> object.
     */
    public Point3D(Point3D p, Vector3D v)
    {
        this(p.x + v.x,
             p.y + v.y,
             p.z + v.z);
    }

    /**
     * Creates a <code>Point3D</code> object from the specified
     * <code>ObjectReader</code>.
     *
     * @param reader the <code>ObjectReader</code> to read the
     *        fields from.
     */
    public static Object build(ObjectReader reader)
        throws java.io.IOException
    {
        Number[] params = reader.readNumbers(3);

        return new Point3D(params[0].doubleValue(),
                           params[1].doubleValue(),
                           params[2].doubleValue());
    }

    /**
     * Translates this <code>Point3D</code> by the specified
     * <code>Vector3D</code>.
     *
     * @param v the <code>Vector3D</code> to translate this
     *          <code>Point3D</code> by.
     */
    public void translate(Vector3D v)
    {
        x += v.x;
        y += v.y;
        z += v.z;
    }

    /**
     * Computes the <i>distance</i> between the two specified
     * <code>Point3D</code>.
     *
     * @param p1,&nbsp;p2 the two <code>Point3D</code> to compute the
     *                    distance between.
     * @return the distance between the two specified <code>Point3D</code>.
     */
    public static double distance(Point3D p1, Point3D p2)
    {
        return Math.sqrt(distanceSq(p1, p2));
    }

    /**
     * Computes the <i>square of the distance</i> between the two specified
     * <code>Point3D</code>.
     *
     * @param p1,&nbsp;p2 the two <code>Point3D</code> to compute the
     *                    square of the distance between.
     * @return the square of the distance between the two specified
     *         <code>Point3D</code>.
     */
    public static double distanceSq(Point3D p1, Point3D p2)
    {
        double dx, dy, dz;

        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
        dz = p1.z - p2.z;

        return (dx*dx + dy*dy + dz*dz);
    }
	
	///////////////////////
	// ADDED by Murat Inan
	/**
	 * Computes the <i>length</i> of this <code>Point3D</code> from origin (0,0,0).
	 *
	 * @return the length of this <code>Point3D</code> from origin.
	*/
	public double length()
	{
		return Math.sqrt(x*x + y*y + z*z);
	}

	/**
	 * Computes the <i>square of the length</i> of this <code>Point3D</code> from origin (0,0,0).
	 *
	 * @return the square of the length of this <code>Point3D</code> from origin.
	*/
	public double lengthSq()
	{
		return x*x + y*y + z*z;
	}
	//////////////

    /**
     * Returns a textual <code>String</code> representation of this
     * <code>Point3D</code> object.
     */
    public String toString()
    {
        return ObjectWriter.toString(this);
    }

    /**
     * Writes the contents of this <code>Point3D</code> object to the
     * specified <code>ObjectWriter</code>.
     *
     * @param writer the <code>ObjectWriter</code> to write the
     *        fields to.
     */
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Number[] fields = { new Double(x), new Double(y), new Double(z) };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/Matrix3.java
// =========================================

// Murat Inan
package raja;

/**
 * Represents a 3x3 matrix for linear transformations in 3D space.
 */
public class Matrix3 implements java.io.Serializable {
  private final double[][] m;
  
  /**
   * Constructs an identity Matrix3.
   */
  public Matrix3() {
    m = new double[3][3];
    m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0;
    m[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0;
    m[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0;
  }
  
  /**
   * Constructs a Matrix3 with the specified elements.
   */
  public Matrix3(double m00, double m01, double m02,
    double m10, double m11, double m12,
    double m20, double m21, double m22) {
    m = new double[3][3];
    this.m[0][0] = m00; this.m[0][1] = m01; this.m[0][2] = m02;
    this.m[1][0] = m10; this.m[1][1] = m11; this.m[1][2] = m12;
    this.m[2][0] = m20; this.m[2][1] = m21; this.m[2][2] = m22;
  }
  
  /**
   * Constructs a new Matrix3 by copying an existing matrix.
   * @param other The Matrix3 object to copy.
   */
  public Matrix3(Matrix3 other) {
    this(other.m[0][0], other.m[0][1], other.m[0][2],
      other.m[1][0], other.m[1][1], other.m[1][2],
    other.m[2][0], other.m[2][1], other.m[2][2]);
  }
  
  /**
   * Provides access to a specific element of the matrix.
   * @param row The row index (0-2).
   * @param col The column index (0-2).
   * @return The matrix element at the specified position.
   * @throws IndexOutOfBoundsException If the row or column index is invalid.
   */
  public double get(int row, int col) {
    if (row < 0 || row >= 3 || col < 0 || col >= 3) {
      throw new IndexOutOfBoundsException("Matrix3 indices out of bounds: [" + row + "][" + col + "]");
    }
    return m[row][col];
  }
  
  /**
   * Multiplies this matrix by another matrix.
   * @param other The other Matrix3 to multiply with.
   * @return The resulting Matrix3.
   */
  public Matrix3 multiply(Matrix3 other) {
    Matrix3 result = new Matrix3();
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
        result.m[i][j] = 0;
        for (int k = 0; k < 3; k++) {
          result.m[i][j] += this.m[i][k] * other.m[k][j];
        }
      }
    }
    return result;
  }
  
  /**
   * Transforms a Vector3 by this matrix.
   * @param vector The Vector3 to transform.
   * @return The transformed Vector3.
   */
  public Vector3D transform(Vector3D vector) {
    double x = m[0][0] * vector.x + m[0][1] * vector.y + m[0][2] * vector.z;
    double y = m[1][0] * vector.x + m[1][1] * vector.y + m[1][2] * vector.z;
    double z = m[2][0] * vector.x + m[2][1] * vector.y + m[2][2] * vector.z;
    return new Vector3D(x, y, z);
  }
  
  /**
   * Computes the determinant of this matrix.
   * @return The determinant value.
   */
  public double determinant() {
    return m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
    m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
    m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
  }
  
  /**
   * Computes the inverse of this matrix.
   * @return The inverse Matrix3, or null if the matrix is singular (non-invertible).
   */
  public Matrix3 inverse() {
    double det = determinant();
    if (Math.abs(det) < Ray.EPSILON) { // Using Ray.EPSILON for floating point comparison
      // System.err.println("Warning: Matrix3 is singular, cannot compute inverse.");
      return null;
    }
    
    double invDet = 1.0 / det;
    
    Matrix3 inv = new Matrix3();
    inv.m[0][0] = (m[1][1] * m[2][2] - m[1][2] * m[2][1]) * invDet;
    inv.m[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * invDet;
    inv.m[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * invDet;
    
    inv.m[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) * invDet;
    inv.m[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * invDet;
    inv.m[1][2] = (m[0][2] * m[1][0] - m[0][0] * m[1][2]) * invDet;
    
    inv.m[2][0] = (m[1][0] * m[2][1] - m[1][1] * m[2][0]) * invDet;
    inv.m[2][1] = (m[0][1] * m[2][0] - m[0][0] * m[2][1]) * invDet;
    inv.m[2][2] = (m[0][0] * m[1][1] - m[0][1] * m[1][0]) * invDet;
    
    return inv;
  }
  
  /**
   * Computes the transpose of this matrix.
   * @return The transposed Matrix3.
   */
  public Matrix3 transpose() {
    Matrix3 result = new Matrix3();
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
        result.m[i][j] = this.m[j][i];
      }
    }
    return result;
  }
  
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 3; i++) {
      sb.append("| ");
      for (int j = 0; j < 3; j++) {
        sb.append(String.format("%8.4f", m[i][j])).append(" ");
      }
      sb.append("|\n");
    }
    return sb.toString();
  }
  
}


// =========================================
// File: /raja/test/DiffImages.java
// =========================================

/* $Id: DiffImages.java,v 1.2 2001/02/18 08:29:24 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.test;

import java.io.*;
import java.awt.image.*;
import raja.io.*;


/*
 * Program to diff images.  The maximum and average differences between
 * pixels (RGBcomponentwise) are reported.
 *
 * Usage: java raja.test.DiffImages [-v] file1 file2
 *
 * The -v option turns verbosity on: all differing pixels will be reported.
 *
 * WARNING: This class is not part of the core Raja API.  It is primarily
 * used by Raja developpers to validate their implementations.  It does not
 * contain much error handling.
 */

class DiffImages
{
    public static void main(String[] argv) throws java.io.IOException
    {
        // Parse command line arguments
        boolean verbose = false;
        int index = 0;

        if (argv[index].equals("-v"))
        {
            verbose = true;
            index++;
        }

        String fileName1 = argv[index++];
        String fileName2 = argv[index++];


        // Deduce input codecs from file name extensions
        String codec1 = ImageIO.suffix2Codec(fileName1);

        if (codec1 == null)
        {
            System.err.println("Could not deduce codec for file: " + fileName1);
            System.err.println("DiffImages aborted.");
            System.exit(1);
        }

        String codec2 = ImageIO.suffix2Codec(fileName2);

        if (codec2 == null)
        {
            System.err.println("Could not deduce codec for file: " + fileName2);
            System.err.println("DiffImages aborted.");
            System.exit(1);
        }


        // Read input images
        System.out.println("Reading " + codec1 + " file: " + fileName1 + "...");
        InputStream is1 = new BufferedInputStream(new FileInputStream(fileName1));
        ImageReader reader1 = ImageIO.createImageReader(codec1, is1);

        if (reader1 == null)
        {
            System.err.println("Could not find an image reader for this codec: " +
                               codec1);
            System.err.println("DiffImages aborted.");
            System.exit(1);
        }

        RenderedImage image1 = reader1.read();
        System.out.println("done.\n");

        System.out.println("Reading " + codec2 + " file: " + fileName2 + "...");
        InputStream is2 = new BufferedInputStream(new FileInputStream(fileName2));
        ImageReader reader2 = ImageIO.createImageReader(codec2, is2);

        if (reader2 == null)
        {
            System.err.println("Could not find an image reader for this codec: " +
                               codec2);
            System.err.println("DiffImages aborted.");
            System.exit(1);
        }

        RenderedImage image2 = reader2.read();
        System.out.println("done.\n");


        System.out.println("Image 1 is a " + codec1 + " file: " + fileName1);
        System.out.println("Image 2 is a " + codec2 + " file: " + fileName2);
        System.out.println();


        // Diff the images
        System.out.println("Diffing images...");
        diff(image1, image2, verbose);
        System.out.println("done.");


        // Close the input and output streams
        // Remark: trying to access the input image after closing the input
        // stream may fail, since the input image is decoded as needed
        is1.close();
        is2.close();
    }

    static void diff(RenderedImage image1, RenderedImage image2, boolean verbose)
    {
        int width = image1.getWidth();
        int height = image2.getHeight();

        if ((image2.getWidth() != width) || (image2.getHeight() != height))
        {
            System.out.println("The 2 images have a different resolution!");
            System.out.println("DiffImages aborted.");
            return;
        }

        System.out.println("Resolution: " + width + " x " + height);

        Raster r1 = image1.getData();
        Raster r2 = image2.getData();
        ColorModel cm1 = image1.getColorModel();
        ColorModel cm2 = image2.getColorModel();

        int[] max = {0, 0, 0};
        double[] sum = {0, 0, 0};

        int[] pix1 = new int[3];
        int[] pix2 = new int[3];

        for (int i = 0 ; i < width ; i++)
        {
            for (int j = 0 ; j < height ; j++)
            {
                int rgb1 = cm1.getRGB(r1.getDataElements(i, j, null));
                int rgb2 = cm2.getRGB(r2.getDataElements(i, j, null));

                pix1[0] = (rgb1 >> 16) & 0xFF;   // red
                pix1[1] = (rgb1 >> 8)  & 0xFF;   // green
                pix1[2] = (rgb1 >> 0)  & 0xFF;   // blue

                pix2[0] = (rgb2 >> 16) & 0xFF;   // red
                pix2[1] = (rgb2 >> 8)  & 0xFF;   // green
                pix2[2] = (rgb2 >> 0)  & 0xFF;   // blue

                if ((pix1[0] != pix2[0]) ||
                    (pix1[1] != pix2[1]) ||
                    (pix1[2] != pix2[2]))
                {
                    if (verbose)
                    {
                        System.out.println("Difference at pixel (" +
                                           i + ", " + j + ")");
                        System.out.println("   image 1 : [" +
                                           pix1[0] + ", " +
                                           pix1[1] + ", " +
                                           pix1[2] + "]");
                        System.out.println("   image 2 : [" +
                                           pix2[0] + ", " +
                                           pix2[1] + ", " +
                                           pix2[2] + "]");
                        System.out.println();
                    }

                    for(int k = 0 ; k < 3 ; k++)
                    {
                        max[k] = Math.max(max[k], Math.abs(pix1[k] - pix2[k]));
                        sum[k] = sum[k] + Math.abs(pix1[k] - pix2[k]);
                    }
                }
            }
        }

        System.out.println("Maximum difference: [" +
                           max[0] + ", " +
                           max[1] + ", " +
                           max[2] + "]");
        System.out.println("Average difference: [" +
                           (sum[0] / (width*height)) + ", " +
                           (sum[1] / (width*height)) + ", " +
                           (sum[2] / (width*height)) + "]");
    }
}


// =========================================
// File: /raja/test/CreateMickeyTravelling.java
// =========================================

package raja.test;

import raja.*;
import raja.renderer.*;

import java.io.*;


class CreateMickeyTravelling
{
    public static void main(String[] argv) throws java.io.IOException
    {
        if (argv.length == 0)
        {
            System.out.println("Vous devez passer un nom de fichier en argument");
            return;
        }

        int N = 100;

        Camera[] travelling = new Camera[N];

        for(int i = 0 ; i < N ; i++)
        {
            double angle = (2 * Math.PI * i) / N;
            angle +=  Math.PI;

            double x = 70*Math.cos(angle);
            double y = 70*Math.sin(angle);

            travelling[i] = new HorizontalCamera(new Point3D(x + 70, y, 35), new Vector3D(-x, -y, -35), 1.8, 2, 1.5);
        }

        OutputStream output = new BufferedOutputStream(new FileOutputStream(argv[0]));
        ObjectOutput objectOutput = new ObjectOutputStream(output);
        objectOutput.writeObject(travelling);
        objectOutput.flush();
        objectOutput.close();
    }
}


// =========================================
// File: /raja/test/HamierTexture.java
// =========================================

package raja.test;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class HamierTexture implements Texture, java.io.Serializable, Writable
{
    private RGB kd1, kd2, kr, kt;
    private int ns, nt;
    private double step, x0, y0;
    
    public HamierTexture(Color c1, Color c2, 
			 int ns, int nt, 
			 double step, double x0, double y0)
    {
	BufferedImage bi=new BufferedImage (3, 3, 1);
        Graphics2D g2d=bi.createGraphics ();
        g2d.setBackground (Color.white);
        g2d.clearRect (0, 0, 3, 3);
        GradientPaint gp=new GradientPaint (0, 0, c1, 3, 3, c2, true);
        g2d.setPaint (gp);
        g2d.fillRect (0, 0, 3, 3);

	final double X255=255.0;
	
        int rgb=bi.getRGB (1, 1);
        Color ncol=new Color (rgb);
	
	double nr=((double)ncol.getRed ());
	double ng=((double)ncol.getGreen ());
	double nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        this.kd1=new RGB (nr, ng, nb);

        rgb=bi.getRGB (0, 0);
        ncol=new Color (rgb);
        
        nr=((double)ncol.getRed ());
	ng=((double)ncol.getGreen ());
	nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        RGB ofi=new RGB (nr, ng, nb);

        this.kd2=ofi;
        
        this.kr=ofi;

        rgb=bi.getRGB (0, 0);
        ncol=new Color (rgb);

	nr=((double)ncol.getRed ());
	ng=((double)ncol.getGreen ());
	nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        ofi=new RGB (nr, ng, nb);

        this.kt=ofi;

        this.ns=ns;
        this.nt=nt;

	this.step = step;
        this.x0 = x0;
        this.y0 = y0;
        
        g2d.dispose ();
        bi=null;
    }
    
    public HamierTexture(RGB kd1, RGB kd2, RGB kr, RGB kt, int ns, int nt, double step, double x0, double y0)
    {
	this.kd1 = kd1;
	this.kd2 = kd2;
	this.kr = kr;
	this.kt = kt;
	this.ns = ns;
	this.nt = nt;
        this.step = step;
        this.x0 = x0;
        this.y0 = y0;
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		return "";
	}

    @Override
    public String toExampleString() {
      return "null";
    }
   
	@Override
    public Texture getInstance(String info) {
		return null;
	}
	////////////////
	
    /**
     * Builds the object LocalTexture from a StreamLexer.
     */
    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("kdUn",null);
	map.put("kdDeux",null);
	map.put("kr",null);
	map.put("kt",null);
	map.put("ns",null);
	map.put("nt",null);
	map.put("step",null);
	map.put("x",null);
	map.put("y",null);

	/* Parsing */
	reader.readFields(map);

        return new HamierTexture((RGB) map.get("kdUn"),
                                 (RGB) map.get("kdDeux"),
                                 (RGB) map.get("kr"),
                                 (RGB) map.get("kt"),
                                 ((Number) map.get("ns")).intValue(),
                                 ((Number) map.get("nt")).intValue(),
                                 ((Number) map.get("step")).doubleValue(),
                                 ((Number) map.get("x")).doubleValue(),
                                 ((Number) map.get("y")).doubleValue());
    }

    public LocalTexture getLocalTexture(Point3D p)
    {
	double i = Math.floor((p.x - y0) / step);
	double j = Math.floor((p.y - x0) / step);

	if ((i-j) %3  == 1)
	{
	    return new LocalTexture(kd1, kr, kt, ns, nt);
	}
	else 
	{
	    return new LocalTexture(kd2, kr, kt, ns, nt);
	}
    }
    
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "kdUn", kd1 },
                              { "kdDeux", kd2 },
                              { "kr", kr },
                              { "kt", kt },
                              { "ns", new Integer(ns) },
                              { "nt", new Integer(nt) },
                              { "step", new Double(step) },
                              { "x", new Double(x0) },
                              { "y", new Double(y0) } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/test/DumpWithJAI.java
// =========================================

/* $Id: DumpWithJAI.java,v 1.2 2001/02/18 08:29:24 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.test;

import java.awt.image.*;
import java.io.*;
import com.sun.media.jai.codec.*;


/*
 * Program to dump images, using JAI directly.
 *
 * Usage: java raja.test.DumpWithJAI file
 *
 * WARNING: This class is not part of the core Raja API.  It is primarily
 * used by Raja developpers to validate their implementations.  It does not
 * contain much error handling.
 */

class DumpWithJAI
{
    public static void main(String[] argv) throws IOException
    {
        // Parse command line arguments
        int index = 0;
        String inputFileName = argv[index++];


        // Deduce input codec from file name extension
        String inputCodec = raja.io.ImageIO.suffix2Codec(inputFileName);

        if (inputCodec == null)
        {
            System.err.println("Could not deduce codec for file: " + inputFileName);
            System.err.println("DumpWithJAI aborted.");
            System.exit(1);
        }


        // Read input image
        System.out.println("Reading " + inputCodec + " file: " + inputFileName + "...");
        InputStream is = new BufferedInputStream(new FileInputStream(inputFileName));
        ImageDecoder dec = ImageCodec.createImageDecoder(inputCodec, is, null);

        if (dec == null)
        {
            System.err.println("Could not find an image decoder for this codec: " +
                               inputCodec);
            System.err.println("DumpWithJAI aborted.");
            System.exit(1);
        }

        RenderedImage image = dec.decodeAsRenderedImage();
        System.out.println("done.\n");


        // Dump Image
        dump(image);


        // Close the input stream
        // Remark: trying to access the input image after closing the input
        // stream may fail, since the input image is decoded as needed
        is.close();
    }

    static void dump(RenderedImage image)
    {
        int width = image.getWidth();
        int height = image.getHeight();

        Raster ras = image.getData();
        ColorModel cm = image.getColorModel();

        System.out.println("image = " + image);
        System.out.println("Image has resolution: " + width + "x" + height);
        System.out.println("getData() = " + ras);
        System.out.println("getColorModel() = " + cm);
        System.out.println("getNumXTiles() = " + image.getNumXTiles());
        System.out.println("getNumYTiles() = " + image.getNumYTiles());
        System.out.println("getMinTileX() = " + image.getMinTileX());
        System.out.println("getMinTileY() = " + image.getMinTileY());
        System.out.println("getTileWidth() = " + image.getTileWidth());
        System.out.println("getTileHeight() = " + image.getTileHeight());
        System.out.println();

        for (int i = 0 ; i < width ; i++)
        {
            for (int j = 0 ; j < height ; j++)
            {
                int rgb = cm.getRGB(ras.getDataElements(i, j, null));

                int red   = (rgb >> 16) & 0xFF;
                int green = (rgb >> 8)  & 0xFF;
                int blue  = (rgb >> 0)  & 0xFF;

                System.out.println("Pixel(" + i + ", " + j + ") : [" +
                                   red + ", " +
                                   green + ", " +
                                   blue + "]");
            }
        }
    }
}


// =========================================
// File: /raja/test/MamierTexture.java
// =========================================

package raja.test;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class MamierTexture implements Texture, java.io.Serializable, Writable
{
    private RGB kd1, kd2, kr, kt;
    private int ns, nt;
    private double step, x0, y0;
    
    public MamierTexture(Color c1, Color c2, 
			 int ns, int nt, 
			 double step, double x0, double y0)
    {
	BufferedImage bi=new BufferedImage (3, 3, 1);
        Graphics2D g2d=bi.createGraphics ();
        g2d.setBackground (Color.white);
        g2d.clearRect (0, 0, 3, 3);
        GradientPaint gp=new GradientPaint (0, 0, c1, 3, 3, c2, true);
        g2d.setPaint (gp);
        g2d.fillRect (0, 0, 3, 3);

	final double X255=255.0;
	
        int rgb=bi.getRGB (1, 1);
        Color ncol=new Color (rgb);
	
	double nr=((double)ncol.getRed ());
	double ng=((double)ncol.getGreen ());
	double nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        this.kd1=new RGB (nr, ng, nb);

        rgb=bi.getRGB (0, 0);
        ncol=new Color (rgb);
        
        nr=((double)ncol.getRed ());
	ng=((double)ncol.getGreen ());
	nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        RGB ofi=new RGB (nr, ng, nb);

        this.kd2=ofi;
        
        this.kr=ofi;

        rgb=bi.getRGB (0, 0);
        ncol=new Color (rgb);

	nr=((double)ncol.getRed ());
	ng=((double)ncol.getGreen ());
	nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        ofi=new RGB (nr, ng, nb);

        this.kt=ofi;

        this.ns=ns;
        this.nt=nt;

	this.step = step;
        this.x0 = x0;
        this.y0 = y0;
        
        g2d.dispose ();
        bi=null;
    }
    
    public MamierTexture(RGB kd1, RGB kd2, RGB kr, RGB kt, int ns, int nt, double step, double x0, double y0)
    {
	this.kd1 = kd1;
	this.kd2 = kd2;
	this.kr = kr;
	this.kt = kt;
	this.ns = ns;
	this.nt = nt;
        this.step = step;
        this.x0 = x0;
        this.y0 = y0;
    }

    /**
     * Builds the object LocalTexture from a StreamLexer.
     */
    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("kdUn",null);
	map.put("kdDeux",null);
	map.put("kr",null);
	map.put("kt",null);
	map.put("ns",null);
	map.put("nt",null);
	map.put("step",null);
	map.put("x",null);
	map.put("y",null);

	/* Parsing */
	reader.readFields(map);

        return new MamierTexture((RGB) map.get("kdUn"),
                                 (RGB) map.get("kdDeux"),
                                 (RGB) map.get("kr"),
                                 (RGB) map.get("kt"),
                                 ((Number) map.get("ns")).intValue(),
                                 ((Number) map.get("nt")).intValue(),
                                 ((Number) map.get("step")).doubleValue(),
                                 ((Number) map.get("x")).doubleValue(),
                                 ((Number) map.get("y")).doubleValue());
    }

    public LocalTexture getLocalTexture(Point3D p)
    {
	double i = Math.floor((p.x - x0) / step);
	double j = Math.floor((p.y - y0) / step);

	if ((j-i) %3  == 0.0)
	{
	    return new LocalTexture(kd1, kr, kt, ns, nt);
	}
	else 
	{
	    return new LocalTexture(kd2, kr, kt, ns, nt);
	}
    }
    
    // ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		return "";
	}
	
    @Override
    public String toExampleString() {
     return "null";
    }
   
	@Override
    public Texture getInstance(String info) {
		return null;
	}
	////////////////
	
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "kdUn", kd1 },
                              { "kdDeux", kd2 },
                              { "kr", kr },
                              { "kt", kt },
                              { "ns", new Integer(ns) },
                              { "nt", new Integer(nt) },
                              { "step", new Double(step) },
                              { "x", new Double(x0) },
                              { "y", new Double(y0) } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/test/ReduceImage.java
// =========================================

/* $Id: ReduceImage.java,v 1.3 2001/02/18 08:29:24 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.test;

import java.awt.image.*;
import java.io.*;
import raja.io.*;


/*
 * Program to reduce images by performing average computations.
 *
 * Usage: java raja.test.ReduceImage factor infile outfile
 *
 * WARNING: This class is not part of the core Raja API.  It is primarily
 * used by Raja developpers to validate their implementations.  It does not
 * contain much error handling.
 */

class ReduceImage
{
    public static void main(String[] argv) throws IOException
    {
        // Parse command line arguments
        int index = 0;
        int reduceFactor = Integer.parseInt(argv[index++]);
        String inputFileName = argv[index++];
        String outputFileName = argv[index++];


        // Deduce input and output codecs from file name extensions
        String inputCodec = ImageIO.suffix2Codec(inputFileName);

        if (inputCodec == null)
        {
            System.err.println("Could not deduce codec for file: " + inputFileName);
            System.err.println("ReduceImage aborted.");
            System.exit(1);
        }

        String outputCodec = ImageIO.suffix2Codec(outputFileName);

        if (outputCodec == null)
        {
            System.err.println("Could not deduce codec for file: " + outputFileName);
            System.err.println("ReduceImage aborted.");
            System.exit(1);
        }


        // Read input image
        System.out.println("Reading " + inputCodec + " file: " + inputFileName + "...");
        InputStream is = new BufferedInputStream(new FileInputStream(inputFileName));
        ImageReader reader = ImageIO.createImageReader(inputCodec, is);

        if (reader == null)
        {
            System.err.println("Could not find an image reader for this codec: " +
                               inputCodec);
            System.err.println("ReduceImage aborted.");
            System.exit(1);
        }

        RenderedImage inputImage = reader.read();
        System.out.println("done.\n");


        // Get input image resolution
        int inputWidth = inputImage.getWidth();
        int inputHeight = inputImage.getHeight();


        // Compute output image resolution
        int outputWidth = inputWidth / reduceFactor;
        int outputHeight = inputHeight / reduceFactor;

        System.out.println("Resolution of input image:  " + inputWidth +
                           " x " + inputHeight);
        System.out.println("Resolution of output image: " + outputWidth +
                           " x " + outputHeight);
        System.out.println();


        // Initialise output image
        Raster inputRas = inputImage.getData();
        WritableRaster outputRas = inputRas.createCompatibleWritableRaster(outputWidth,
                                                                           outputHeight);
        ColorModel colorModel = inputImage.getColorModel();
        BufferedImage outputImage = new BufferedImage(colorModel,
                                                      outputRas,
                                                      false,
                                                      null);


        // Compute output image
        System.out.println("Computing reduced image...");
        long reduceFactorSquare = reduceFactor * reduceFactor;

        for (int i = 0 ; i < outputWidth ; i++)
        {
            for (int j = 0 ; j < outputHeight ; j++)
            {
                double red   = 0;
                double green = 0;
                double blue  = 0;

                for (int h = 0 ; h < reduceFactor ; h++)
                {
                    for (int k = 0 ; k < reduceFactor ; k++)
                    {
                        Object data = inputRas.getDataElements(reduceFactor*i + h,
                                                               reduceFactor*j + k,
                                                               null);
                        int inputPixelRGB = colorModel.getRGB(data);

                        red   += (inputPixelRGB >> 16) & 0xFF;
                        green += (inputPixelRGB >> 8)  & 0xFF;
                        blue  += (inputPixelRGB >> 0)  & 0xFF;
                    }
                }

                red   /= reduceFactorSquare;
                green /= reduceFactorSquare;
                blue  /= reduceFactorSquare;

                int red_int   = Math.round((float) red);
                int green_int = Math.round((float) green);
                int blue_int  = Math.round((float) blue);

                int outputPixelRGB =               (0xFF << 24) |
                                       ((red_int & 0xFF) << 16) |
                                     ((green_int & 0xFF) << 8)  |
                                      ((blue_int & 0xFF) << 0);

                outputImage.setRGB(i, j, outputPixelRGB);
            }
        }

        System.out.println("done.\n");


        // Close the input stream
        // Remark: trying to access the input image after closing the input
        // stream may fail, since the input image is decoded as needed
        is.close();


        // Write reduced image in output file
        System.out.println("Writing " + outputCodec + " file: " + outputFileName + "...");
        OutputStream os = new BufferedOutputStream(new FileOutputStream(outputFileName));
        ImageWriter writer = ImageIO.createImageWriter(outputCodec, os);

        if (writer == null)
        {
            System.err.println("Could not find an image writer for this codec: " +
                               outputCodec);
            System.err.println("ReduceImage aborted.");
            System.exit(1);
        }

        Object writeParam = writer.createDefaultImageWriteParam(outputImage);
        writer.setImageWriteParam(writeParam);
        writer.write(outputImage);


        // Close the output stream
        os.close();
        System.out.println("done.");
    }
}


// =========================================
// File: /raja/test/CheckImageIO.java
// =========================================

/* $Id: CheckImageIO.java,v 1.2 2001/02/18 08:29:24 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.test;

import java.awt.image.*;
import java.io.*;
import raja.io.*;


/*
 * Program to check Raja's I/O image functionnality.
 *
 * Usage: java raja.test.CheckImageIO [--indexed] tmpfile
 *
 * The codec to check I/O for is deduced from the tmpfile extension.  When
 * the --indexed option is used, an indexed image is generated ; otherwise
 * an RGB image is generated.
 *
 * WARNING: This class is not part of the core Raja API.  It is primarily
 * used by Raja developpers to validate their implementations.  It does not
 * contain much error handling.
 */

class CheckImageIO
{
    public static void main(String[] argv) throws IOException
    {
        // Parse command line arguments
        boolean indexed = false;
        int index = 0;

        if (argv[index].equals("--indexed"))
        {
            indexed = true;
            index++;
        }

        String tmpFileName = argv[index++];


        // Deduce codec from temporary file name extension
        String codec = ImageIO.suffix2Codec(tmpFileName);

        if (codec == null)
        {
            System.err.println("Could not deduce codec for file: " + tmpFileName);
            System.err.println("CheckImageIO aborted.");
            System.exit(1);
        }


        // Set maximum width and height
        int maxWidth = 2048;
        int maxHeight = 2048;


        // Create a new random test image
        RenderedImage testImage = createRandomImage(maxWidth, maxHeight, indexed);
        System.out.println("done.\n");


        // Write test image in output file
        System.out.println("Writing " + codec + " file: " + tmpFileName + "...");
        OutputStream os = new BufferedOutputStream(new FileOutputStream(tmpFileName));
        ImageWriter writer = ImageIO.createImageWriter(codec, os);

        if (writer == null)
        {
            System.err.println("Could not find an image writer for this codec: " +
                               codec);
            System.err.println("CheckImageIO aborted.");
            System.exit(1);
        }

        Object writeParam = writer.createDefaultImageWriteParam(testImage);
        writer.setImageWriteParam(writeParam);
        writer.write(testImage);


        // Close the output stream
        os.close();
        System.out.println("done.\n");


        // Read input image
        System.out.println("Reading " + codec + " file: " + tmpFileName + "...");
        InputStream is = new BufferedInputStream(new FileInputStream(tmpFileName));
        ImageReader reader = ImageIO.createImageReader(codec, is);

        if (reader == null)
        {
            System.err.println("Could not find an image reader for this codec: " +
                               codec);
            System.err.println("CheckImageIO aborted.");
            System.exit(1);
        }

        RenderedImage readImage = reader.read();
        System.out.println("done.\n");


        // Diff the original test image and the encoded-decoded version
        System.out.println("Diffing images...");
        DiffImages.diff(testImage, readImage, false);
        System.out.println("done.");


        // Close the input stream
        // Remark: trying to access the input image after closing the input
        // stream may fail, since the input image is decoded as needed
        is.close();
    }

    static RenderedImage createRandomImage(int maxWidth, int maxHeight,
                                           boolean indexed)
    {
        int width  = Math.round((float) (maxWidth * Math.random()));
        int height = Math.round((float) (maxWidth * Math.random()));

        int imageType;

        if (indexed)
        {
            imageType = BufferedImage.TYPE_BYTE_INDEXED;
            System.out.println("Creating a random INDEXED " +
                               width + "x" + height + " image...");
        }
        else
        {
            imageType = BufferedImage.TYPE_3BYTE_BGR;
            System.out.println("Creating a random 3BYTE_BGR " +
                               width + "x" + height + " image...");
        }

        BufferedImage image = new BufferedImage(width, height, imageType);

        for (int i = 0 ; i < width ; i++)
        {
            for (int j = 0 ; j < height ; j++)
            {
                long random_pos_long = Math.round(Long.MAX_VALUE * Math.random());
                int random_int = (int) (random_pos_long >> 16);
                int rgb = 0xFF000000 | random_int;
                image.setRGB(i, j, rgb);
            }
        }

        return image;
    }
}


// =========================================
// File: /raja/test/CreateAdvancedCristalTravelling.java
// =========================================

package raja.test;

import raja.*;
import raja.renderer.*;
import java.io.*;


class CreateAdvancedCristalTravelling
{
    public static void main(String[] argv) throws java.io.IOException
    {
        if (argv.length == 0)
        {
            System.out.println("Vous devez passer un nom de fichier en argument");
            return;
        }

        int N = 100;

        Camera[] travelling = new Camera[N];

        for(int i = 0 ; i < N ; i++)
        {
            double angle = (2 * Math.PI * i) / N;
            angle +=  Math.PI;

            double x = 140*Math.cos(angle);
            double y = 140*Math.sin(angle);

            travelling[i] = new HorizontalCamera(new Point3D(x + 140, y, 130), new Vector3D(-x, -y, -130), 1.8, 2, 1.5);
        }

        OutputStream output = new BufferedOutputStream(new FileOutputStream(argv[0]));
        ObjectOutput objectOutput = new ObjectOutputStream(output);
        objectOutput.writeObject(travelling);
        objectOutput.flush();
        objectOutput.close();
    }
}


// =========================================
// File: /raja/test/ComputeVideo.java
// =========================================

package raja.test;

import javax.swing.BoundedRangeModel;
import javax.swing.DefaultBoundedRangeModel;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.JProgressBar;
import javax.swing.event.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.image.*;
import java.awt.event.*;
import java.io.*;
import com.sun.media.jai.codec.*;

import raja.renderer.*;
import raja.io.*;


class ComputeVideo
{
    public static void main(String[] argv) throws java.io.IOException, java.lang.ClassNotFoundException
    {
        if (argv.length <= 1)
        {
            System.out.println("usage : java raja.test.ComputeVideo [-noprogress -scale scale -exact -antialias level -n first-last] depth sceneFile travellingFile videoBaseName");
            return;
        }

        boolean noProgressBar = false;
        boolean exact = false;
        float scale = 1;
        int antialias = 0;
        int first = 1;
        int last = 0;
        int index;

        for(index = 0 ; ; index++)
        {
            if (argv[index].equals("-noprogress")) {
                noProgressBar = true;
            }
            else if (argv[index].equals("-scale")) {
                scale = Float.parseFloat(argv[++index]);
            }
            else if (argv[index].equals("-antialias")) {
                antialias = Integer.parseInt(argv[++index]);
            }
            else if (argv[index].equals("-exact")) {
                exact = true;
            }
            else if (argv[index].equals("-n")) {
                String region = argv[++index];
                int i = region.indexOf('-');
                first = Integer.parseInt(region.substring(0, i));
                last  = Integer.parseInt(region.substring(i+1));
                if (first > last) {
                    throw new IllegalArgumentException("first > last");
                }
                if ((first <= 0)) {
                    throw new IllegalArgumentException("first <= 0");
                }
                if ((last <= 0)) {
                    throw new IllegalArgumentException("last <= 0");
                }
            }
            else {
                break;
            }
        }

        int depth = Integer.parseInt(argv[index++]);

        Reader in = new InputStreamReader(new FileInputStream(argv[index]));
        ObjectReader reader = new ObjectReader(in);
        Scene scene = (Scene) reader.readObject();
        reader.close();
        index++;

        InputStream inputStream = new BufferedInputStream(new FileInputStream(argv[index]));
        ObjectInput objectInput = new ObjectInputStream(inputStream);
        Camera[] travelling = (Camera[]) objectInput.readObject();
        objectInput.close();
        index++;

        if (first > travelling.length) {
            throw new IllegalArgumentException("first > travelling.length");
        }

        if (last == 0) {
            last = travelling.length;
        }
        else if (last > travelling.length) {
            throw new IllegalArgumentException("last > travelling.length");
        }

        Resolution resolution = new Resolution((int) Math.round(384 * scale), (int) Math.round(288 * scale));
        RayTracer rayTracer;

        if (exact) {
            rayTracer = new AdvancedRayTracer(scene.getWorld(), depth, 0);
        }
        else {
            rayTracer = new AdvancedRayTracer(scene.getWorld(), depth);
        }

        Sampler sampler;

        if (antialias > 0) {
            sampler = new NaiveSuperSampler(antialias);
        }
        else {
            sampler = new BasicSampler();
        }

        JFrame progressFrame = null;

        if (! noProgressBar) {
            progressFrame = new JFrame("Raja");
            progressFrame.getContentPane().setLayout(new BorderLayout(10, 10));
            progressFrame.setBounds(300, 300, 300, 120);
            progressFrame.show();
        }

        for(int i = first ; i <= last ; i++)
        {
            Camera camera = travelling[i-1];

            System.out.println("\nCalcul de l'image " + i + "/" + travelling.length);

            Renderer renderer = new BasicRenderer(camera, resolution, rayTracer, sampler, BufferedImage.TYPE_3BYTE_BGR);
            BufferedImage image = renderer.getImage();
            BoundedRangeModel model = renderer.getModel();

            long starttime, endtime;
            JProgressBar progress = null;
            JLabel label = null;

            if (! noProgressBar) {
                progress = new JProgressBar();
                progress.setPreferredSize(new Dimension(100, 40));
                Border border = progress.getBorder();
                Border margin = new EmptyBorder(0, 10, 10, 10);
                progress.setBorder(new CompoundBorder(margin, border));
                progress.setStringPainted(true);

                label = new JLabel("Calcul de l'image " + i + "/" + travelling.length, SwingConstants.CENTER);
                label.setForeground(Color.black);

                progressFrame.getContentPane().add(label, BorderLayout.CENTER);
                progressFrame.getContentPane().add(progress, BorderLayout.SOUTH);
                progressFrame.validate();
                progress.setModel(model);
            }

            starttime = System.currentTimeMillis();
            renderer.run();
            endtime = System.currentTimeMillis();

            if (! noProgressBar) {
                progressFrame.getContentPane().remove(label);
                progressFrame.getContentPane().remove(progress);
            }

            System.out.println("Temps de calcul : " + ((double) endtime - starttime) / 1000 + " secondes");

            String fileName = argv[index] + "-" + i + ".pnm";
            System.out.print("Enregistrement du fichier PNM " + fileName + " : ");
            OutputStream os = new BufferedOutputStream(new FileOutputStream(fileName));
            ImageEncoder enc = ImageCodec.createImageEncoder("PNM", os, new PNMEncodeParam());
            enc.encode(image);
            os.close();
            System.out.println("termin�.\n");
        }

        if (! noProgressBar) {
            progressFrame.setVisible(false);
            progressFrame.dispose();
            System.exit(0);
        }
    }
}


// =========================================
// File: /raja/test/DamierTexture.java
// =========================================

package raja.test;

import raja.*;
import raja.shape.*;
import raja.io.*;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class DamierTexture implements Texture, java.io.Serializable, Writable
{
    private RGB kd1, kd2, kr, kt;
    private int ns, nt;
    private double step, x0, y0;
    
    public DamierTexture(Color c1, Color c2, 
			 int ns, int nt, 
			 double step, double x0, double y0)
    {
	BufferedImage bi=new BufferedImage (3, 3, 1);
        Graphics2D g2d=bi.createGraphics ();
        g2d.setBackground (Color.white);
        g2d.clearRect (0, 0, 3, 3);
        GradientPaint gp=new GradientPaint (0, 0, c1, 3, 3, c2, true);
        g2d.setPaint (gp);
        g2d.fillRect (0, 0, 3, 3);

	final double X255=255.0;
	
        int rgb=bi.getRGB (1, 1);
        Color ncol=new Color (rgb);
	
	double nr=((double)ncol.getRed ());
	double ng=((double)ncol.getGreen ());
	double nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        this.kd1=new RGB (nr, ng, nb);

        rgb=bi.getRGB (0, 0);
        ncol=new Color (rgb);
        
        nr=((double)ncol.getRed ());
	ng=((double)ncol.getGreen ());
	nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        RGB ofi=new RGB (nr, ng, nb);

        this.kd2=ofi;
        
        this.kr=ofi;

        rgb=bi.getRGB (0, 0);
        ncol=new Color (rgb);

	nr=((double)ncol.getRed ());
	ng=((double)ncol.getGreen ());
	nb=((double)ncol.getBlue ());
        
        nr=((1.0)/(X255))*nr;
        ng=((1.0)/(X255))*ng;
        nb=((1.0)/(X255))*nb;
        
        if (nr > 1.0) nr=1.0;
        if (nr < 0.0) nr=0.0;
        if (ng > 1.0) ng=1.0;
        if (ng < 0.0) ng=0.0;
        if (nb > 1.0) nb=1.0;
        if (nb < 0.0) nb=0.0;
        
        ofi=new RGB (nr, ng, nb);

        this.kt=ofi;

        this.ns=ns;
        this.nt=nt;

	this.step = step;
        this.x0 = x0;
        this.y0 = y0;
        
        g2d.dispose ();
        bi=null;
    }
    
    public DamierTexture(RGB kd1, RGB kd2, RGB kr, RGB kt, int ns, int nt, double step, double x0, double y0)
    {
	this.kd1 = kd1;
	this.kd2 = kd2;
	this.kr = kr;
	this.kt = kt;
	this.ns = ns;
	this.nt = nt;
        this.step = step;
        this.x0 = x0;
        this.y0 = y0;
    }

    /**
     * Builds the object LocalTexture from a StreamLexer.
     */
    public static Object build(ObjectReader reader)
	throws java.io.IOException
    {
	/* Initialisation */
	HashMap map = new HashMap();

	map.put("kdUn",null);
	map.put("kdDeux",null);
	map.put("kr",null);
	map.put("kt",null);
	map.put("ns",null);
	map.put("nt",null);
	map.put("step",null);
	map.put("x",null);
	map.put("y",null);

	/* Parsing */
	reader.readFields(map);

        return new DamierTexture((RGB) map.get("kdUn"),
                                 (RGB) map.get("kdDeux"),
                                 (RGB) map.get("kr"),
                                 (RGB) map.get("kt"),
                                 ((Number) map.get("ns")).intValue(),
                                 ((Number) map.get("nt")).intValue(),
                                 ((Number) map.get("step")).doubleValue(),
                                 ((Number) map.get("x")).doubleValue(),
                                 ((Number) map.get("y")).doubleValue());
    }

	// ADDED by Murat Inan
	@Override
	public String getUsageInformation() {
		return "";
	}

	@Override
    public String toExampleString() {
     return "null";
    }
   
	@Override
    public Texture getInstance(String info) {
		return null;
	}
	////////////////
	
    public LocalTexture getLocalTexture(Point3D p)
    {
	double i = Math.floor((p.x - x0) / step);
	double j = Math.floor((p.y - y0) / step);

	if ((i - j) % 2 == 0) {
	    return new LocalTexture(kd1, kr, kt, ns, nt);
	}
	else {
	    return new LocalTexture(kd2, kr, kt, ns, nt);
	}
    }
    public void write(ObjectWriter writer) throws java.io.IOException
    {
        Object[][] fields = { { "kdUn", kd1 },
                              { "kdDeux", kd2 },
                              { "kr", kr },
                              { "kt", kt },
                              { "ns", new Integer(ns) },
                              { "nt", new Integer(nt) },
                              { "step", new Double(step) },
                              { "x", new Double(x0) },
                              { "y", new Double(y0) } };
        writer.writeFields(fields);
    }
}


// =========================================
// File: /raja/test/ConvertWithJAI.java
// =========================================

/* $Id: ConvertWithJAI.java,v 1.2 2001/02/18 08:29:24 gregoire Exp $
 * Copyright (C) 2001 E. Fleury & G. Sutre
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package raja.test;

import java.awt.image.*;
import java.io.*;
import com.sun.media.jai.codec.*;


/*
 * Program to convert images, using JAI directly.
 *
 * Usage: java raja.test.ConvertWithJAI infile outfile
 *
 * WARNING: This class is not part of the core Raja API.  It is primarily
 * used by Raja developpers to validate their implementations.  It does not
 * contain much error handling.
 */

class ConvertWithJAI
{
    public static void main(String[] argv) throws IOException
    {
        // Parse command line arguments
        int index = 0;
        String inputFileName = argv[index++];
        String outputFileName = argv[index++];


        // Deduce input and output codecs from file name extensions
        String inputCodec = raja.io.ImageIO.suffix2Codec(inputFileName);

        if (inputCodec == null)
        {
            System.err.println("Could not deduce codec for file: " + inputFileName);
            System.err.println("ConvertWithJAI aborted.");
            System.exit(1);
        }

        String outputCodec = raja.io.ImageIO.suffix2Codec(outputFileName);

        if (outputCodec == null)
        {
            System.err.println("Could not deduce codec for file: " + outputFileName);
            System.err.println("ConvertWithJAI aborted.");
            System.exit(1);
        }


        // Read input image
        System.out.println("Reading " + inputCodec + " file: " + inputFileName + "...");
        InputStream is = new BufferedInputStream(new FileInputStream(inputFileName));
        ImageDecoder dec = ImageCodec.createImageDecoder(inputCodec, is, null);

        if (dec == null)
        {
            System.err.println("Could not find an image decoder for this codec: " +
                               inputCodec);
            System.err.println("ConvertWithJAI aborted.");
            System.exit(1);
        }

        RenderedImage image = dec.decodeAsRenderedImage();
        System.out.println("done.\n");


        // Write image in output file
        System.out.println("Writing " + outputCodec + " file: " + outputFileName + "...");
        OutputStream os = new BufferedOutputStream(new FileOutputStream(outputFileName));
        ImageEncoder enc = ImageCodec.createImageEncoder(outputCodec, os, null);

        if (enc == null)
        {
            System.err.println("Could not find an image encoder for this codec: " +
                               outputCodec);
            System.err.println("ConvertWithJAI aborted.");
            System.exit(1);
        }

        enc.encode(image);


        // Close the output stream
        os.close();
        System.out.println("done.");


        // Close the input stream
        // Remark: trying to access the input image after closing the input
        // stream may fail, since the input image is decoded as needed
        is.close();
    }
}


// =========================================
// File: /net/murat/rajaext/PaintPanel.java
// =========================================

package net.murat.rajaext;

final 
public class PaintPanel
     extends javax.swing.JPanel
{
    
    private java.awt.image.BufferedImage bimg = null;
	
    public PaintPanel ()
	{
	    super (true);
	    setPreferredSize (new java.awt.Dimension (640, 480));
	}
	
	final
	public java.awt.image.BufferedImage getBufferedImage ()
	{
	    return bimg;
	}
	
	final
	public void setBufferedImage (java.awt.image.BufferedImage bi)
	{
	    this.bimg = bi;
	    this.repaint ();
	}
	
	public void paint (java.awt.Graphics g)
	{
	    super.paint (g);
	}
	
	public void paintChildren (java.awt.Graphics g)
	{
	    super.paintChildren (g);
	}
	
	public final void update (java.awt.Graphics g)
	{
	    paintComponent (g);
	}
	
	protected final void paintComponent (java.awt.Graphics g)
	{
	    super.paintComponent (g);
	    
	    java.awt.Dimension d = this.getSize ();
	    int w = d.width;
	    int h = d.height;
	    
	    g.setColor (java.awt.Color.white);
	    g.fillRect (0, 0, w, h);
	    
	    if (bimg != null)
	    {
	        g.drawImage (bimg, 0, 0, this);
	    }
	    return;
	}
	
}
//class end


// =========================================
// File: /net/murat/rajaext/FilterOBJ.java
// =========================================

// Murat Inan
package net.murat.rajaext;

import javax.swing.filechooser.*;

/**
 * Simple class for showing obj files
 *
 * @author Murat iNAN
 */
public 	class 	FilterOBJ
extends FileFilter
implements java.io.Serializable
{
  
  /**
   * @param f All files
   * @return If is directory or is au file true
   *         otherwise false
   */
  public boolean accept (java.io.File f)
  {
    if (f.isDirectory ())
    {
      return true;
    }
    
    String name = f.getName ();
    
    if (name != null)
    {
      name = name.toLowerCase ();
    }
    
    if (name.endsWith (".txt"))
    {
      return true;
    }
    
    return false;
  }
  
  /** @return "text" files*/
  public String getDescription ()
  {
    return "Plain TEXT files";
  }
  
}


// =========================================
// File: /net/murat/rajaext/RajaRayTracerGUI.java
// =========================================

package net.murat.rajaext;

import java.io.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;

import javax.swing.*;

// raja
import raja.*;
import raja.material.*;
import raja.ui.*;
import raja.util.*;
import raja.light.*;
import raja.shape.*;
import raja.renderer.*;

public class RajaRayTracerGUI extends JPanel implements Serializable, ActionListener {
    private final PaintPanel paintPanel = new PaintPanel();
	
	private int width = 800;
    private int height = 600;
    
    private BufferedImage bimg = new BufferedImage(width, height,  
		BufferedImage.TYPE_INT_ARGB);
	
	private final java.util.LinkedList<TexturedForm> txFormList = new java.util.LinkedList<TexturedForm>();
	private final java.util.LinkedList<String> txFormNamesList = new java.util.LinkedList<String>();
	//private final java.util.LinkedList<String> txFormFullNamesList = new java.util.LinkedList<String>();
	//private final java.util.LinkedList<String> cameraInfoList = new java.util.LinkedList<String>();
	//private final java.util.LinkedList<String> lightsInfoList = new java.util.LinkedList<String>();
	//private final java.util.LinkedList<String> texturesInfoList = new java.util.LinkedList<String>();

    private final Aggregate solids = new Aggregate();
    private final raja.util.List lights = new raja.util.List();
    
    private final JFileChooser jfc = new JFileChooser (new File ("."));
    private final JFileChooser mfc = new JFileChooser (new File ("."));

    final private JTextArea SHAPEAREA=getTextArea (9, 55);
	final private JScrollPane JSPSHAPE=new JScrollPane (SHAPEAREA);
  
	final private JTextArea MATERIALAREA=getTextArea (12, 55);
	final private JScrollPane JSPMATERIAL=new JScrollPane (MATERIALAREA);
	
	final private JTextArea LIGHTAREA=getTextArea (8, 55);
	final private JScrollPane JSPLIGHT=new JScrollPane (LIGHTAREA);
	
	final private JTextArea CAMERAAREA=getTextArea (8, 55);
	final private JScrollPane JSPCAMERA=new JScrollPane (CAMERAAREA);
    
    final private JTextArea UNIINTAREA=getTextArea (12, 55);
	final private JScrollPane JSPUNIINT=new JScrollPane (UNIINTAREA);
    
    private final JTextField torderField = getField("TRS"); 
    private final JTextField txField = getField("0.0"); 
    private final JTextField tyField = getField("0.0"); 
    private final JTextField tzField = getField("0.0"); 
    private final JTextField rxField = getField("0.0"); 
    private final JTextField ryField = getField("0.0"); 
    private final JTextField rzField = getField("0.0"); 
    private final JTextField sxField = getField("1.0"); 
    private final JTextField syField = getField("1.0"); 
    private final JTextField szField = getField("1.0"); 

    private JComboBox<String> samplerBox = null;
    private JComboBox<String> cameraBox = null;
    private JComboBox<String> lgBox = null;
    private JComboBox shapesBox = null;
    private JList<String> materialesBox = null;
    
    private final String[] OPTVALS = new String[] {"Set", "Cancel"};
    
    //private final int MILS = 500;

	private JButton createButton = new JButton("");
	private final JProgressBar bar = new JProgressBar ();

    private Camera camera = new HorizontalCamera(
      new Point3D(-3.0, 0.0, 0.0),    // Point
      new Vector3D(1.0, 0.0, 0.0),   // X eksenine bak
      1.8, 2.0, 1.5                  // Focal, screen width/height
    );
    
    private final Camera DEFAULTCAM = camera;
    private final Texture DEFAULT_TEXTURE = new LambertianTexture(new RGB(0.2, 0.2, 0.7));
    
    private final LightSource DEFAULTLS = new PointLightSource(
			new Point3D(-5.0, 0.0, 5.0), 
			new RGB(1.0, 1.0, 1.0)
	);
	
    private World world = null;
    private RGB ambientShadow = new RGB(0.1, 0.1, 0.1);
    private RGB bgColor = new RGB(0.0, 0.0, 0.7);
    
    private int depth = 3;
    private Volume volume = new IsotropicVolume(0.5);
        
    private Sampler sampler = new DiadicSampler();
	private int alias = 2;
	
	private boolean processing = false;

    private RajaRayTracerGUI() {
        super(new BorderLayout());
        
		lights.add(DEFAULTLS);
		
		//cameraInfoList.add("Constructor is: HorizontalCamera(Point3D origin, Vector3D direction, double focal, double screenWidth, double screenHeight);\nExample:\n-5,0,0,  1,0,0,  1.8,  2,  1.5\nEnter your values after three diyez symbol\n###\n");
		//lightsInfoList.add("Constructor is: PointLightSource(double x, double y, double z, RGB light);\nExample:\n-3,0,5,  1.0, 1.0, 1.0\nEnter your values after three diyez symbol\n###\n");

		world = new World(
			solids,
			lights,
			new RGB(0.0, 0.0, 0.7),  // Background
			new RGB(0.1, 0.1, 0.1),  // Ambient-Shadow
			new IsotropicVolume(1.0)
		);
		
        mfc.addChoosableFileFilter (new FilterOBJ ());

        JTabbedPane tabbedPane = new JTabbedPane();
        tabbedPane.setForeground(new Color(0.1f, 0.1f, 0.9f));
        tabbedPane.setBackground(new Color(0.9f, 0.9f, 0.9f));
        tabbedPane.setFont(new Font("Segoe UI", Font.BOLD, 20));
        
        // Sekmeleri oluştur
        tabbedPane.addTab("Rendered Image", new JScrollPane(paintPanel));
        tabbedPane.addTab("Render Settings", createRenderSettingsPanel());
        tabbedPane.addTab("Camera & Lights", createCameraLightsPanel());
        tabbedPane.addTab("Shapes", createShapesPanel());
        
        add(tabbedPane, BorderLayout.CENTER);
        
        JPanel southPanel = new JPanel(new GridLayout(0, 4));
        
        createButton = getButton("Generate Image");
        createButton.addActionListener(this);
		createButton.setBackground(new Color(40, 167, 69)); // Yeşil tonu
		createButton.setForeground(Color.WHITE);
		createButton.setFont(new Font("Segoe UI", Font.BOLD, 24));
        southPanel.add(createButton);
        
        JButton fromFileButton = getButton("Reproduce");
		fromFileButton.setBackground(new Color(90, 43, 83));
		fromFileButton.setForeground(Color.WHITE);
		fromFileButton.setFont(new Font("Segoe UI", Font.BOLD, 24));
        fromFileButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
				int rep=mfc.showOpenDialog (paintPanel);
				if (rep != JFileChooser.APPROVE_OPTION) return;
    
				File f=mfc.getSelectedFile ();
				
				try {
					InputStream fis = new FileInputStream(f);
					
					//BURASI IMPLEMENTS EDILECEK
				
					fis.close();
				} catch (IOException ioe) {
					ioe.printStackTrace();
					return;
				}
			}
		});
        southPanel.add (fromFileButton);
        
        JButton saveButton = getButton("Save");
		saveButton.setBackground(new Color(69, 53, 253)); // Mavi tonu
		saveButton.setForeground(Color.WHITE);
		saveButton.setFont(new Font("Segoe UI", Font.BOLD, 24));
        saveButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                if (bimg == null) return;
                
                int rep=jfc.showSaveDialog (paintPanel);
				if (rep != JFileChooser.APPROVE_OPTION) return;
    
				File f=jfc.getSelectedFile ();
				
				String nm = f.getName();
				nm = nm.toLowerCase();
				
				String FORMAT = "PNG";
				
				if (nm.endsWith(".png")) {
					FORMAT = "PNG";
				} else if (nm.endsWith(".jpg")) {
					FORMAT = "JPG";
				} else if (nm.endsWith(".jpeg")) {
					FORMAT = "JPEG";
				} else {
					JOptionPane.showMessageDialog(paintPanel, "Only PNG/JPG/JPEG supported.");
					return;
				}
				
				try {
					ImageIO.write(bimg, FORMAT, f);
					
					String fobjname = "test.txt";
					String name = f.getName();
					int index = name.lastIndexOf(".");
					if (index > 0) {
						fobjname = (name.substring(0, index))+".txt";
					}
					File fscfile = new File("scenes");
					if (fscfile.exists() == false) fscfile.mkdir();
					OutputStream fos = new FileOutputStream("scenes/"+fobjname);
					PrintStream ps = new PrintStream(fos, true, "UTF-8");
					
					ps.println(world.toImportantParametersString());
					ps.println(""+(camera.toString())+"\n");
					
					ps.println("/** STARTS LIGHTS: */");
					
					int size = lights.size();
					for (int i = 0; i < size; i++) {
						ps.println(lights.get(i));
						ps.println("");
				    }
				    //ps.print("\b");
				    ps.println("/** ENDS LIGHTS */\n");
				    
				    ps.println("/** STARTS GEOMETRIES/SHAPES/FORMS */");
					
					size = txFormList.size();
					
					//int size2 = texturesInfoList.size();
					//if (size != size2) {
						//System.out.println("ERROR size != size2");
						//ps.flush();
						//ps.close();
						//fos.flush();
						//fos.close();
						//return;
					//}
					
					for (int i = 0; i < size; i++) {
						TexturedForm tfim = txFormList.get(i);
						ps.println(tfim.toString());
						if (tfim instanceof BasicTexturedForm) {
							BasicTexturedForm xtfim = (BasicTexturedForm)(tfim);
							Form forme = xtfim.getForm();
							if (forme instanceof BasicForm) {
								BasicForm bform = (BasicForm)forme;
								ps.println(bform.getTransform().toParametersString());
							}
							
							Texture fiturIN = xtfim.getTextureIN ();
							if (fiturIN instanceof TransparentPNGTexture) {
								String path = ((TransparentPNGTexture)(fiturIN)).getImagePath();
								ps.println("// TextureINPath: " + path + "");
							} else if (fiturIN instanceof ImageTexture) {
								String path = ((ImageTexture)(fiturIN)).getImagePath();
								ps.println("// TextureINPath: " + path + "");
							} else if (fiturIN instanceof ImageSpheringTexture) {
								String path = ((ImageSpheringTexture)(fiturIN)).getImagePath();
								ps.println("// TextureINPath: " + path + "");
							} else {
							}
							
							Texture fiturOUT = xtfim.getTextureOUT ();
							if (fiturOUT instanceof TransparentPNGTexture) {
								String path = ((TransparentPNGTexture)(fiturOUT)).getImagePath();
								ps.println("// TextureOUTPath: " + path + "");
							} else if (fiturOUT instanceof ImageTexture) {
								String path = ((ImageTexture)(fiturOUT)).getImagePath();
								ps.println("// TextureOUTPath: " + path + "");
							} else if (fiturOUT instanceof ImageSpheringTexture) {
								String path = ((ImageSpheringTexture)(fiturOUT)).getImagePath();
								ps.println("// TextureOUTPath: " + path + "");
							} else {
							}
							
						}
						//ps.println("%%%");
						//ps.println(texturesInfoList.get(i));
						ps.println("-----------------");
				    }
				    
				    ps.println("END");
				    
					ps.flush();
					ps.close();
					fos.flush();
					fos.close();
					JOptionPane.showMessageDialog(paintPanel, "Saved successfully: "+(f.getName()));
					return;
				} catch (IOException ioe) {
					JOptionPane.showMessageDialog(paintPanel, ioe.getMessage());
					return;
				}
            }
        });
        southPanel.add(saveButton);
        
        JButton exitButton = getButton("Exit");
		exitButton.setBackground(new Color(220, 53, 69)); // Kırmızı tonu
		exitButton.setForeground(Color.WHITE);
		exitButton.setFont(new Font("Segoe UI", Font.BOLD, 24));
        exitButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                System.exit(0);
            }
        });
        southPanel.add(exitButton);
        
        add(southPanel, BorderLayout.SOUTH);
    }
    
    private JPanel createRenderSettingsPanel() {
    JPanel panel = new JPanel(new BorderLayout(5, 5));
    panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
    
    // Main container for better centering
    JPanel mainPanel = new JPanel(new GridLayout(4, 1, 5, 5));
    
    // Resolution Settings
    JPanel resPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
    resPanel.add(getLabel("Width:"));
    final JTextField widthField = getField("800");
    widthField.setColumns(6);
    resPanel.add(widthField);
    resPanel.add(getLabel("Height:"));
    final JTextField heightField = getField("600");
    heightField.setColumns(6);
    resPanel.add(heightField);
    mainPanel.add(resPanel);
    
    // Sampler Settings
    JPanel samplerPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
    samplerPanel.add(getLabel("Sampler:"));
    final String[] samplers = {"Diadic Sampler", "Basic Sampler", "Naive Super Sampler"};
    samplerBox = getComboBox(samplers);
    samplerPanel.add(samplerBox);
    samplerPanel.add(getLabel("Alias:"));
    final JTextField aliasField = getField("2");
    aliasField.setColumns(4);
    samplerPanel.add(aliasField);
    mainPanel.add(samplerPanel);
    
    // Render Quality Settings
    JPanel qualityPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
    qualityPanel.add(getLabel("Depth:"));
    final JTextField depthField = getField("3");
    depthField.setColumns(4);
    qualityPanel.add(depthField);
    qualityPanel.add(getLabel("Volume:"));
    final JTextField volumeField = getField("1"); // 1.5 is glass
    volumeField.setColumns(4);
    qualityPanel.add(volumeField);
    mainPanel.add(qualityPanel);
    
    // Render Buttons
    JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
    JButton ambientButton = getButton("Ambient/Shadow");
    ambientButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
            Color col = JColorChooser.showDialog(paintPanel, "Ambient/Shadow Color:", Color.BLACK);
            if (col == null) return;
            
            int ri = col.getRed();
            int gi = col.getGreen();
            int bi = col.getBlue();
            
            double r = ((double)ri) / 255.0;
            double g = ((double)gi) / 255.0;
            double b = ((double)bi) / 255.0;
            
            ambientShadow = new RGB(r, g, b);
            
            return;
        }
    });
    buttonPanel.add(ambientButton);
    JButton worldBGButton = getButton("BG Color");
    worldBGButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
            Color col = JColorChooser.showDialog(paintPanel, "World BG Color:", Color.BLACK);
            if (col == null) return;
            
            int ri = col.getRed();
            int gi = col.getGreen();
            int bi = col.getBlue();
            
            double r = ((double)ri) / 255.0;
            double g = ((double)gi) / 255.0;
            double b = ((double)bi) / 255.0;
            
            bgColor = new RGB(r, g, b);
            
            return;
        }
    });
    buttonPanel.add(worldBGButton);
    JButton setWorldButton = getButton("Set");
    setWorldButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
            try {
                width = Integer.parseInt(widthField.getText());
                height = Integer.parseInt(heightField.getText());
                bimg = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
                
                alias = Integer.parseInt(aliasField.getText());
                depth = Integer.parseInt(depthField.getText());
                volume = new IsotropicVolume(Double.parseDouble(volumeField.getText()));
                
                int sindex = samplerBox.getSelectedIndex();
                
                if (sindex == 0) {
                    sampler = new DiadicSampler();
                } else if (sindex == 1) {
                    sampler = new BasicSampler();
                } else if (sindex == 2) {
                    sampler = new NaiveSuperSampler(alias);
                } else {
                    sampler = new BasicSampler();
                }
                
                world = new World(
                    solids,
                    lights,
                    bgColor,
                    ambientShadow,
                    volume
                );
            } catch (NumberFormatException nfe) {
                JOptionPane.showMessageDialog(paintPanel, nfe.getMessage());
                return;
            }
            
            return;
        }
    });
    buttonPanel.add(setWorldButton);
    
    mainPanel.add(buttonPanel);
    
    // Center the main panel
    panel.add(mainPanel, BorderLayout.CENTER);
    
    return panel;
}

private JPanel createCameraLightsPanel() {
    JPanel panel = new JPanel(new BorderLayout(5, 5));
    panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
    
    // Main container for better centering
    JPanel mainPanel = new JPanel(new GridLayout(3, 1, 5, 5));
    
    // Camera Settings
    JPanel camPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
    camPanel.add(getLabel("Camera:"));
    final String[] cameras = {"Horizontal Camera", "Stereo Camera"};
    final Camera[] xcameras = {
        DEFAULTCAM,
        new StereoCamera(
            new Point3D(-3.0, 0.0, 0.0),
            new Vector3D(1.0, 0.0, 0.0),
            1.8, 2.0, 1.5, 5.0, true
        )
    };
    
    cameraBox = getComboBox(cameras);
    camPanel.add(cameraBox);
    JButton setCamButton = getButton("Set Camera");
    setCamButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
            int cindex = cameraBox.getSelectedIndex();
            
            Camera aremac = xcameras[cindex];
            CAMERAAREA.setText(aremac.getUsageInformation());
                
            int intiline = JOptionPane.showOptionDialog(paintPanel, JSPCAMERA,
                "Change camera according lines below:",
                JOptionPane.YES_NO_CANCEL_OPTION,
                JOptionPane.PLAIN_MESSAGE,
                null,
                OPTVALS,
                OPTVALS[0]);
    
            if ((intiline < 0) || (intiline > 0)) return; // Cancel
            
            camera = aremac.getInstance(CAMERAAREA.getText());
            // cameraInfoList.clear();
            // cameraInfoList.add(aremac.toExampleString());
            // System.out.println("DEBUG: "+aremac.toExampleString());
            System.out.println(camera.toString());
            
            return;
        }
    });
    camPanel.add(setCamButton);
    mainPanel.add(camPanel);
    
    // Light Settings
    JPanel lightPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
    lightPanel.add(getLabel("Light Type:"));
    final String[] lghts = {"Point Light", "Directional Light", "Spot Light"};
    final LightSource[] lsources = {
        new PointLightSource(
            new Point3D(-3.0, 0.0, 5.0), 
            new RGB(1.0, 1.0, 1.0)
        ),
        new DirectionalLightSource(
            new Vector3D(-5.0, 0.0, 5.0), 
            new RGB(1.0, 1.0, 1.0)
        ),
        new SpotLightSource(
            -3.0, 0.0, 5.0, 
            0, 1, 0, 
            5.0, 25.0,
            RGB.white
        )
    };
    lgBox = getComboBox(lghts);
    lightPanel.add(lgBox);
    JButton addLightButton = getButton("Add Light");
    addLightButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
            int cindex = lgBox.getSelectedIndex();
            
            LightSource lxs = lsources[cindex];
            LIGHTAREA.setText(lxs.getUsageInformation());
                    
            int intiline = JOptionPane.showOptionDialog(paintPanel, JSPLIGHT,
                "Add light according lines below:",
                JOptionPane.YES_NO_CANCEL_OPTION,
                JOptionPane.PLAIN_MESSAGE,
                null,
                OPTVALS,
                OPTVALS[0]);
    
            if ((intiline < 0) || (intiline > 0)) return; // Cancel
            
            LightSource lsource = lxs.getInstance(LIGHTAREA.getText());
            System.out.println(lsource.toString());
            lights.add(lsource);
            // lightsInfoList.add(lxs.toExampleString());
            
            return;
        }
    });
    lightPanel.add(addLightButton);
    mainPanel.add(lightPanel);
    
    // Light Management
    JPanel lightMgmtPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
    JButton remLastLightButton = getButton("Remove Last Light");
    remLastLightButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
            if (lights.size() < 1) return;
            System.out.println("Removing: " + (lights.getLast().toString()));
            lights.removeLast();
            // lightsInfoList.removeLast();
            return;
        }
    });
    lightMgmtPanel.add(remLastLightButton);
    JButton remAllLightsButton = getButton("Remove All Lights");
    remAllLightsButton.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
            if (lights.size() < 1) return;
            lights.clear();
            // lightsInfoList.clear();
            System.out.println("Removed all lights from list.");
            return;
        }
    });
    lightMgmtPanel.add(remAllLightsButton);
    mainPanel.add(lightMgmtPanel);
    
    // Center the main panel
    panel.add(mainPanel, BorderLayout.CENTER);
    
    return panel;
}

    private JPanel createShapesPanel() {
        JPanel panel = new JPanel(new BorderLayout(5, 5));
		panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
   
        // Shape Selection
        JPanel shapeSelectPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        shapeSelectPanel.add(getLabel("Shape:"));
        final String[] shapes = {
			   "Plane", "Sphere", "Cylinder", "Cone", 
			   "Box", "Rectangle", "Torus", "Triangle", 
			   "Billboard", "Union", "Intersection"
		};
		final BasicForm[] xformes = {
			new MPlane(new Vector3D(0, 0, 1)),
			new MSphere(1.0),
			new MCylinder(1.0, 1.0),
			new MCone(new Point3D(0, 0, 0), new Vector3D(0, 0, 1), 0.5, 1.0),
			new MBox(new Point3D(-1, -1, -1), new Point3D(1, 1, 1)),
			new XRectangle(new Vector3D(0, 0, 1), 2, 1),
			new MTorus(1.0, 0.5),
			new MTriangle(new Point3D(-0.5, -0.5, -0.5), new Point3D(0.5, 0.5, 0.5), new Point3D(1, -1, 1)),
			new Billboard(10, 10, true)
		};
        shapesBox = getComboBox(shapes);
        shapeSelectPanel.add(shapesBox);
        
        shapeSelectPanel.add(getLabel("Material:"));
        final String[] materiales = {
			"Plain", "Damier", "Checkerboard", "Emissive", 
			"Dielectric", "Image", "ImageSphering", "Lambertian", 
			"Metal", "AfricanKente", "Anodized", "CeramicTile", 
			"CrystalCave", "Hokusai", "Marble", "NorwegianRose", 
			"TurkishTile", "TiledRoof", "Wood", "Void", 
			"XRay", "TransparentPNG", "Hologram", "Prism", 
			"Lava", "Water", "Storm", "AuroraCeramic",
			"Pattern", "KilimRosemaling", "NordicWeave", "NorthernLight",
			"ColorWheel", "Grid", "Plastic", "Stripes",
			"AnisotropicMetal", "DreamMist", "ObsidianHeart", "Sand"
		};
		final Texture[] xtextures = {
			new XPlainTexture(),
			new XDamierTexture(new RGB(1.0, 0.0, 0.0), new RGB(1.0, 1.0, 1.0), new RGB(0.0, 0.3, 0.0), new RGB(0.2, 0.0, 0.0), 100, 10, 4.0, 0.0, 0.0),
			new CheckerboardTexture(new RGB(1.0, 0.0, 0.0), new RGB(0.0, 1.0, 0.0), new RGB(0.5, 0.5, 0.5), new RGB(0.0, 0.0, 0.0), 150, 10, 0.3, 0.0, 0.0, 0.0),
			new EmissiveTexture(RGB.red, 0.35),
			new DielectricTexture(new RGB(0.0, 0.0, 0.8), 0.7, 0.4, 200),
			new ImageTexture(new BufferedImage(1, 1, 1), new RGB(0.5, 0.5, 0.5), new RGB(0.1, 0.1, 0.1), new RGB(0.0, 0.0, 0.0), 50, 10, 1.0, 1.0, 0.0, 0.0, 1.5, 1.5, 0.0, 0.0, 0.0),
			new ImageSpheringTexture(new BufferedImage(1, 1, 1), new RGB(0.5, 0.5, 0.5), new RGB(0.3, 0.3, 0.3), new RGB(0.0, 0.0, 0.0), 100, 10, 0.2, 0.0, 0.0, 1.0, 1.0),
			new LambertianTexture(),
			new MetalTexture(RGB.red),
			new AfricanKenteTexture(),
			new AnodizedTexture(),
			new CeramicTileTexture(new RGB(1,1,1), new RGB(0.9,0.9,0.9), new RGB(0.8,0.82,0.8), 4.0, 0.005, 0),
			new CrystalCaveTexture(),
			new HokusaiTexture(),
			new MarbleTexture(),
			new NorwegianRoseTexture(),
			new TurkishTileTexture(),
			new TiledRoofTexture(),
			new WoodTexture(),
			new VoidTexture(),
			new XRayTexture(),
			new TransparentPNGTexture(new BufferedImage(1, 1, 1), new RGB(0.5, 0.5, 0.5), new RGB(0.0, 0.0, 0.0), new RGB(0.0, 0.0, 0.0), 30, 10, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0),
			new HologramTexture(),
			new PrismTexture(),
			new LavaTexture(),
			new WaterTexture(),
			new StormTexture(),
			new AuroraCeramicTexture(),
			new PatternTexture(),
			new KilimRosemalingTexture(),
			new NordicWeaveTexture(),
			new NorthernLightTexture(),
			new ColorWheelTexture(), 
			new GridTexture(),
			new PlasticTexture(),
			new StripesTexture(),
			new AnisotropicMetalTexture(),
			new DreamMistTexture(),
			new ObsidianHeartTexture(),
			new SandTexture()
		};
		
        materialesBox = new JList<String>(materiales);
        materialesBox.setForeground(new Color(0.8f, 0.1f, 0.1f));
        materialesBox.setFont(new Font("Serif", 1, 15));
        materialesBox.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		materialesBox.setVisibleRowCount(20);
		JScrollPane materialesScroll = new JScrollPane(materialesBox);
		materialesScroll.setPreferredSize(new Dimension(200, 400));
		shapeSelectPanel.add(materialesScroll);
        
        JButton addShapeButton = getButton("Add Shape");
        addShapeButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				BasicForm form = null;
				Texture texture = null;
				Matrix4 transform = null;
				
				BasicForm xfx = null;
				
				int cindex = shapesBox.getSelectedIndex();
				if (cindex == 8) { // union
					int size = txFormList.size();
					if (size < 2) return;
					
					Union union = new Union();
					StringBuffer ubuf = new StringBuffer("UNION: \n");
					for (int i = 0; i < size; i++) {
						ubuf.append("" + (i) + ": ");
						ubuf.append(txFormNamesList.get(i));
						ubuf.append("\n");
					}
					ubuf.append("Enter the numbers of selected shapes for union, separated with comma:###\n");
					
					UNIINTAREA.setText(ubuf.toString());
					
					int iline = JOptionPane.showOptionDialog (paintPanel, JSPUNIINT,
					"Enter selected shapes for union:",
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.PLAIN_MESSAGE,
					null,
					OPTVALS,
					OPTVALS [0]);
          
				    if ((iline < 0) || (iline > 0)) return;//Cancel
					
					String hes = UNIINTAREA.getText();
					int hesindex = hes.lastIndexOf("###");
					hes = hes.substring(hesindex+3);
					hes = hes.replaceAll("\n", "");
					hes = hes.replaceAll(" ", "");
					
					String[] split = hes.split(",");
					int slen = split.length;
					
					int numTx = -1;
					for (int i = 0; i < slen; i++) {
						numTx = Integer.parseInt(split [i]);
						TexturedForm tm = txFormList.get(numTx);
						union.addForm(tm);
						//solids.getList().remove(numTx);
						//txFormList.remove(numTx);
						//txFormNamesList.remove(numTx);
					}
					int[] numbers=new int[slen];
					for (int i = 0; i < slen; i++) {
						numTx = Integer.parseInt(split[i]);
						numbers[i]=numTx;
					}
					java.util.Arrays.sort(numbers);
					for (int i = (slen-1); i >= 0; i--) {
						(solids.getList()).remove(numbers[i]);
						txFormList.remove(numbers[i]);
						txFormNamesList.remove(numbers[i]);
						//txFormFullNamesList.remove(numbers[i]);
						//texturesInfoList.remove(numbers[i]);
					}
					
					Solid usolid = new BasicSolid(union, volume); 
					//solids.getList().clear();
					solids.addSolid(usolid);
					
					txFormList.add(union);
					txFormNamesList.add(union.toString());
					//txFormFullNamesList.add(union.toString());
					//texturesInfoList.add("UNION");
					
					return;	
				} else if (cindex == 9) { // intersection
					int size = txFormList.size();
					if (size < 2) return;
					
					Intersection ise = new Intersection();
					StringBuffer ubuf = new StringBuffer("INTERSECTION: \n");
					for (int i = 0; i < size; i++) {
						ubuf.append("" + (i) + ": ");
						ubuf.append(txFormNamesList.get(i));
						ubuf.append("\n");
					}
					ubuf.append("Enter the numbers of selected shapes for intersection, separated with comma:###\n");
					
					UNIINTAREA.setText(ubuf.toString());
					
					int iline = JOptionPane.showOptionDialog (paintPanel, JSPUNIINT,
					"Enter selected shapes for intersection:",
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.PLAIN_MESSAGE,
					null,
					OPTVALS,
					OPTVALS [0]);
          
				    if ((iline < 0) || (iline > 0)) return;//Cancel
					
					String hes = UNIINTAREA.getText();
					int hesindex = hes.lastIndexOf("###");
					hes = hes.substring(hesindex+3);
					hes = hes.replaceAll("\n", "");
					hes = hes.replaceAll(" ", "");
					
					String[] split = hes.split(",");
					int slen = split.length;
					
					int numTx = -1;
					for (int i = 0; i < slen; i++) {
						numTx = Integer.parseInt(split [i]);
						TexturedForm tm = txFormList.get(numTx);
						ise.addForm(tm);
						//solids.getList().remove(numTx);
						//txFormList.remove(numTx);
						//txFormNamesList.remove(numTx);
					}
					int[] numbers=new int[slen];
					for (int i = 0; i < slen; i++) {
						numTx = Integer.parseInt(split[i]);
						numbers[i]=numTx;
					}
					java.util.Arrays.sort(numbers);
					for (int i = (slen-1); i >= 0; i--) {
						(solids.getList()).remove(numbers[i]);
						txFormList.remove(numbers[i]);
						txFormNamesList.remove(numbers[i]);
						//txFormFullNamesList.remove(numbers[i]);
						//texturesInfoList.remove(numbers[i]);
					}
					
					Solid usolid = new BasicSolid(ise, volume); 
					//solids.getList().clear();
					solids.addSolid(usolid);
					
					txFormList.add(ise);
					txFormNamesList.add(ise.toString());
					//txFormFullNamesList.add(ise.toString());
					//texturesInfoList.add("INTERSECTION");

					return;				
				} else { //other basic shapes
					xfx = xformes[cindex];
					SHAPEAREA.setText(xfx.getUsageInformation());
			    }
						
				int intiline = JOptionPane.showOptionDialog (paintPanel, JSPSHAPE,
					"Add shape according lines below:",
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.PLAIN_MESSAGE,
					null,
					OPTVALS,
					OPTVALS [0]);
          
				if ((intiline < 0) || (intiline > 0)) return;//Cancel
				
				if (xfx != null) {
					form = xfx.getInstance(SHAPEAREA.getText());
					System.out.println(form.toString());
				} else {
					form = null;
				}
				
				if (form == null) {
					JOptionPane.showMessageDialog(paintPanel, "Null form error!");
					return;
				}
				
				transform = getTransform();
				form.setTransform(transform);
				
				////// TEXTURE IN //////////
				int[] cindexes = materialesBox.getSelectedIndices();
				final int cilen = cindexes.length;
				if (cilen == 0 || cilen > 2) {
					System.out.println("ERROR: You must select one or two options.");
					return;
				}
				
				boolean multiSelected = false;
				if (cilen == 2) {
					multiSelected = true;
				}
				
				Texture xtx = xtextures[cindexes[0]];
				MATERIALAREA.setText(xtx.getUsageInformation());
				
				intiline = JOptionPane.showOptionDialog (paintPanel, JSPMATERIAL,
					"Select material according lines below:",
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.PLAIN_MESSAGE,
					null,
					OPTVALS,
					OPTVALS [0]);
          
				if ((intiline < 0) || (intiline > 0)) return;//Cancel
				
				texture = xtx.getInstance(MATERIALAREA.getText());
				System.out.println(texture.toString());
				//System.out.println(xtx.toExampleString());
				
				if (texture == null) {
					texture = DEFAULT_TEXTURE;
				}
				
				//TransparentPNG - Billboard coherencia
				if (form instanceof Billboard && 
				    texture instanceof TransparentPNGTexture) {
					((TransparentPNGTexture)texture).setBillboardDimensions(
						((Billboard)form).getWidth(), ((Billboard)form).getHeight());
					((TransparentPNGTexture)texture).setInverseTransform(transform.inverse());
					((TransparentPNGTexture)texture).setUseZForV(false);		
				}
				
				if (form instanceof XRectangle && 
				    texture instanceof TransparentPNGTexture) {
					((TransparentPNGTexture)texture).setBillboardDimensions(
						((XRectangle)form).getXRectangleWidth(), ((XRectangle)form).getXRectangleHeight());
					((TransparentPNGTexture)texture).setInverseTransform(transform.inverse());
					((TransparentPNGTexture)texture).setUseZForV(true);	
				}
				
				if (form instanceof MSphere && 
					texture instanceof ImageSpheringTexture) {
						((ImageSpheringTexture)texture).setSphereInfo(
							transform.transformPoint(((MSphere)form).getLocalCenter()),
							transform.inverse()
						);
				}

				Texture texture_in = texture;
				Texture texture_out = texture;
				///////////// TEXTURE IN ENDS ///////
				
				//////////// TEXTURE OUT STARTS ////////////
				if (multiSelected) {
				xtx = xtextures[cindexes[1]];
				MATERIALAREA.setText(xtx.getUsageInformation());
				
				intiline = JOptionPane.showOptionDialog (paintPanel, JSPMATERIAL,
					"Select material according lines below:",
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.PLAIN_MESSAGE,
					null,
					OPTVALS,
					OPTVALS [0]);
          
				if ((intiline < 0) || (intiline > 0)) return;//Cancel
				
				Texture mexture = xtx.getInstance(MATERIALAREA.getText());
				System.out.println(mexture.toString());
				//System.out.println(xtx.toExampleString());
				
				if (mexture == null) {
					mexture = DEFAULT_TEXTURE;
				}
				
				//TransparentPNG - Billboard coherencia
				if (form instanceof Billboard && 
				    texture instanceof TransparentPNGTexture) {
					((TransparentPNGTexture)texture).setBillboardDimensions(
						((Billboard)form).getWidth(), ((Billboard)form).getHeight());
					((TransparentPNGTexture)texture).setInverseTransform(transform.inverse());
					((TransparentPNGTexture)texture).setUseZForV(false);	
				}
				
				if (form instanceof XRectangle && 
				    texture instanceof TransparentPNGTexture) {
					((TransparentPNGTexture)texture).setBillboardDimensions(
						((XRectangle)form).getXRectangleWidth(), ((XRectangle)form).getXRectangleHeight());
					((TransparentPNGTexture)texture).setInverseTransform(transform.inverse());
					((TransparentPNGTexture)texture).setUseZForV(true);		
				}
				
				if (form instanceof MSphere && 
					texture instanceof ImageSpheringTexture) {
						((ImageSpheringTexture)texture).setSphereInfo(
							transform.transformPoint(((MSphere)form).getLocalCenter()),
							transform.inverse()
						);
				}
				
				texture_out = mexture;
			}
				/////////// TEXTURE OUT ENDS /////////////
				
				//texture = new LambertianTexture(new RGB(0.0, 0.7, 0.0));
				TexturedForm txForm = null;
				
				if (!multiSelected) {
					txForm = new BasicTexturedForm(form, texture_in);
				} else {
					boolean isRegular = true;
				
				String input = JOptionPane.showInputDialog(paintPanel, 
				 "<html><body><font color=\"red\" size=\"6\">r|e|y</font><font color=\"blue\" size=\"5\"> is regular order texture, other any letter is reverse.</font></body></hyml>");
				if (input == null) {
					isRegular = true;
				} else {
					if (input.length() < 1) {
						isRegular = true;
					} else {
						input = input.toLowerCase();
						final char chr = input.charAt(0);
						if ((chr == 'r') || (chr == 'e') || (chr == 'y')) {
							isRegular = true;
						} else {
							isRegular = false;
						}
					}
				}
				
					if (!isRegular) {
						txForm = new BasicTexturedForm(form, texture_out, texture_in);
					} else {
						txForm = new BasicTexturedForm(form, texture_in, texture_out);
					}
				}
				
				//System.out.println("TXFRM: "+txForm);
				Solid solid = new BasicSolid(txForm, new IsotropicVolume(form.getVolumeValue())); 
				solids.addSolid(solid);
				txFormList.add(txForm);
				txFormNamesList.add(purify(xfx.toExampleString()));
				//txFormFullNamesList.add(xfx.toExampleString());
				//texturesInfoList.add(xtx.toExampleString());
				
				System.out.println("Added: "+form.toString()+"\n#####\n"+texture.toString());
				
				return;
			}
		});
        shapeSelectPanel.add(addShapeButton);
        
        // Transform Settings - Shape panelin alt kısmında
        JPanel transformPanel = new JPanel(new GridLayout(4, 4, 5, 5));
        transformPanel.add(getLabel("Transform Order:"));
        torderField.setForeground(Color.RED);
        torderField.setColumns(6);
        transformPanel.add(torderField);
        transformPanel.add(getLabel(""));
        transformPanel.add(getLabel(""));
        transformPanel.add(getLabel("TranslateXYZ(+fwd/left/u):"));
        txField.setForeground(Color.MAGENTA);
        txField.setColumns(6);
        transformPanel.add(txField);
        tyField.setForeground(Color.MAGENTA);
        tyField.setColumns(6);
        transformPanel.add(tyField);
        tzField.setForeground(Color.MAGENTA);
        tzField.setColumns(6);
        transformPanel.add(tzField);   
        
        transformPanel.add(getLabel("RotateXYZ:"));
        rxField.setForeground(Color.GREEN.darker());
        rxField.setColumns(6);
        transformPanel.add(rxField);
        ryField.setForeground(Color.GREEN.darker());
        ryField.setColumns(6);
        transformPanel.add(ryField);
        rzField.setForeground(Color.GREEN.darker());
        rzField.setColumns(6);
        transformPanel.add(rzField);
        
        transformPanel.add(getLabel("ScaleXYZ:"));
        sxField.setForeground(Color.RED);
        sxField.setColumns(6);
        transformPanel.add(sxField);
        syField.setForeground(Color.RED);
        syField.setColumns(6);
        transformPanel.add(syField);
        szField.setForeground(Color.RED);
        szField.setColumns(6);
        transformPanel.add(szField);
        
        //panel.add(transformPanel);
        
        // Shape Management
        JPanel shapeMgmtPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));

        JButton remSelectedShapesButton = getButton("Remove Selected Shapes");
        remSelectedShapesButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				if (solids.getList().size() < 1) return;
				//(solids.getList()).removeLast();
				//txFormList.removeLast();
				//txFormNamesList.removeLast();
				final int size = txFormList.size();
				 
				StringBuffer ubuf = new StringBuffer("SHAPES/GEOMETRIES: \n");
					for (int i = 0; i < size; i++) {
						ubuf.append("" + (i) + ": ");
						ubuf.append(txFormNamesList.get(i));
						ubuf.append("\n");
					}
					ubuf.append("Enter the numbers of shapes for remove, separated with comma:###\n");
					
					UNIINTAREA.setText(ubuf.toString());
					
					int iline = JOptionPane.showOptionDialog (paintPanel, JSPUNIINT,
					"Enter selected shapes for remove:",
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.PLAIN_MESSAGE,
					null,
					OPTVALS,
					OPTVALS [0]);
          
				    if ((iline < 0) || (iline > 0)) return;//Cancel
					
					String hes = UNIINTAREA.getText();
					int hesindex = hes.lastIndexOf("###");
					hes = hes.substring(hesindex+3);
					hes = hes.replaceAll("\n", "");
					hes = hes.replaceAll(" ", "");
					
					String[] split = hes.split(",");
					int slen = split.length;
					
					int numTx = -1;

					int[] numbers=new int[slen];
					for (int i = 0; i < slen; i++) {
						numTx = Integer.parseInt(split[i]);
						numbers[i]=numTx;
					}
					java.util.Arrays.sort(numbers);
					for (int i = (slen-1); i >= 0; i--) {
						(solids.getList()).remove(numbers[i]);
						txFormList.remove(numbers[i]);
						txFormNamesList.remove(numbers[i]);
						//txFormFullNamesList.remove(numbers[i]);
						//texturesInfoList.remove(numbers[i]);
					}
					
				return;
			}
		});
        shapeMgmtPanel.add(remSelectedShapesButton);
        
        JButton remLastShapeButton = getButton("Remove Last Shape");
        remLastShapeButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				if (solids.getList().size() < 1) return;
				System.out.println("Removing: "+(solids.getList().getLast().toString()));
				(solids.getList()).removeLast();
				txFormList.removeLast();
				txFormNamesList.removeLast();
				//texturesInfoList.removeLast();
				//txFormFullNamesList.removeLast();
				return;
			}
		});
        shapeMgmtPanel.add(remLastShapeButton);
        
        JButton remAllShapesButton = getButton("Remove All Shapes");
        remAllShapesButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				if (solids.getList().size() < 1) return;
				(solids.getList()).clear();
				txFormList.clear();
				txFormNamesList.clear();
				//texturesInfoList.clear();
				//txFormFullNamesList.clear();
				System.out.println("Removed all solids from list.");
				return;
			}
		});
        shapeMgmtPanel.add(remAllShapesButton);
        
         // LAYOUT DÜZENİ:
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.add(transformPanel, BorderLayout.CENTER);
    
		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.add(shapeMgmtPanel, BorderLayout.NORTH);
		centerPanel.add(shapeSelectPanel, BorderLayout.CENTER);
		
		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(centerPanel, BorderLayout.CENTER);
    
		return panel;
	}
    
    private final String purify(String descx) {
		String desc = descx;
		int index = desc.indexOf("(");
		desc = desc.substring(0, index);
		index = desc.indexOf(":");
		desc = desc.substring(index+1);
		desc = desc.trim();
		
		StringBuffer sb = new StringBuffer();
		sb.append(desc);
		sb.append("=");
		
		index = descx.lastIndexOf("###");
		String m = descx.substring(index+3);
		//m = m.replaceAll(" ", "");
		m = m.replaceAll("\n", "");
		
		sb.append(m);
		
		return sb.toString(); 
	}
	
    private final JLabel getLabel(String t) {
        JLabel label = new JLabel(t, JLabel.LEFT);
        label.setForeground(Color.GREEN.darker());
        label.setBackground(Color.BLACK);
        label.setFont(new Font("Serif", Font.BOLD, 14));
        return label;
    }
    
    private final JTextField getField(String t) {
        JTextField field = new JTextField(t);
        field.setForeground(Color.BLUE);
        field.setBackground(Color.WHITE);
        field.setFont(new Font("Serif", Font.BOLD, 16));
        return field;
    }

    private final JTextArea getTextArea(int u, int v) {
        JTextArea area = new JTextArea(u, v);
        area.setForeground(Color.BLUE);
        area.setBackground(Color.WHITE);
        area.setFont(new Font("Arial", Font.BOLD, 20));
        return area;
    }

    private final JButton getButton(String t) {
        JButton button = new JButton(t);
        button.setForeground(Color.BLUE);
        button.setBackground(new Color(0.9f, 0.9f, 0.9f));
        button.setFont(new Font("Serif", Font.BOLD, 14));
        return button;
    }
    
    private final JComboBox getComboBox(String[] strs) {
        JComboBox<String> box = new JComboBox(strs);
        box.setForeground(Color.BLUE);
        box.setBackground(Color.WHITE);
        box.setFont(new Font("Serif", Font.BOLD, 14));
        return box; 
    }
    
    private Matrix4 getTransform() {
		try {
			double tx = Double.parseDouble(txField.getText());
			double ty = Double.parseDouble(tyField.getText());
			double tz = Double.parseDouble(tzField.getText());
			
			double rx = Double.parseDouble(rxField.getText());
			double ry = Double.parseDouble(ryField.getText());
			double rz = Double.parseDouble(rzField.getText());
			
			double sx = Double.parseDouble(sxField.getText());
			double sy = Double.parseDouble(syField.getText());
			double sz = Double.parseDouble(szField.getText());
			
			Matrix4 mtr = new Matrix4();
			
			String mtext = (torderField.getText()).trim();
			if (mtext.length () < 3) {
				JOptionPane.showMessageDialog(paintPanel, "Order must be like TRS.");
				return mtr;
			}
			
			mtext = mtext.toLowerCase();
			
			char chr = mtext.charAt(0);
			if (chr == 't') {
				mtr = Matrix4.translate(tx, ty, tz);
			} else if (chr == 'r') {
				if (rx != 0.0 || ry != 0.0 || rz != 0.0) {
					mtr = Matrix4.rotateXYZ(rx, ry, rz);
				}
			} else if (chr == 's') {
				if (sx != 1.0 || sy != 1.0 || sz != 1.0) {
					mtr = Matrix4.scale(sx, sy, sz);
				}
			} else {
			}
			
			chr = mtext.charAt(1);
			if (chr == 't') {
				mtr = mtr.multiply(Matrix4.translate(tx, ty, tz));
			} else if (chr == 'r') {
				if (rx != 0.0 || ry != 0.0 || rz != 0.0) {
					mtr = mtr.multiply(Matrix4.rotateXYZ(rx, ry, rz));
				}
			} else if (chr == 's') {
				if (sx != 1.0 || sy != 1.0 || sz != 1.0) {
					mtr = mtr.multiply(Matrix4.scale(sx, sy, sz));
				}
			} else {
			}
			
			chr = mtext.charAt(2);
			if (chr == 't') {
				mtr = mtr.multiply(Matrix4.translate(tx, ty, tz));
			} else if (chr == 'r') {
				if (rx != 0.0 || ry != 0.0 || rz != 0.0) {
					mtr = mtr.multiply(Matrix4.rotateXYZ(rx, ry, rz));
				}
			} else if (chr == 's') {
				if (sx != 1.0 || sy != 1.0 || sz != 1.0) {
					mtr = mtr.multiply(Matrix4.scale(sx, sy, sz));
				}
			} else {
			}
			
			System.out.println("Transform:\n"+mtr);
			return mtr;
		} catch (NumberFormatException nfe) {
			nfe.printStackTrace();
			return new Matrix4();
		}
	}
	
	private static final void forCompileNames() {
		AdvancedRayTracer advancedraytracer_variable = null;
		AfricanKenteTexture africankentetexture_variable = null;
		Aggregate aggregate_variable = null;
		AnisotropicMetalTexture anisootropicmetaltexture_variable = null;
		AnodizedTexture anodizedtexture_variable = null;
		AuroraCeramicTexture auroraceramictexture_variable = null;
		BasicForm basicform_variable = null;
		BasicRenderer basicrenderer_variable = null;
		BasicSampler basicsampler_variable = null;
		BasicSolid basicsolid_variable = null;
		BasicTexturedForm basictexturedform_variable = null;
		Billboard billboard_variable = null;
		Camera camera_variable = null;
		CeramicTileTexture ceramictiletexture_variable = null;
		CheckerboardTexture checkerboardtexture_variable = null;
		ColorWheelTexture colorwheeltexture_variable = null; 
		Complement complement_variable = null;
		CompositeForm compositeform_variable = null;
		Cone cone_variable = null;
		CrystalCaveTexture crystalcavetexture_variable = null;
		Cylinder cylinder_variable = null;
		raja.test.DamierTexture damiertexture_variable = null;
		DiadicSampler diadicsampler_variable = null;
		DielectricTexture dielectrictexture_variable = null;
		DirectedGraph directedgraph_variable = null;
		DirectionalLightSource directionallightsource_variable = null;
		DreamMistTexture dreammisttexture_variable = null;
		EmissiveTexture emissivetexture_variable = null;
		FileHelper filehelper_variable = null;
		Form form_variable = null;
		GridTexture gridtexture_variable = null;
		raja.test.HamierTexture hamiertexture_variable = null;
		PatternTexture patterntexture_variable = null;
		HokusaiTexture hokusaitexture_variable = null;
		HologramTexture hologramtexture_variable = null;
		HorizontalCamera horizontalcamera_variable = null;
		ImageSpheringTexture imagespheringtexture_variable = null;
		ImageTexture imagetexture_variable = null;
		Intersection intersection_variable = null;
		IsotropicVolume isotropicvolume_variable = null;
		KilimRosemalingTexture kilimrosemalingtexture_variable = null;
		LambertianTexture lambertiantexture_variable = null;
		LavaTexture lavatexture_variable = null;
		LightRay lightray_variable = null;
		LightSource lightsource_variable = null;
		LocalGeometry localgeometry_variable = null;
		LocalTexture localtexture_variable = null;
		raja.test.MamierTexture mamiertexture_variable = null;
		MarbleTexture marbletexture_variable = null;
		Matrix3 matrix3_variable = null;
		Matrix4 matrix4_variable = null;
		MBox mbox_variable = null;
		MCone mcone_variable = null;
		MCylinder mcylinder_variable = null;
		MetalTexture metaltexture_variable = null;
		MPlane mplane_variable = null;
		MSphere msphere_variable = null;
		MTorus mtorus_variable = null;
		MTriangle mtriangle_variable = null;
		NaiveSuperSampler naivesupersampler_variable = null;
		NordicWeaveTexture nordicweavetexture_variable = null;
		NorthernLightTexture northernlighttexture_variable = null;
		NorwegianRoseTexture norwegianrosetexture_variable = null;
		raja.io.ObjectReader objectreader_variable = null;
		raja.io.ObjectWriter objectwriter_variable = null;
		ObsidianHeartTexture obsidianhearttexture_variable = null;
		PlainTexture plaintexture_variable = null;
		Plane plane_variable = null;
		PlasticTexture plastictexture_variable = null;
		Point2D point2d_variable = null;
		Point3D point3d_variable = null;
		PointLightSource pointlightsource_variable = null;
		PrismTexture prismtexture_variable = null;
		Ray ray_variable = null;
		RayTracer raytracer_variable = null;
		raja.renderer.Renderer renderer_variable = null;
		Resolution resolution_variable = null;
		RGB rgb_variable = null;
		Sampler sampler_variable = null;
		SandTexture sandtexture_variable = null;
		Scene scene_variable = null;
		Solid solid_variable = null;
		SolidLocalGeometry solidlocalgeometry_variable = null;
		Sphere sphere_variable = null;
		SpotLightSource spotlightsource_variable = null;
		StereoCamera stereocamera_variable = null;
		StormTexture stormtexture_variable = null;
		StripesTexture stripestexture_variable = null;
		Texture texture_variable = null;
		TexturedForm texturedform_variable = null;
		TexturedLocalGeometry texturedlocalgeometry_variable = null;
		TiledRoofTexture tiledrooftexture_variable = null;
		TransparentPNGTexture transparentpngtexture_variable = null;
		TurkishTileTexture turkishtiletexture_variable = null;
		Union union_variable = null;
		Vector3D vector3d_variable = null;
		VoidTexture voidtexture_variable = null;
		Volume volume_variable = null;
		WaterTexture watertexture_variable = null;
		WoodTexture woodtexture_variable = null;
		World world_variable = null;
		XDamierTexture xdamiertexture_variable = null;
		XPlainTexture xplaintexture_variable = null;
		XRayTexture xraytexture_variable = null;
		XRectangle xrectangle_variable = null;
  }
  
  // CREATE Button Action
  public void actionPerformed(ActionEvent evt) {
	  Thread thr = new Thread() {
		  public void run() {
			  processing = true;
			  createButton.setEnabled (false);
			  
			  try {
				drawScene(); // this too runs under his own thread
		      } catch (Exception e) {
				e.printStackTrace ();
				processing = false;
				createButton.setEnabled (true);
			  }
			  
			  createButton.setEnabled (true);
			  processing = false;
		  }
	  };
	  thr.start();
  }
  
  private final void drawScene() {
     processing = true; 
     bimg = new BufferedImage(width, height,  BufferedImage.TYPE_INT_ARGB);
     paintPanel.setBufferedImage(bimg);
     
     createButton.setEnabled(false);
     Thread thr = new Thread() {
		public void run() {
			while(processing) {
				paintPanel.repaint();
				//try { 
					//sleep (MILS);
				//} catch (InterruptedException ie) {
				//}
			}
		} 
	 };
	 thr.start();
	 
	 bar.setValue (0);
	 
	 // For easy object output
	 world.setCamera(camera);
	 world.setImageWidth(width);
	 world.setImageHeight(height);
	 world.setImageDepth(depth);
	 ///////
	 final RayTracer tracer = new AdvancedRayTracer(world, depth);

	 try {
	    sampler.compute(camera, tracer, bar.getModel(), bimg);
	 }
	 catch (Exception e)
	 {
	    createButton.setEnabled (true);
	    JOptionPane.showMessageDialog (paintPanel, "Error Computing!!!!");
	    processing=false;
	    bar.setValue (0);
	    return;
	}
	
	processing = false;
	createButton.setEnabled(true);
	bar.setValue (0);
	
	return;
  }
  
  private static final void showScreen() {
	////////
	forCompileNames();
	////////
	
	JFrame fr = new JFrame("Raja Ray Tracer GUI");
	fr.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	
	JComponent jc = new RajaRayTracerGUI();
	jc.setOpaque(true);
	fr.setContentPane(jc);
	
	fr.pack();
	fr.setSize(1360, 720);
	fr.setResizable(true);
	fr.setLocationRelativeTo(null);
	fr.setVisible(true);
	
	return;
  }
  
  public static final void main(final String[] args) {
	javax.swing.SwingUtilities.invokeLater(new Runnable() {
		public void run() {
			showScreen();
		}
	});
  }

} // class end


